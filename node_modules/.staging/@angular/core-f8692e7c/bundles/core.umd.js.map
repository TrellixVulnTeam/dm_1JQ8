{"version":3,"file":"core.umd.js","sources":["../../../../../external/npm/node_modules/tslib/tslib.es6.js","../../../../../../../packages/core/src/util/decorators.ts","../../../../../packages/core/src/di/metadata.ts","../../../../../../../../packages/core/src/di/interface/injector.ts","../../../../../../../packages/core/src/util/property.ts","../../../../../../../../packages/core/src/di/interface/defs.ts","../../../../../../../packages/core/src/util/stringify.ts","../../../../../packages/core/src/di/forward_ref.ts","../../../../../../../packages/core/src/util/global.ts","../../../../../../../packages/core/src/compiler/compiler_facade_interface.ts","../../../../../../../packages/core/src/compiler/compiler_facade.ts","../../../../../packages/core/src/render3/fields.ts","../../../../../packages/core/src/di/injection_token.ts","../../../../../packages/core/src/di/injector_compatibility.ts","../../../../../packages/core/src/di/jit/environment.ts","../../../../../packages/core/src/linker/ng_module_factory.ts","../../../../../../../packages/core/src/util/array_utils.ts","../../../../../../../packages/core/src/util/assert.ts","../../../../../packages/core/src/change_detection/constants.ts","../../../../../packages/core/src/metadata/view.ts","../../../../../../../packages/core/src/util/closure.ts","../../../../../../../packages/core/src/util/ng_dev_mode.ts","../../../../../packages/core/src/render3/empty.ts","../../../../../packages/core/src/render3/definition.ts","../../../../../packages/core/src/render3/interfaces/view.ts","../../../../../packages/core/src/render3/interfaces/container.ts","../../../../../packages/core/src/render3/interfaces/type_checks.ts","../../../../../packages/core/src/render3/assert.ts","../../../../../packages/core/src/render3/state.ts","../../../../../packages/core/src/render3/hooks.ts","../../../../../packages/core/src/render3/interfaces/injector.ts","../../../../../packages/core/src/render3/node_assert.ts","../../../../../packages/core/src/render3/interfaces/document.ts","../../../../../packages/core/src/render3/interfaces/renderer.ts","../../../../../packages/core/src/render3/util/attrs_utils.ts","../../../../../packages/core/src/render3/util/injector_utils.ts","../../../../../packages/core/src/render3/util/misc_utils.ts","../../../../../packages/core/src/sanitization/bypass.ts","../../../../../packages/core/src/render3/tokens.ts","../../../../../packages/core/src/render3/util/styling_utils.ts","../../../../../packages/core/src/render3/di.ts","../../../../../../../packages/core/src/util/errors.ts","../../../../../packages/core/src/errors.ts","../../../../../packages/core/src/error_handler.ts","../../../../../packages/core/src/metadata/schema.ts","../../../../../../../packages/core/src/util/is_dev_mode.ts","../../../../../packages/core/src/sanitization/inert_body.ts","../../../../../packages/core/src/sanitization/url_sanitizer.ts","../../../../../packages/core/src/sanitization/html_sanitizer.ts","../../../../../packages/core/src/sanitization/security.ts","../../../../../packages/core/src/sanitization/style_sanitizer.ts","../../../../../packages/core/src/sanitization/sanitization.ts","../../../../../../../packages/core/src/util/named_array_type.ts","../../../../../../../packages/core/src/util/ng_reflect.ts","../../../../../packages/core/src/render3/interfaces/context.ts","../../../../../packages/core/src/render3/util/view_utils.ts","../../../../../packages/core/src/render3/context_discovery.ts","../../../../../packages/core/src/render3/errors.ts","../../../../../packages/core/src/render3/interfaces/node.ts","../../../../../packages/core/src/render3/interfaces/projection.ts","../../../../../packages/core/src/render3/node_selector_matcher.ts","../../../../../packages/core/src/render3/styling/state.ts","../../../../../packages/core/src/render3/styling/bindings.ts","../../../../../packages/core/src/render3/util/view_traversal_utils.ts","../../../../../packages/core/src/render3/instructions/advance.ts","../../../../../packages/core/src/render3/interfaces/i18n.ts","../../../../../packages/core/src/debug/proxy.ts","../../../../../packages/core/src/render3/util/debug_utils.ts","../../../../../packages/core/src/render3/styling/map_based_bindings.ts","../../../../../packages/core/src/render3/styling/styling_debug.ts","../../../../../packages/core/src/render3/instructions/lview_debug.ts","../../../../../packages/core/src/render3/instructions/shared.ts","../../../../../packages/core/src/render3/node_manipulation.ts","../../../../../packages/core/src/render3/node_util.ts","../../../../../packages/core/src/render3/view_ref.ts","../../../../../packages/core/src/render3/view_engine_compatibility.ts","../../../../../packages/core/src/change_detection/change_detector_ref.ts","../../../../../../../packages/core/src/interface/type.ts","../../../../../../../packages/core/src/reflection/reflection_capabilities.ts","../../../../../packages/core/src/di/jit/util.ts","../../../../../packages/core/src/di/jit/injectable.ts","../../../../../packages/core/src/di/util.ts","../../../../../packages/core/src/di/injectable.ts","../../../../../packages/core/src/di/scope.ts","../../../../../packages/core/src/di/r3_injector.ts","../../../../../packages/core/src/di/injector.ts","../../../../../packages/core/src/di/reflective_errors.ts","../../../../../packages/core/src/di/reflective_key.ts","../../../../../../../packages/core/src/reflection/reflector.ts","../../../../../../../packages/core/src/reflection/reflection.ts","../../../../../packages/core/src/di/reflective_provider.ts","../../../../../packages/core/src/di/reflective_injector.ts","../../../../../packages/core/src/di/index.ts","../../../../../packages/core/src/di.ts","../../../../../packages/core/src/metadata/di.ts","../../../../../packages/core/src/metadata/resource_loading.ts","../../../../../packages/core/src/render3/instructions/alloc_host_vars.ts","../../../../../../../packages/core/src/util/symbol.ts","../../../../../../../packages/core/src/util/iterable.ts","../../../../../../../packages/core/src/util/comparison.ts","../../../../../packages/core/src/change_detection/change_detection_util.ts","../../../../../packages/core/src/render3/bindings.ts","../../../../../packages/core/src/render3/instructions/attribute.ts","../../../../../packages/core/src/render3/instructions/interpolation.ts","../../../../../packages/core/src/render3/instructions/attribute_interpolation.ts","../../../../../packages/core/src/render3/instructions/change_detection.ts","../../../../../packages/core/src/render3/instructions/container.ts","../../../../../packages/core/src/render3/instructions/storage.ts","../../../../../packages/core/src/render3/instructions/di.ts","../../../../../packages/core/src/render3/instructions/styling.ts","../../../../../packages/core/src/render3/instructions/element.ts","../../../../../packages/core/src/render3/instructions/element_container.ts","../../../../../packages/core/src/render3/instructions/embedded_view.ts","../../../../../packages/core/src/render3/instructions/get_current_view.ts","../../../../../../../packages/core/src/util/lang.ts","../../../../../packages/core/src/render3/instructions/listener.ts","../../../../../packages/core/src/render3/instructions/namespace.ts","../../../../../packages/core/src/render3/instructions/next_context.ts","../../../../../packages/core/src/render3/instructions/projection.ts","../../../../../packages/core/src/render3/instructions/property.ts","../../../../../packages/core/src/render3/instructions/property_interpolation.ts","../../../../../packages/core/src/render3/instructions/text.ts","../../../../../packages/core/src/render3/instructions/text_interpolation.ts","../../../../../packages/core/src/render3/instructions/class_map_interpolation.ts","../../../../../packages/core/src/render3/instructions/style_prop_interpolation.ts","../../../../../packages/core/src/render3/instructions/host_property.ts","../../../../../packages/core/src/render3/instructions/all.ts","../../../../../packages/core/src/render3/util/discovery_utils.ts","../../../../../packages/core/src/render3/global_utils_api.ts","../../../../../packages/core/src/render3/util/global_utils.ts","../../../../../packages/core/src/render3/component.ts","../../../../../packages/core/src/render3/features/inherit_definition_feature.ts","../../../../../packages/core/src/render3/features/copy_definition_feature.ts","../../../../../../../packages/core/src/interface/simple_change.ts","../../../../../packages/core/src/render3/features/ng_onchanges_feature.ts","../../../../../packages/core/src/render3/di_setup.ts","../../../../../packages/core/src/render3/features/providers_feature.ts","../../../../../packages/core/src/linker/component_factory.ts","../../../../../packages/core/src/linker/component_factory_resolver.ts","../../../../../../../packages/core/src/util/noop.ts","../../../../../packages/core/src/linker/element_ref.ts","../../../../../packages/core/src/render/api.ts","../../../../../packages/core/src/sanitization/sanitizer.ts","../../../../../packages/core/src/version.ts","../../../../../packages/core/src/change_detection/differs/default_iterable_differ.ts","../../../../../packages/core/src/change_detection/differs/default_keyvalue_differ.ts","../../../../../packages/core/src/change_detection/differs/iterable_differs.ts","../../../../../packages/core/src/change_detection/differs/keyvalue_differs.ts","../../../../../packages/core/src/change_detection/change_detection.ts","../../../../../packages/core/src/linker/template_ref.ts","../../../../../packages/core/src/linker/view_container_ref.ts","../../../../../packages/core/src/view/errors.ts","../../../../../packages/core/src/view/types.ts","../../../../../packages/core/src/view/util.ts","../../../../../packages/core/src/view/ng_module.ts","../../../../../packages/core/src/view/view_attach.ts","../../../../../packages/core/src/view/refs.ts","../../../../../packages/core/src/view/provider.ts","../../../../../packages/core/src/render3/component_ref.ts","../../../../../../../packages/core/src/util/ng_i18n_closure_mode.ts","../../../../../packages/core/src/i18n/locale_en.ts","../../../../../packages/core/src/i18n/locale_data_api.ts","../../../../../packages/core/src/i18n/localization.ts","../../../../../packages/core/src/render3/i18n.ts","../../../../../packages/core/src/linker/ng_module_factory_registration.ts","../../../../../packages/core/src/render3/ng_module_ref.ts","../../../../../packages/core/src/render3/metadata.ts","../../../../../packages/core/src/render3/pure_function.ts","../../../../../packages/core/src/render3/pipe.ts","../../../../../packages/core/src/event_emitter.ts","../../../../../packages/core/src/linker/query_list.ts","../../../../../packages/core/src/render3/interfaces/definition.ts","../../../../../packages/core/src/render3/interfaces/query.ts","../../../../../packages/core/src/render3/query.ts","../../../../../packages/core/src/render3/view_engine_compatibility_prebound.ts","../../../../../packages/core/src/render3/index.ts","../../../../../packages/core/src/render3/jit/environment.ts","../../../../../packages/core/src/render3/jit/module.ts","../../../../../packages/core/src/render3/jit/directive.ts","../../../../../packages/core/src/render3/jit/pipe.ts","../../../../../packages/core/src/metadata/directives.ts","../../../../../packages/core/src/metadata/ng_module.ts","../../../../../packages/core/src/metadata.ts","../../../../../packages/core/src/application_init.ts","../../../../../packages/core/src/application_tokens.ts","../../../../../packages/core/src/console.ts","../../../../../packages/core/src/i18n/tokens.ts","../../../../../packages/core/src/ivy_switch.ts","../../../../../packages/core/src/linker/compiler.ts","../../../../../../../packages/core/src/util/microtask.ts","../../../../../../../packages/core/src/util/raf.ts","../../../../../packages/core/src/zone/ng_zone.ts","../../../../../packages/core/src/testability/testability.ts","../../../../../packages/core/src/application_ref.ts","../../../../../packages/core/src/zone.ts","../../../../../packages/core/src/render.ts","../../../../../packages/core/src/linker/ng_module_factory_loader.ts","../../../../../packages/core/src/linker/system_js_ng_module_factory_loader.ts","../../../../../packages/core/src/linker/view_ref.ts","../../../../../packages/core/src/linker.ts","../../../../../packages/core/src/debug/debug_node.ts","../../../../../packages/core/src/change_detection.ts","../../../../../packages/core/src/platform_core_providers.ts","../../../../../packages/core/src/application_module.ts","../../../../../packages/core/src/view/element.ts","../../../../../packages/core/src/view/query.ts","../../../../../packages/core/src/view/ng_content.ts","../../../../../packages/core/src/view/pure_expression.ts","../../../../../packages/core/src/view/text.ts","../../../../../packages/core/src/view/view.ts","../../../../../packages/core/src/view/services.ts","../../../../../packages/core/src/view/entrypoint.ts","../../../../../packages/core/src/view/index.ts","../../../../../packages/core/src/core_private_export.ts","../../../../../packages/core/src/core_render3_private_export.ts","../../../../../packages/core/src/codegen_private_exports.ts","../../../../../packages/core/src/core.ts","../../../../../packages/core/public_api.ts","../../../../../packages/core/index.ts","../../../../../packages/core/core.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\n\n/**\n * An interface implemented by all Angular type decorators, which allows them to be used as\n * decorators as well as Angular syntax.\n *\n * ```\n * @ng.Component({...})\n * class MyClass {...}\n * ```\n *\n * @publicApi\n */\nexport interface TypeDecorator {\n  /**\n   * Invoke as decorator.\n   */\n  <T extends Type<any>>(type: T): T;\n\n  // Make TypeDecorator assignable to built-in ParameterDecorator type.\n  // ParameterDecorator is declared in lib.d.ts as a `declare type`\n  // so we cannot declare this interface as a subtype.\n  // see https://github.com/angular/angular/issues/3379#issuecomment-126169417\n  (target: Object, propertyKey?: string|symbol, parameterIndex?: number): void;\n}\n\nexport const ANNOTATIONS = '__annotations__';\nexport const PARAMETERS = '__parameters__';\nexport const PROP_METADATA = '__prop__metadata__';\n\n/**\n * @suppress {globalThis}\n */\nexport function makeDecorator<T>(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (type: Type<T>) => void,\n    typeFn?: (type: Type<T>, ...args: any[]) => void):\n    {new (...args: any[]): any; (...args: any[]): any; (...args: any[]): (cls: any) => any;} {\n  const metaCtor = makeMetadataCtor(props);\n\n  function DecoratorFactory(\n      this: unknown | typeof DecoratorFactory, ...args: any[]): (cls: Type<T>) => any {\n    if (this instanceof DecoratorFactory) {\n      metaCtor.call(this, ...args);\n      return this as typeof DecoratorFactory;\n    }\n\n    const annotationInstance = new (DecoratorFactory as any)(...args);\n    return function TypeDecorator(cls: Type<T>) {\n      if (typeFn) typeFn(cls, ...args);\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const annotations = cls.hasOwnProperty(ANNOTATIONS) ?\n          (cls as any)[ANNOTATIONS] :\n          Object.defineProperty(cls, ANNOTATIONS, {value: []})[ANNOTATIONS];\n      annotations.push(annotationInstance);\n\n\n      if (additionalProcessing) additionalProcessing(cls);\n\n      return cls;\n    };\n  }\n\n  if (parentClass) {\n    DecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  DecoratorFactory.prototype.ngMetadataName = name;\n  (DecoratorFactory as any).annotationCls = DecoratorFactory;\n  return DecoratorFactory as any;\n}\n\nfunction makeMetadataCtor(props?: (...args: any[]) => any): any {\n  return function ctor(this: any, ...args: any[]) {\n    if (props) {\n      const values = props(...args);\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\n\nexport function makeParamDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any): any {\n  const metaCtor = makeMetadataCtor(props);\n  function ParamDecoratorFactory(\n      this: unknown | typeof ParamDecoratorFactory, ...args: any[]): any {\n    if (this instanceof ParamDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n    const annotationInstance = new (<any>ParamDecoratorFactory)(...args);\n\n    (<any>ParamDecorator).annotation = annotationInstance;\n    return ParamDecorator;\n\n    function ParamDecorator(cls: any, unusedKey: any, index: number): any {\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const parameters = cls.hasOwnProperty(PARAMETERS) ?\n          (cls as any)[PARAMETERS] :\n          Object.defineProperty(cls, PARAMETERS, {value: []})[PARAMETERS];\n\n      // there might be gaps if some in between parameters do not have annotations.\n      // we pad with nulls.\n      while (parameters.length <= index) {\n        parameters.push(null);\n      }\n\n      (parameters[index] = parameters[index] || []).push(annotationInstance);\n      return cls;\n    }\n  }\n  if (parentClass) {\n    ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n  ParamDecoratorFactory.prototype.ngMetadataName = name;\n  (<any>ParamDecoratorFactory).annotationCls = ParamDecoratorFactory;\n  return ParamDecoratorFactory;\n}\n\nexport function makePropDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (target: any, name: string, ...args: any[]) => void): any {\n  const metaCtor = makeMetadataCtor(props);\n\n  function PropDecoratorFactory(this: unknown | typeof PropDecoratorFactory, ...args: any[]): any {\n    if (this instanceof PropDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n\n    const decoratorInstance = new (<any>PropDecoratorFactory)(...args);\n\n    function PropDecorator(target: any, name: string) {\n      const constructor = target.constructor;\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const meta = constructor.hasOwnProperty(PROP_METADATA) ?\n          (constructor as any)[PROP_METADATA] :\n          Object.defineProperty(constructor, PROP_METADATA, {value: {}})[PROP_METADATA];\n      meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n      meta[name].unshift(decoratorInstance);\n\n      if (additionalProcessing) additionalProcessing(target, name, ...args);\n    }\n\n    return PropDecorator;\n  }\n\n  if (parentClass) {\n    PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  PropDecoratorFactory.prototype.ngMetadataName = name;\n  (<any>PropDecoratorFactory).annotationCls = PropDecoratorFactory;\n  return PropDecoratorFactory;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {makeParamDecorator} from '../util/decorators';\n\n\n\n/**\n * Type of the Inject decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectDecorator {\n  /**\n   * Parameter decorator on a dependency parameter of a class constructor\n   * that specifies a custom provider of the dependency.\n   *\n   * Learn more in the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * The following example shows a class constructor that specifies a\n   * custom provider of a dependency using the parameter decorator.\n   *\n   * When `@Inject()` is not present, the injector uses the type annotation of the\n   * parameter as the provider.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"InjectWithoutDecorator\">\n   * </code-example>\n   */\n  (token: any): any;\n  new (token: any): Inject;\n}\n\n/**\n * Type of the Inject metadata.\n *\n * @publicApi\n */\nexport interface Inject {\n  /**\n   * A [DI token](guide/glossary#di-token) that maps to the dependency to be injected.\n   */\n  token: any;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Inject: InjectDecorator = makeParamDecorator('Inject', (token: any) => ({token}));\n\n\n/**\n * Type of the Optional decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OptionalDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which marks the parameter as being an optional dependency.\n   * The DI framework provides null if the dependency is not found.\n   *\n   * Can be used together with other parameter decorators\n   * that modify how dependency injection operates.\n   *\n   * Learn more in the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   *\n   * The following code allows the possibility of a null result:\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Optional\">\n   * </code-example>\n   *\n   */\n  (): any;\n  new (): Optional;\n}\n\n/**\n * Type of the Optional metadata.\n *\n * @publicApi\n */\nexport interface Optional {}\n\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Optional: OptionalDecorator = makeParamDecorator('Optional');\n\n/**\n * Type of the Self decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the local injector.\n   *\n   * Resolution works upward through the injector hierarchy, so the children\n   * of this class must configure their own providers or be prepared for a null result.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved\n   * by the local injector when instantiating the class itself, but not\n   * when instantiating a child.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Self\">\n   * </code-example>\n   *\n   *\n   * @see `SkipSelf`\n   * @see `Optional`\n   *\n   */\n  (): any;\n  new (): Self;\n}\n\n/**\n * Type of the Self metadata.\n *\n * @publicApi\n */\nexport interface Self {}\n\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Self: SelfDecorator = makeParamDecorator('Self');\n\n\n/**\n * Type of the SkipSelf decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SkipSelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the parent injector.\n   * Resolution works upward through the injector hierarchy, so the local injector\n   * is not checked for a provider.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved when\n   * instantiating a child, but not when instantiating the class itself.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"SkipSelf\">\n   * </code-example>\n   *\n   * Learn more in the\n   * [Dependency Injection guide](guide/dependency-injection-in-action#skip).\n   *\n   * @see `Self`\n   * @see `Optional`\n   *\n   */\n  (): any;\n  new (): SkipSelf;\n}\n\n/**\n * Type of the SkipSelf metadata.\n *\n * @publicApi\n */\nexport interface SkipSelf {}\n\n/**\n * SkipSelf decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const SkipSelf: SkipSelfDecorator = makeParamDecorator('SkipSelf');\n\n/**\n * Type of the Host decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostDecorator {\n  /**\n   * Parameter decorator on a view-provider parameter of a class constructor\n   * that tells the DI framework to resolve the view by checking injectors of child\n   * elements, and stop when reaching the host element of the current component.\n   *\n   * For an extended example, see\n   * [\"Dependency Injection Guide\"](guide/dependency-injection-in-action#optional).\n   *\n   * @usageNotes\n   *\n   * The following shows use with the `@Optional` decorator, and allows for a null result.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Host\">\n   * </code-example>\n   */\n  (): any;\n  new (): Host;\n}\n\n/**\n * Type of the Host metadata.\n *\n * @publicApi\n */\nexport interface Host {}\n\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Host: HostDecorator = makeParamDecorator('Host');\n\n\n/**\n * Type of the Attribute decorator / constructor function.\n *\n * @publicApi\n */\nexport interface AttributeDecorator {\n  /**\n   * Parameter decorator for a directive constructor that designates\n   * a host-element attribute whose value is injected as a constant string literal.\n   *\n   * @usageNotes\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * The following example uses the decorator to inject the string literal `text`.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n   *\n   * ### Example as TypeScript Decorator\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n   *\n   */\n  (name: string): any;\n  new (name: string): Attribute;\n}\n\n/**\n * Type of the Attribute metadata.\n *\n * @publicApi\n */\nexport interface Attribute {\n  /**\n   * The name of the attribute whose value can be injected.\n   */\n  attributeName?: string;\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Attribute: AttributeDecorator =\n    makeParamDecorator('Attribute', (attributeName?: string) => ({attributeName}));\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\nexport enum InjectFlags {\n  // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.\n\n  /** Check self and check parent injector if needed */\n  Default = 0b0000,\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n  /** Don't ascend to ancestors of the node requesting injection. */\n  Self = 0b0010,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty as any) {\n      return key;\n    }\n  }\n  throw Error('Could not find renamed property on target object.');\n}\n\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nexport function fillProperties(target: {[key: string]: string}, source: {[key: string]: string}) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../../interface/type';\nimport {getClosureSafeProperty} from '../../util/property';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, ValueProvider} from './provider';\n\n\n\n/**\n * Information about how a type or `InjectionToken` interfaces with the DI system.\n *\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\n * requesting injection of other types if necessary.\n *\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\n * `InjectorDef`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\n * that the injectable does not belong to any scope.\n *\n * NOTE: This is a private type and should not be exported\n *\n * @publicApi\n */\nexport interface ÉµÉµInjectableDef<T> {\n  /**\n   * Specifies that the given type belongs to a particular injector:\n   * - `InjectorType` such as `NgModule`,\n   * - `'root'` the root injector\n   * - `'any'` all injectors.\n   * - `null`, does not belong to any injector. Must be explicitly listed in the injector\n   *   `providers`.\n   */\n  providedIn: InjectorType<any>|'root'|'platform'|'any'|null;\n\n  /**\n   * The token to which this definition belongs.\n   *\n   * Note that this may not be the same as the type that the `factory` will create.\n   */\n  token: unknown;\n\n  /**\n   * Factory method to execute to create an instance of the injectable.\n   */\n  factory: (t?: Type<any>) => T;\n\n  /**\n   * In a case of no explicit injector, a location where the instance of the injectable is stored.\n   */\n  value: T|undefined;\n}\n\n/**\n * Information about the providers to be included in an `Injector` as well as how the given type\n * which carries the information should be created by the DI system.\n *\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\n * structure of providers with a defined priority (identically to how `NgModule`s also have\n * an import/dependency structure).\n *\n * NOTE: This is a private type and should not be exported\n *\n * @publicApi\n */\nexport interface ÉµÉµInjectorDef<T> {\n  factory: () => T;\n\n  // TODO(alxhub): Narrow down the type here once decorators properly change the return type of the\n  // class they are decorating (to add the Éµprov property for example).\n  providers: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n              StaticClassProvider|ClassProvider|any[])[];\n\n  imports: (InjectorType<any>|InjectorTypeWithProviders<any>)[];\n}\n\n/**\n * A `Type` which has an `InjectableDef` static field.\n *\n * `InjectableDefType`s contain their own Dependency Injection metadata and are usable in an\n * `InjectorDef`-based `StaticInjector.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  Éµprov: never;\n}\n\n/**\n * A type which has an `InjectorDef` static field.\n *\n * `InjectorDefTypes` can be used to configure a `StaticInjector`.\n *\n * @publicApi\n */\nexport interface InjectorType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  Éµinj: never;\n}\n\n/**\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorDefType` with an\n * associated array of providers.\n *\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorTypeWithProviders<T> {\n  ngModule: InjectorType<T>;\n  providers?: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n               StaticClassProvider|ClassProvider|any[])[];\n}\n\n\n/**\n * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and\n * in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `Éµprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @codeGenApi\n */\nexport function ÉµÉµdefineInjectable<T>(opts: {\n  token: unknown,\n  providedIn?: Type<any>| 'root' | 'platform' | 'any' | null,\n  factory: () => T,\n}): never {\n  return ({\n    token: opts.token, providedIn: opts.providedIn as any || null, factory: opts.factory,\n        value: undefined,\n  } as ÉµÉµInjectableDef<T>) as never;\n}\n\n/**\n * @deprecated in v8, delete after v10. This API should be used only be generated code, and that\n * code should now use ÉµÉµdefineInjectable instead.\n * @publicApi\n */\nexport const defineInjectable = ÉµÉµdefineInjectable;\n\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`Éµinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to\n *   create the type must be provided. If that factory function needs to inject arguments, it can\n *   use the `inject` function.\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `Éµprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @publicApi\n */\nexport function ÉµÉµdefineInjector(options: {factory: () => any, providers?: any[], imports?: any[]}):\n    never {\n  return ({\n    factory: options.factory, providers: options.providers || [], imports: options.imports || [],\n  } as ÉµÉµInjectorDef<any>) as never;\n}\n\n/**\n * Read the injectable def (`Éµprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `Éµprov`.\n */\nexport function getInjectableDef<T>(type: any): ÉµÉµInjectableDef<T>|null {\n  return getOwnDefinition(type, type[NG_PROV_DEF]) ||\n      getOwnDefinition(type, type[NG_INJECTABLE_DEF]);\n}\n\n/**\n * Return `def` only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n *\n * The function `Object.hasOwnProperty` is not sufficient to distinguish this case because in older\n * browsers (e.g. IE10) static property inheritance is implemented by copying the properties.\n *\n * Instead, the definition's `token` is compared to the `type`, and if they don't match then the\n * property was not defined directly on the type itself, and was likely inherited. The definition\n * is only returned if the `type` matches the `def.token`.\n */\nfunction getOwnDefinition<T>(type: any, def: ÉµÉµInjectableDef<T>): ÉµÉµInjectableDef<T>|null {\n  return def && def.token === type ? def : null;\n}\n\n/**\n * Read the injectable def (`Éµprov`) for `type` or read the `Éµprov` from one of its ancestors.\n *\n * @param type A type which may have `Éµprov`, via inheritance.\n *\n * @deprecated Will be removed in v10, where an error will occur in the scenario if we find the\n * `Éµprov` on an ancestor only.\n */\nexport function getInheritedInjectableDef<T>(type: any): ÉµÉµInjectableDef<T>|null {\n  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);\n  if (def) {\n    // TODO(FW-1307): Re-add ngDevMode when closure can handle it\n    // ngDevMode &&\n    console.warn(\n        `DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n        `This will become an error in v10. Please add @Injectable() to the \"${type.name}\" class.`);\n    return def;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`Éµinj`)\n */\nexport function getInjectorDef<T>(type: any): ÉµÉµInjectorDef<T>|null {\n  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ?\n      (type as any)[NG_INJ_DEF] :\n      null;\n}\n\nexport const NG_PROV_DEF = getClosureSafeProperty({Éµprov: getClosureSafeProperty});\nexport const NG_INJ_DEF = getClosureSafeProperty({Éµinj: getClosureSafeProperty});\n\n// We need to keep these around so we can read off old defs if new defs are unavailable\nexport const NG_INJECTABLE_DEF = getClosureSafeProperty({ngInjectableDef: getClosureSafeProperty});\nexport const NG_INJECTOR_DEF = getClosureSafeProperty({ngInjectorDef: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {getClosureSafeProperty} from '../util/property';\nimport {stringify} from '../util/stringify';\n\n\n\n/**\n * An interface that a function passed into {@link forwardRef} has to implement.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @publicApi\n */\nexport interface ForwardRefFn { (): any; }\n\nconst __forward_ref__ = getClosureSafeProperty({__forward_ref__: getClosureSafeProperty});\n\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\nexport function forwardRef(forwardRefFn: ForwardRefFn): Type<any> {\n  (<any>forwardRefFn).__forward_ref__ = forwardRef;\n  (<any>forwardRefFn).toString = function() { return stringify(this()); };\n  return (<Type<any>><any>forwardRefFn);\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\nexport function resolveForwardRef<T>(type: T): T {\n  return isForwardRef(type) ? type() : type;\n}\n\n/** Checks whether a function is wrapped by a `forwardRef`. */\nexport function isForwardRef(fn: any): fn is() => any {\n  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&\n      fn.__forward_ref__ === forwardRef;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// TODO(jteplitz602): Load WorkerGlobalScope from lib.webworker.d.ts file #3492\ndeclare var WorkerGlobalScope: any /** TODO #9100 */;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any /** TODO #9100 */;\n// Not yet available in TypeScript: https://github.com/Microsoft/TypeScript/pull/29332\ndeclare var globalThis: any /** TODO #9100 */;\n\nconst __globalThis = typeof globalThis !== 'undefined' && globalThis;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case.\nconst _global = __globalThis || __global || __window || __self;\n\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport {_global as global};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * A set of interfaces which are shared between `@angular/core` and `@angular/compiler` to allow\n * for late binding of `@angular/compiler` for JIT purposes.\n *\n * This file has two copies. Please ensure that they are in sync:\n *  - packages/compiler/src/compiler_facade_interface.ts             (master)\n *  - packages/core/src/render3/jit/compiler_facade_interface.ts     (copy)\n *\n * Please ensure that the two files are in sync using this command:\n * ```\n * cp packages/compiler/src/compiler_facade_interface.ts \\\n *    packages/core/src/render3/jit/compiler_facade_interface.ts\n * ```\n */\n\nexport interface ExportedCompilerFacade { ÉµcompilerFacade: CompilerFacade; }\n\nexport interface CompilerFacade {\n  compilePipe(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3PipeMetadataFacade):\n      any;\n  compileInjectable(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectableMetadataFacade): any;\n  compileInjector(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectorMetadataFacade): any;\n  compileNgModule(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3NgModuleMetadataFacade): any;\n  compileDirective(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DirectiveMetadataFacade): any;\n  compileComponent(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3ComponentMetadataFacade): any;\n  compileFactory(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3FactoryDefMetadataFacade): any;\n\n  createParseSourceSpan(kind: string, typeName: string, sourceUrl: string): ParseSourceSpan;\n\n  R3ResolvedDependencyType: typeof R3ResolvedDependencyType;\n  R3FactoryTarget: typeof R3FactoryTarget;\n  ResourceLoader: {new (): ResourceLoader};\n}\n\nexport interface CoreEnvironment { [name: string]: Function; }\n\nexport type ResourceLoader = {\n  get(url: string): Promise<string>| string;\n};\n\nexport type StringMap = {\n  [key: string]: string;\n};\n\nexport type StringMapWithRename = {\n  [key: string]: string | [string, string];\n};\n\nexport type Provider = any;\n\nexport enum R3ResolvedDependencyType {\n  Token = 0,\n  Attribute = 1,\n  ChangeDetectorRef = 2,\n}\n\nexport enum R3FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\nexport interface R3DependencyMetadataFacade {\n  token: any;\n  resolved: R3ResolvedDependencyType;\n  host: boolean;\n  optional: boolean;\n  self: boolean;\n  skipSelf: boolean;\n}\n\nexport interface R3PipeMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  pipeName: string;\n  deps: R3DependencyMetadataFacade[]|null;\n  pure: boolean;\n}\n\nexport interface R3InjectableMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  providedIn: any;\n  useClass?: any;\n  useFactory?: any;\n  useExisting?: any;\n  useValue?: any;\n  userDeps?: R3DependencyMetadataFacade[];\n}\n\nexport interface R3NgModuleMetadataFacade {\n  type: any;\n  bootstrap: Function[];\n  declarations: Function[];\n  imports: Function[];\n  exports: Function[];\n  schemas: {name: string}[]|null;\n  id: string|null;\n}\n\nexport interface R3InjectorMetadataFacade {\n  name: string;\n  type: any;\n  deps: R3DependencyMetadataFacade[]|null;\n  providers: any[];\n  imports: any[];\n}\n\nexport interface R3DirectiveMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  typeSourceSpan: ParseSourceSpan;\n  deps: R3DependencyMetadataFacade[]|null;\n  selector: string|null;\n  queries: R3QueryMetadataFacade[];\n  host: {[key: string]: string};\n  propMetadata: {[key: string]: any[]};\n  lifecycle: {usesOnChanges: boolean;};\n  inputs: string[];\n  outputs: string[];\n  usesInheritance: boolean;\n  exportAs: string[]|null;\n  providers: Provider[]|null;\n  viewQueries: R3QueryMetadataFacade[];\n}\n\nexport interface R3ComponentMetadataFacade extends R3DirectiveMetadataFacade {\n  template: string;\n  preserveWhitespaces: boolean;\n  animations: any[]|undefined;\n  pipes: Map<string, any>;\n  directives: {selector: string, expression: any}[];\n  styles: string[];\n  encapsulation: ViewEncapsulation;\n  viewProviders: Provider[]|null;\n  interpolation?: [string, string];\n  changeDetection?: ChangeDetectionStrategy;\n}\n\nexport interface R3FactoryDefMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  deps: R3DependencyMetadataFacade[]|null;\n  injectFn: 'directiveInject'|'inject';\n  target: R3FactoryTarget;\n}\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  Native = 1,\n  None = 2,\n  ShadowDom = 3\n}\n\nexport type ChangeDetectionStrategy = number;\n\nexport interface R3QueryMetadataFacade {\n  propertyName: string;\n  first: boolean;\n  predicate: any|string[];\n  descendants: boolean;\n  read: any|null;\n  static: boolean;\n}\n\nexport interface ParseSourceSpan {\n  start: any;\n  end: any;\n  details: any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {global} from '../util/global';\nimport {CompilerFacade, ExportedCompilerFacade} from './compiler_facade_interface';\nexport * from './compiler_facade_interface';\n\nexport function getCompilerFacade(): CompilerFacade {\n  const globalNg: ExportedCompilerFacade = global['ng'];\n  if (!globalNg || !globalNg.ÉµcompilerFacade) {\n    throw new Error(\n        `Angular JIT compilation failed: '@angular/compiler' not loaded!\\n` +\n        `  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\\n` +\n        `  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\\n` +\n        `  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`);\n  }\n  return globalNg.ÉµcompilerFacade;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getClosureSafeProperty} from '../util/property';\n\nexport const NG_COMP_DEF = getClosureSafeProperty({Éµcmp: getClosureSafeProperty});\nexport const NG_DIR_DEF = getClosureSafeProperty({Éµdir: getClosureSafeProperty});\nexport const NG_PIPE_DEF = getClosureSafeProperty({Éµpipe: getClosureSafeProperty});\nexport const NG_MOD_DEF = getClosureSafeProperty({Éµmod: getClosureSafeProperty});\nexport const NG_LOC_ID_DEF = getClosureSafeProperty({Éµloc: getClosureSafeProperty});\nexport const NG_FACTORY_DEF = getClosureSafeProperty({Éµfac: getClosureSafeProperty});\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nexport const NG_ELEMENT_ID = getClosureSafeProperty({__NG_ELEMENT_ID__: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\n\nimport {ÉµÉµdefineInjectable} from './interface/defs';\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function. See below for an example.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Example\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\nexport class InjectionToken<T> {\n  /** @internal */\n  readonly ngMetadataName = 'InjectionToken';\n\n  readonly Éµprov: never|undefined;\n\n  constructor(protected _desc: string, options?: {\n    providedIn?: Type<any>| 'root' | 'platform' | 'any' | null,\n    factory: () => T\n  }) {\n    this.Éµprov = undefined;\n    if (typeof options == 'number') {\n      // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n      // __NG_ELEMENT_ID__ is Used by Ivy to determine bloom filter id.\n      // We are using it to assign `-1` which is used to identify `Injector`.\n      (this as any).__NG_ELEMENT_ID__ = options;\n    } else if (options !== undefined) {\n      this.Éµprov = ÉµÉµdefineInjectable({\n        token: this,\n        providedIn: options.providedIn || 'root',\n        factory: options.factory,\n      });\n    }\n  }\n\n  toString(): string { return `InjectionToken ${this._desc}`; }\n}\n\nexport interface InjectableDefToken<T> extends InjectionToken<T> { Éµprov: never; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {getClosureSafeProperty} from '../util/property';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {getInjectableDef, ÉµÉµInjectableDef} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\nimport {ValueProvider} from './interface/provider';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\n\n\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport const INJECTOR = new InjectionToken<Injector>(\n    'INJECTOR',\n    -1 as any  // `-1` is used by Ivy DI system as special value to recognize it as `Injector`.\n    );\n\nconst _THROW_IF_NOT_FOUND = {};\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\nexport const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'Éµ';\nexport const SOURCE = '__source';\n\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector | null | undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation:\n    (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null)|undefined;\n\n/**\n * Sets the current inject implementation.\n */\nexport function setInjectImplementation(\n    impl: (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null) | undefined):\n    (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null)|undefined {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>): T;\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|\n    null;\nexport function injectInjectorOnly<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  if (_currentInjector === undefined) {\n    throw new Error(`inject() must be called from an injection context`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\n/**\n * Generated instruction: Injects a token from the currently active injector.\n *\n * Must be used in the context of a factory function such as one defined for an\n * `InjectionToken`. Throws an error if not called from such a context.\n *\n * (Additional documentation moved to `inject`, as it is the public API, and an alias for this instruction)\n *\n * @see inject\n * @codeGenApi\n */\nexport function ÉµÉµinject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function ÉµÉµinject<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function ÉµÉµinject<T>(token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|\n    null {\n  return (_injectImplementation || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * Must be used in the context of a factory function such as one defined for an\n * `InjectionToken`. Throws an error if not called from such a context.\n *\n * Within such a factory function, using this function to request injection of a dependency\n * is faster and more type-safe than providing an additional array of dependencies\n * (as has been common with `useFactory` providers).\n *\n * @param token The injection token for the dependency to be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSef`, and `@Optional`.\n * @returns True if injection is successful, null otherwise.\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n * @publicApi\n */\nexport const inject = ÉµÉµinject;\n\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * `InjectableDef`.\n */\nexport function injectRootLimpMode<T>(\n    token: Type<T>| InjectionToken<T>, notFoundValue: T | undefined, flags: InjectFlags): T|null {\n  const injectableDef: ÉµÉµInjectableDef<T>|null = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                               injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n}\n\nexport function injectArgs(types: (Type<any>| InjectionToken<any>| any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.ngMetadataName === 'Optional' || meta === Optional) {\n          flags |= InjectFlags.Optional;\n        } else if (\n            meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf' || meta === SkipSelf) {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.ngMetadataName === 'Self' || meta === Self) {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject || meta === Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(ÉµÉµinject(type !, flags));\n    } else {\n      args.push(ÉµÉµinject(arg));\n    }\n  }\n  return args;\n}\n\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      // Intentionally left behind: With dev tools open the debugger will stop here. There is no\n      // reason why correctly written application should cause this exception.\n      // TODO(misko): uncomment the next line once `ngDevMode` works with closure.\n      // if (ngDevMode) debugger;\n      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n      error.name = 'NullInjectorError';\n      throw error;\n    }\n    return notFoundValue;\n  }\n}\n\n\nexport function catchInjectorError(\n    e: any, token: any, injectorErrorName: string, source: string | null): never {\n  const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n  if (token[SOURCE]) {\n    tokenPath.unshift(token[SOURCE]);\n  }\n  e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n  e[NG_TOKEN_PATH] = tokenPath;\n  e[NG_TEMP_TOKEN_PATH] = null;\n  throw e;\n}\n\nexport function formatError(\n    text: string, obj: any, injectorErrorName: string, source: string | null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (Array.isArray(obj)) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../../interface/type';\nimport {isForwardRef, resolveForwardRef} from '../forward_ref';\nimport {ÉµÉµinject} from '../injector_compatibility';\nimport {getInjectableDef, getInjectorDef, ÉµÉµdefineInjectable, ÉµÉµdefineInjector} from '../interface/defs';\n\n\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nexport const angularCoreDiEnv: {[name: string]: Function} = {\n  'ÉµÉµdefineInjectable': ÉµÉµdefineInjectable,\n  'ÉµÉµdefineInjector': ÉµÉµdefineInjector,\n  'ÉµÉµinject': ÉµÉµinject,\n  'ÉµÉµgetFactoryOf': getFactoryOf,\n};\n\nfunction getFactoryOf<T>(type: Type<any>): ((type?: Type<T>) => T)|null {\n  const typeAny = type as any;\n\n  if (isForwardRef(type)) {\n    return (() => {\n      const factory = getFactoryOf<T>(resolveForwardRef(typeAny));\n      return factory ? factory() : null;\n    }) as any;\n  }\n\n  const def = getInjectableDef<T>(typeAny) || getInjectorDef<T>(typeAny);\n  if (!def || def.factory === undefined) {\n    return null;\n  }\n  return def.factory;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {Type} from '../interface/type';\n\nimport {ComponentFactoryResolver} from './component_factory_resolver';\n\n\n/**\n * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\n *\n * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\n * NgModule Instance.\n *\n * @publicApi\n */\nexport abstract class NgModuleRef<T> {\n  /**\n   * The injector that contains all of the providers of the NgModule.\n   */\n  abstract get injector(): Injector;\n\n  /**\n   * The ComponentFactoryResolver to get hold of the ComponentFactories\n   * declared in the `entryComponents` property of the module.\n   */\n  abstract get componentFactoryResolver(): ComponentFactoryResolver;\n\n  /**\n   * The NgModule instance.\n   */\n  abstract get instance(): T;\n\n  /**\n   * Destroys the module instance and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Allows to register a callback that will be called when the module is destroyed.\n   */\n  abstract onDestroy(callback: () => void): void;\n}\n\nexport interface InternalNgModuleRef<T> extends NgModuleRef<T> {\n  // Note: we are using the prefix _ as NgModuleData is an NgModuleRef and therefore directly\n  // exposed to the user.\n  _bootstrapComponents: Type<any>[];\n}\n\n/**\n * @publicApi\n */\nexport abstract class NgModuleFactory<T> {\n  abstract get moduleType(): Type<T>;\n  abstract create(parentInjector: Injector|null): NgModuleRef<T>;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n* Equivalent to ES6 spread, add each item to an array.\n*\n* @param items The items to add\n* @param arr The array to which you want to add the items\n*/\nexport function addAllToArray(items: any[], arr: any[]) {\n  for (let i = 0; i < items.length; i++) {\n    arr.push(items[i]);\n  }\n}\n\n/**\n * Flattens an array.\n */\nexport function flatten(list: any[], dst?: any[]): any[] {\n  if (dst === undefined) dst = list;\n  for (let i = 0; i < list.length; i++) {\n    let item = list[i];\n    if (Array.isArray(item)) {\n      // we need to inline it.\n      if (dst === list) {\n        // Our assumption that the list was already flat was wrong and\n        // we need to clone flat since we need to write to it.\n        dst = list.slice(0, i);\n      }\n      flatten(item, dst);\n    } else if (dst !== list) {\n      dst.push(item);\n    }\n  }\n  return dst;\n}\n\nexport function deepForEach<T>(input: (T | any[])[], fn: (value: T) => void): void {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\n\nexport function addToArray(arr: any[], index: number, value: any): void {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\n\nexport function removeFromArray(arr: any[], index: number): any {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value !);\n  }\n  return list;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// The functions in this file verify that the assumptions we are making\n// about state in an instruction are correct before implementing any logic.\n// They are meant only to be called in dev mode as sanity checks.\n\nimport {stringify} from './stringify';\n\nexport function assertNumber(actual: any, msg: string) {\n  if (typeof actual != 'number') {\n    throwError(msg);\n  }\n}\n\nexport function assertEqual<T>(actual: T, expected: T, msg: string) {\n  if (actual != expected) {\n    throwError(msg);\n  }\n}\n\nexport function assertNotEqual<T>(actual: T, expected: T, msg: string) {\n  if (actual == expected) {\n    throwError(msg);\n  }\n}\n\nexport function assertSame<T>(actual: T, expected: T, msg: string) {\n  if (actual !== expected) {\n    throwError(msg);\n  }\n}\n\nexport function assertNotSame<T>(actual: T, expected: T, msg: string) {\n  if (actual === expected) {\n    throwError(msg);\n  }\n}\n\nexport function assertLessThan<T>(actual: T, expected: T, msg: string) {\n  if (actual >= expected) {\n    throwError(msg);\n  }\n}\n\nexport function assertLessThanOrEqual<T>(actual: T, expected: T, msg: string) {\n  if (actual > expected) {\n    throwError(msg);\n  }\n}\n\nexport function assertGreaterThan<T>(actual: T, expected: T, msg: string) {\n  if (actual <= expected) {\n    throwError(msg);\n  }\n}\n\nexport function assertNotDefined<T>(actual: T, msg: string) {\n  if (actual != null) {\n    throwError(msg);\n  }\n}\n\nexport function assertDefined<T>(actual: T, msg: string) {\n  if (actual == null) {\n    throwError(msg);\n  }\n}\n\nexport function throwError(msg: string): never {\n  // tslint:disable-next-line\n  debugger;  // Left intentionally for better debugger experience.\n  throw new Error(`ASSERTION ERROR: ${msg}`);\n}\n\nexport function assertDomNode(node: any) {\n  // If we're in a worker, `Node` will not be defined.\n  assertEqual(\n      (typeof Node !== 'undefined' && node instanceof Node) ||\n          (typeof node === 'object' && node != null &&\n           node.constructor.name === 'WebWorkerRenderNode'),\n      true, `The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n}\n\n\nexport function assertDataInRange(arr: any[], index: number) {\n  const maxLen = arr ? arr.length : 0;\n  assertLessThan(index, maxLen, `Index expected to be less than ${maxLen} but got ${index}`);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @publicApi\n */\nexport enum ChangeDetectionStrategy {\n  /**\n   * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n   * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n   * Change detection can still be explicitly invoked.\n   * This strategy applies to all child directives and cannot be overridden.\n   */\n  OnPush = 0,\n\n  /**\n   * Use the default `CheckAlways` strategy, in which change detection is automatic until\n   * explicitly deactivated.\n   */\n  Default = 1,\n}\n\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\nexport enum ChangeDetectorStatus {\n  /**\n   * A state in which, after calling `detectChanges()`, the change detector\n   * state becomes `Checked`, and must be explicitly invoked or reactivated.\n   */\n  CheckOnce,\n\n  /**\n   * A state in which change detection is skipped until the change detector mode\n   * becomes `CheckOnce`.\n   */\n  Checked,\n\n  /**\n   * A state in which change detection continues automatically until explicitly\n   * deactivated.\n   */\n  CheckAlways,\n\n  /**\n   * A state in which a change detector sub tree is not a part of the main tree and\n   * should be skipped.\n   */\n  Detached,\n\n  /**\n   * Indicates that the change detector encountered an error checking a binding\n   * or calling a directive lifecycle method and is now in an inconsistent state. Change\n   * detectors in this state do not detect changes.\n   */\n  Errored,\n\n  /**\n   * Indicates that the change detector has been destroyed.\n   */\n  Destroyed,\n}\n\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\nexport function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy):\n    boolean {\n  return changeDetectionStrategy == null ||\n      changeDetectionStrategy === ChangeDetectionStrategy.Default;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Defines template and style encapsulation options available for Component's {@link Component}.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nexport enum ViewEncapsulation {\n  /**\n   * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\n   * Element and pre-processing the style rules provided via {@link Component#styles styles} or\n   * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all\n   * selectors.\n   *\n   * This is the default option.\n   */\n  Emulated = 0,\n  /**\n   * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.\n   * Use the native encapsulation mechanism of the renderer.\n   *\n   * For the DOM this means using the deprecated [Shadow DOM\n   * v0](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * creating a ShadowRoot for Component's Host Element.\n   */\n  Native = 1,\n  /**\n   * Don't provide any template or style encapsulation.\n   */\n  None = 2,\n\n  /**\n   * Use Shadow DOM to encapsulate styles.\n   *\n   * For the DOM this means using modern [Shadow\n   * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * creating a ShadowRoot for Component's Host Element.\n   */\n  ShadowDom = 3\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nexport function noSideEffects(fn: () => void): string {\n  return '' + {toString: fn};\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from './global';\n\n// Do not remove: needed for closure to be able to properly tree-shake ngDevMode.\n// goog.define\n\ndeclare global {\n  /**\n   * Values of ngDevMode\n   * Depending on the current state of the application, ngDevMode may have one of several values.\n   *\n   * For convenience, the âtruthyâ value which enables dev mode is also an object which contains\n   * Angularâs performance counters. This is not necessary, but cuts down on boilerplate for the\n   * perf counters.\n   *\n   * ngDevMode may also be set to false. This can happen in one of a few ways:\n   * - The user explicitly sets `window.ngDevMode = false` somewhere in their app.\n   * - The user calls `enableProdMode()`.\n   * - The URL contains a `ngDevMode=false` text.\n   * Finally, ngDevMode may not have been defined at all.\n   */\n  const ngDevMode: null|NgDevModePerfCounters;\n  interface NgDevModePerfCounters {\n    namedConstructors: boolean;\n    firstCreatePass: number;\n    tNode: number;\n    tView: number;\n    rendererCreateTextNode: number;\n    rendererSetText: number;\n    rendererCreateElement: number;\n    rendererAddEventListener: number;\n    rendererSetAttribute: number;\n    rendererRemoveAttribute: number;\n    rendererSetProperty: number;\n    rendererSetClassName: number;\n    rendererAddClass: number;\n    rendererRemoveClass: number;\n    rendererSetStyle: number;\n    rendererRemoveStyle: number;\n    rendererDestroy: number;\n    rendererDestroyNode: number;\n    rendererMoveNode: number;\n    rendererRemoveNode: number;\n    rendererAppendChild: number;\n    rendererInsertBefore: number;\n    rendererCreateComment: number;\n    styleMap: number;\n    styleMapCacheMiss: number;\n    classMap: number;\n    classMapCacheMiss: number;\n    styleProp: number;\n    stylePropCacheMiss: number;\n    classProp: number;\n    classPropCacheMiss: number;\n    flushStyling: number;\n    classesApplied: number;\n    stylesApplied: number;\n  }\n}\n\nexport function ngDevModeResetPerfCounters(): NgDevModePerfCounters {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters: NgDevModePerfCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n    styleMap: 0,\n    styleMapCacheMiss: 0,\n    classMap: 0,\n    classMapCacheMiss: 0,\n    styleProp: 0,\n    stylePropCacheMiss: 0,\n    classProp: 0,\n    classPropCacheMiss: 0,\n    flushStyling: 0,\n    classesApplied: 0,\n    stylesApplied: 0,\n  };\n\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ÉµÉµdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When using checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nexport function initNgDevMode(): boolean {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return !!ngDevMode;\n  }\n  return false;\n}\n","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\nimport {initNgDevMode} from '../util/ng_dev_mode';\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\n\nexport const EMPTY_OBJ: {} = {};\nexport const EMPTY_ARRAY: any[] = [];\n\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  // These property accesses can be ignored because ngDevMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_OBJ);\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_ARRAY);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Mutable, Type} from '../interface/type';\nimport {NgModuleDef} from '../metadata/ng_module';\nimport {SchemaMetadata} from '../metadata/schema';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {noSideEffects} from '../util/closure';\nimport {initNgDevMode} from '../util/ng_dev_mode';\nimport {stringify} from '../util/stringify';\n\nimport {EMPTY_ARRAY, EMPTY_OBJ} from './empty';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF, NG_LOC_ID_DEF, NG_MOD_DEF, NG_PIPE_DEF} from './fields';\nimport {ComponentDef, ComponentDefFeature, ComponentTemplate, ComponentType, ContentQueriesFunction, DirectiveDef, DirectiveDefFeature, DirectiveTypesOrFactory, FactoryFn, HostBindingsFunction, PipeDef, PipeType, PipeTypesOrFactory, ViewQueriesFunction} from './interfaces/definition';\nimport {TConstants} from './interfaces/node';\n// while SelectorFlags is unused here, it's required so that types don't get resolved lazily\n// see: https://github.com/Microsoft/web-build-tools/issues/1050\nimport {CssSelectorList, SelectorFlags} from './interfaces/projection';\nimport {NgModuleType} from './ng_module_ref';\n\nlet _renderCompCount = 0;\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static Éµcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nexport function ÉµÉµdefineComponent<T>(componentDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this component. */\n  selectors?: CssSelectorList;\n\n  /**\n   * The number of nodes, local refs, and pipes in this component template.\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the binding start index.\n   */\n  // TODO(kara): remove queries from this count\n  decls: number;\n\n  /**\n   * The number of bindings in this component template (including pure fn bindings).\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  vars: number;\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['public', 'declared']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ContentQueriesFunction<T>;\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string[];\n\n  /**\n   * Template function use for rendering DOM.\n   *\n   * This function has following structure.\n   *\n   * ```\n   * function Template<T>(ctx:T, creationMode: boolean) {\n   *   if (creationMode) {\n   *     // Contains creation mode instructions.\n   *   }\n   *   // Contains binding update instructions\n   * }\n   * ```\n   *\n   * Common instructions are:\n   * Creation mode instructions:\n   *  - `elementStart`, `elementEnd`\n   *  - `text`\n   *  - `container`\n   *  - `listener`\n   *\n   * Binding update instructions:\n   * - `bind`\n   * - `elementAttribute`\n   * - `elementProperty`\n   * - `elementClass`\n   * - `elementStyle`\n   *\n   */\n  template: ComponentTemplate<T>;\n\n  /**\n   * Constants for the nodes in the component's view.\n   * Includes attribute arrays, local definition arrays etc.\n   */\n  consts?: TConstants;\n\n  /**\n   * An array of `ngContent[selector]` values that were found in the template.\n   */\n  ngContentSelectors?: string[];\n\n  /**\n   * Additional set of instructions specific to view query processing. This could be seen as a\n   * set of instruction to be inserted into the template function.\n   *\n   * Query-related instructions need to be pulled out to a specific function as a timing of\n   * execution is different as compared to all other instructions (after change detection hooks but\n   * before view hooks).\n   */\n  viewQuery?: ViewQueriesFunction<T>| null;\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}\n   */\n  features?: ComponentDefFeature[];\n\n  /**\n   * Defines template and style encapsulation options available for Component's {@link Component}.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   *\n   * see: animation\n   */\n  data?: {[kind: string]: any};\n\n  /**\n   * A set of styles that the component needs to be present for component to render correctly.\n   */\n  styles?: string[];\n\n  /**\n   * The strategy that the default change detector uses to detect changes.\n   * When set, takes effect the next time change detection is triggered.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Registry of directives and components that may be found in this component's view.\n   *\n   * The property is either an array of `DirectiveDef`s or a function which returns the array of\n   * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n   */\n  directives?: DirectiveTypesOrFactory | null;\n\n  /**\n   * Registry of pipes that may be found in this component's view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   */\n  pipes?: PipeTypesOrFactory | null;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the component's template.\n   */\n  schemas?: SchemaMetadata[] | null;\n}): never {\n  // Initialize ngDevMode. This must be the first statement in ÉµÉµdefineComponent.\n  // See the `initNgDevMode` docstring for more information.\n  (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n\n  const type = componentDefinition.type;\n  const typePrototype = type.prototype;\n  const declaredInputs: {[key: string]: string} = {} as any;\n  const def: Mutable<ComponentDef<any>, keyof ComponentDef<any>> = {\n    type: type,\n    providersResolver: null,\n    decls: componentDefinition.decls,\n    vars: componentDefinition.vars,\n    factory: null,\n    template: componentDefinition.template || null !,\n    consts: componentDefinition.consts || null,\n    ngContentSelectors: componentDefinition.ngContentSelectors,\n    hostBindings: componentDefinition.hostBindings || null,\n    contentQueries: componentDefinition.contentQueries || null,\n    declaredInputs: declaredInputs,\n    inputs: null !,   // assigned in noSideEffects\n    outputs: null !,  // assigned in noSideEffects\n    exportAs: componentDefinition.exportAs || null,\n    onChanges: null,\n    onInit: typePrototype.ngOnInit || null,\n    doCheck: typePrototype.ngDoCheck || null,\n    afterContentInit: typePrototype.ngAfterContentInit || null,\n    afterContentChecked: typePrototype.ngAfterContentChecked || null,\n    afterViewInit: typePrototype.ngAfterViewInit || null,\n    afterViewChecked: typePrototype.ngAfterViewChecked || null,\n    onDestroy: typePrototype.ngOnDestroy || null,\n    onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n    directiveDefs: null !,  // assigned in noSideEffects\n    pipeDefs: null !,       // assigned in noSideEffects\n    selectors: componentDefinition.selectors || EMPTY_ARRAY,\n    viewQuery: componentDefinition.viewQuery || null,\n    features: componentDefinition.features as DirectiveDefFeature[] || null,\n    data: componentDefinition.data || {},\n    // TODO(misko): convert ViewEncapsulation into const enum so that it can be used directly in the\n    // next line. Also `None` should be 0 not 2.\n    encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n    id: 'c',\n    styles: componentDefinition.styles || EMPTY_ARRAY,\n    _: null as never,\n    setInput: null,\n    schemas: componentDefinition.schemas || null,\n    tView: null,\n  };\n  def._ = noSideEffects(() => {\n    const directiveTypes = componentDefinition.directives !;\n    const feature = componentDefinition.features;\n    const pipeTypes = componentDefinition.pipes !;\n    def.id += _renderCompCount++;\n    def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\n    def.outputs = invertObject(componentDefinition.outputs),\n    feature && feature.forEach((fn) => fn(def));\n    def.directiveDefs = directiveTypes ?\n        () => (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes)\n                  .map(extractDirectiveDef) :\n        null;\n    def.pipeDefs = pipeTypes ?\n        () => (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef) :\n        null;\n  }) as never;\n\n  return def as never;\n}\n\n/**\n * @codeGenApi\n */\nexport function ÉµÉµsetComponentScope(\n    type: ComponentType<any>, directives: Type<any>[], pipes: Type<any>[]): void {\n  const def = (type.Éµcmp as ComponentDef<any>);\n  def.directiveDefs = () => directives.map(extractDirectiveDef);\n  def.pipeDefs = () => pipes.map(extractPipeDef);\n}\n\nexport function extractDirectiveDef(type: Type<any>): DirectiveDef<any>|ComponentDef<any> {\n  const def = getComponentDef(type) || getDirectiveDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is neither 'ComponentType' or 'DirectiveType'.`);\n  }\n  return def !;\n}\n\nexport function extractPipeDef(type: Type<any>): PipeDef<any> {\n  const def = getPipeDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is not a 'PipeType'.`);\n  }\n  return def !;\n}\n\nexport const autoRegisterModuleById: {[id: string]: NgModuleType} = {};\n\n/**\n * @codeGenApi\n */\nexport function ÉµÉµdefineNgModule<T>(def: {\n  /** Token representing the module. Used by DI. */\n  type: T;\n\n  /** List of components to bootstrap. */\n  bootstrap?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]);\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]);\n\n  /** The set of schemas that declare elements to be allowed in the NgModule. */\n  schemas?: SchemaMetadata[] | null;\n\n  /** Unique ID for the module that is used with `getModuleFactory`. */\n  id?: string | null;\n}): never {\n  const res: NgModuleDef<T> = {\n    type: def.type,\n    bootstrap: def.bootstrap || EMPTY_ARRAY,\n    declarations: def.declarations || EMPTY_ARRAY,\n    imports: def.imports || EMPTY_ARRAY,\n    exports: def.exports || EMPTY_ARRAY,\n    transitiveCompileScopes: null,\n    schemas: def.schemas || null,\n    id: def.id || null,\n  };\n  if (def.id != null) {\n    noSideEffects(\n        () => { autoRegisterModuleById[def.id !] = def.type as unknown as NgModuleType; });\n  }\n  return res as never;\n}\n\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nexport function ÉµÉµsetNgModuleScope(type: any, scope: {\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]);\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]);\n}): void {\n  return noSideEffects(() => {\n    const ngModuleDef = getNgModuleDef(type, true);\n    ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n    ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n    ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n  }) as never;\n}\n\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject<T>(\n    obj?: {[P in keyof T]?: string | [string, string]},\n    secondary?: {[key: string]: string}): {[P in keyof T]: string} {\n  if (obj == null) return EMPTY_OBJ as any;\n  const newLookup: any = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      let publicName: string|[string, string] = obj[minifiedKey] !;\n      let declaredName = publicName;\n      if (Array.isArray(publicName)) {\n        declaredName = publicName[1];\n        publicName = publicName[0];\n      }\n      newLookup[publicName] = minifiedKey;\n      if (secondary) {\n        (secondary[publicName] = declaredName as string);\n      }\n    }\n  }\n  return newLookup;\n}\n\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static Éµdir = ÉµÉµdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nexport const ÉµÉµdefineDirective = ÉµÉµdefineComponent as any as<T>(directiveDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this directive. */\n  selectors?: CssSelectorList;\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['declaredInput2', 'publicInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['declared', 'public']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}, {@link InheritDefinitionFeature}\n   */\n  features?: DirectiveDefFeature[];\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ContentQueriesFunction<T>;\n\n  /**\n   * Additional set of instructions specific to view query processing. This could be seen as a\n   * set of instructions to be inserted into the template function.\n   */\n  viewQuery?: ViewQueriesFunction<T>| null;\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string[];\n}) => never;\n\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static Éµpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nexport function ÉµÉµdefinePipe<T>(pipeDef: {\n  /** Name of the pipe. Used for matching pipes in template to pipe defs. */\n  name: string,\n\n  /** Pipe class reference. Needed to extract pipe lifecycle hooks. */\n  type: Type<T>,\n\n  /** Whether the pipe is pure. */\n  pure?: boolean\n}): never {\n  return (<PipeDef<T>>{\n    type: pipeDef.type,\n    name: pipeDef.name,\n    factory: null,\n    pure: pipeDef.pure !== false,\n    onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n  }) as never;\n}\n\n/**\n * The following getter methods retrieve the definition form the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\n\nexport function getComponentDef<T>(type: any): ComponentDef<T>|null {\n  return type[NG_COMP_DEF] || null;\n}\n\nexport function getDirectiveDef<T>(type: any): DirectiveDef<T>|null {\n  return type[NG_DIR_DEF] || null;\n}\n\nexport function getPipeDef<T>(type: any): PipeDef<T>|null {\n  return type[NG_PIPE_DEF] || null;\n}\n\nexport function getFactoryDef<T>(type: any, throwNotFound: true): FactoryFn<T>;\nexport function getFactoryDef<T>(type: any): FactoryFn<T>|null;\nexport function getFactoryDef<T>(type: any, throwNotFound?: boolean): FactoryFn<T>|null {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'Éµfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\nexport function getNgModuleDef<T>(type: any, throwNotFound: true): NgModuleDef<T>;\nexport function getNgModuleDef<T>(type: any): NgModuleDef<T>|null;\nexport function getNgModuleDef<T>(type: any, throwNotFound?: boolean): NgModuleDef<T>|null {\n  const ngModuleDef = type[NG_MOD_DEF] || null;\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have 'Éµmod' property.`);\n  }\n  return ngModuleDef;\n}\n\nexport function getNgLocaleIdDef(type: any): string|null {\n  return (type as any)[NG_LOC_ID_DEF] || null;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {Injector} from '../../di/injector';\nimport {Type} from '../../interface/type';\nimport {SchemaMetadata} from '../../metadata';\nimport {Sanitizer} from '../../sanitization/sanitizer';\n\nimport {LContainer} from './container';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList, ViewQueriesFunction} from './definition';\nimport {I18nUpdateOpCodes, TI18n} from './i18n';\nimport {TAttributes, TConstants, TElementNode, TNode, TViewNode} from './node';\nimport {PlayerHandler} from './player';\nimport {LQueries, TQueries} from './query';\nimport {RElement, Renderer3, RendererFactory3} from './renderer';\n\n\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nexport const HOST = 0;\nexport const TVIEW = 1;\nexport const FLAGS = 2;\nexport const PARENT = 3;\nexport const NEXT = 4;\nexport const QUERIES = 5;\nexport const T_HOST = 6;\nexport const CLEANUP = 7;\nexport const CONTEXT = 8;\nexport const INJECTOR = 9;\nexport const RENDERER_FACTORY = 10;\nexport const RENDERER = 11;\nexport const SANITIZER = 12;\nexport const CHILD_HEAD = 13;\nexport const CHILD_TAIL = 14;\nexport const DECLARATION_VIEW = 15;\nexport const DECLARATION_COMPONENT_VIEW = 16;\nexport const DECLARATION_LCONTAINER = 17;\nexport const PREORDER_HOOK_FLAGS = 18;\n/** Size of LView's header. Necessary to adjust for it when setting slots.  */\nexport const HEADER_OFFSET = 19;\n\n\n// This interface replaces the real LView interface if it is an arg or a\n// return value of a public instruction. This ensures we don't need to expose\n// the actual interface, which should be kept private.\nexport interface OpaqueViewState {\n  '__brand__': 'Brand for OpaqueViewState that nothing will match';\n}\n\n\n/**\n * `LView` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LView`. When processing a particular view, we set the `viewData` to that\n * `LView`. When that view is done processing, the `viewData` is set back to\n * whatever the original `viewData` was before (the parent `LView`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\nexport interface LView extends Array<any> {\n  /**\n   * The host node for this LView instance, if this is a component view.\n   * If this is an embedded view, HOST will be null.\n   */\n  [HOST]: RElement|null;\n\n  /**\n   * The static data for this view. We need a reference to this so we can easily walk up the\n   * node tree in DI and get the TView.data array associated with a node (where the\n   * directive defs are stored).\n   */\n  readonly[TVIEW]: TView;\n\n  /** Flags for this view. See LViewFlags for more info. */\n  [FLAGS]: LViewFlags;\n\n  /**\n   * This may store an {@link LView} or {@link LContainer}.\n   *\n   * `LView` - The parent view. This is needed when we exit the view and must restore the previous\n   * LView. Without this, the render method would have to keep a stack of\n   * views as it is recursively rendering templates.\n   *\n   * `LContainer` - The current view is part of a container, and is an embedded view.\n   */\n  [PARENT]: LView|LContainer|null;\n\n  /**\n   *\n   * The next sibling LView or LContainer.\n   *\n   * Allows us to propagate between sibling view states that aren't in the same\n   * container. Embedded views already have a node.next, but it is only set for\n   * views in the same container. We need a way to link component views and views\n   * across containers as well.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /** Queries active for this view - nodes from a view are reported to those queries. */\n  [QUERIES]: LQueries|null;\n\n  /**\n   * Pointer to the `TViewNode` or `TElementNode` which represents the root of the view.\n   *\n   * If `TViewNode`, this is an embedded view of a container. We need this to be able to\n   * efficiently find the `LViewNode` when inserting the view into an anchor.\n   *\n   * If `TElementNode`, this is the LView of a component.\n   *\n   * If null, this is the root view of an application (root component is in this view).\n   */\n  [T_HOST]: TViewNode|TElementNode|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This context array stores both listener functions wrapped with\n   * their context and output subscription instances for a particular view.\n   *\n   * These change per LView instance, so they cannot be stored on TView. Instead,\n   * TView.cleanup saves an index to the necessary context in this array.\n   */\n  // TODO: flatten into LView[]\n  [CLEANUP]: any[]|null;\n\n  /**\n   * - For dynamic views, this is the context with which to render the template (e.g.\n   *   `NgForContext`), or `{}` if not defined explicitly.\n   * - For root view of the root component the context contains change detection data.\n   * - For non-root components, the context is the component instance,\n   * - For inline views, the context is null.\n   */\n  [CONTEXT]: {}|RootContext|null;\n\n  /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */\n  readonly[INJECTOR]: Injector|null;\n\n  /** Factory to be used for creating Renderer. */\n  [RENDERER_FACTORY]: RendererFactory3;\n\n  /** Renderer to be used for this view. */\n  [RENDERER]: Renderer3;\n\n  /** An optional custom sanitizer. */\n  [SANITIZER]: Sanitizer|null;\n\n  /**\n   * Reference to the first LView or LContainer beneath this LView in\n   * the hierarchy.\n   *\n   * Necessary to store this so views can traverse through their nested views\n   * to remove listeners and call onDestroy callbacks.\n   */\n  [CHILD_HEAD]: LView|LContainer|null;\n\n  /**\n   * The last LView or LContainer beneath this LView in the hierarchy.\n   *\n   * The tail allows us to quickly add a new state to the end of the view list\n   * without having to propagate starting from the first child.\n   */\n  [CHILD_TAIL]: LView|LContainer|null;\n\n  /**\n   * View where this view's template was declared.\n   *\n   * Only applicable for dynamically created views. Will be null for inline/component views.\n   *\n   * The template for a dynamically created view may be declared in a different view than\n   * it is inserted. We already track the \"insertion view\" (view where the template was\n   * inserted) in LView[PARENT], but we also need access to the \"declaration view\"\n   * (view where the template was declared). Otherwise, we wouldn't be able to call the\n   * view's template function with the proper contexts. Context should be inherited from\n   * the declaration view tree, not the insertion view tree.\n   *\n   * Example (AppComponent template):\n   *\n   * <ng-template #foo></ng-template>       <-- declared here -->\n   * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\n   *\n   * The <ng-template> above is declared in the AppComponent template, but it will be passed into\n   * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\n   * but the insertion view would be SomeComp. When we are removing views, we would want to\n   * traverse through the insertion view to clean up listeners. When we are calling the\n   * template function during change detection, we need the declaration view to get inherited\n   * context.\n   */\n  [DECLARATION_VIEW]: LView|null;\n\n\n  /**\n   * Points to the declaration component view, used to track transplanted `LView`s.\n   *\n   * See: `DECLARATION_VIEW` which points to the actual `LView` where it was declared, whereas\n   * `DECLARATION_COMPONENT_VIEW` points to the component which may not be same as\n   * `DECLARATION_VIEW`.\n   *\n   * Example:\n   * ```\n   * <#VIEW #myComp>\n   *  <div *ngIf=\"true\">\n   *   <ng-template #myTmpl>...</ng-template>\n   *  </div>\n   * </#VIEW>\n   * ```\n   * In the above case `DECLARATION_VIEW` for `myTmpl` points to the `LView` of `ngIf` whereas\n   * `DECLARATION_COMPONENT_VIEW` points to `LView` of the `myComp` which owns the template.\n   *\n   * The reason for this is that all embedded views are always check-always whereas the component\n   * view can be check-always or on-push. When we have a transplanted view it is important to\n   * determine if we have transplanted a view from check-always declaration to on-push insertion\n   * point. In such a case the transplanted view needs to be added to the `LContainer` in the\n   * declared `LView` and CD during the declared view CD (in addition to the CD at the insertion\n   * point.) (Any transplanted views which are intra Component are of no interest because the CD\n   * strategy of declaration and insertion will always be the same, because it is the same\n   * component.)\n   *\n   * Queries already track moved views in `LView[DECLARATION_LCONTAINER]` and\n   * `LContainer[MOVED_VIEWS]`. However the queries also track `LView`s which moved within the same\n   * component `LView`. Transplanted views are a subset of moved views, and we use\n   * `DECLARATION_COMPONENT_VIEW` to differentiate them. As in this example.\n   *\n   * Example showing intra component `LView` movement.\n   * ```\n   * <#VIEW #myComp>\n   *   <div *ngIf=\"condition; then thenBlock else elseBlock\"></div>\n   *   <ng-template #thenBlock>Content to render when condition is true.</ng-template>\n   *   <ng-template #elseBlock>Content to render when condition is false.</ng-template>\n   * </#VIEW>\n   * ```\n   * The `thenBlock` and `elseBlock` is moved but not transplanted.\n   *\n   * Example showing inter component `LView` movement (transplanted view).\n   * ```\n   * <#VIEW #myComp>\n   *   <ng-template #myTmpl>...</ng-template>\n   *   <insertion-component [template]=\"myTmpl\"></insertion-component>\n   * </#VIEW>\n   * ```\n   * In the above example `myTmpl` is passed into a different component. If `insertion-component`\n   * instantiates `myTmpl` and `insertion-component` is on-push then the `LContainer` needs to be\n   * marked as containing transplanted views and those views need to be CD as part of the\n   * declaration CD.\n   *\n   *\n   * When change detection runs, it iterates over `[MOVED_VIEWS]` and CDs any child `LView`s where\n   * the `DECLARATION_COMPONENT_VIEW` of the current component and the child `LView` does not match\n   * (it has been transplanted across components.)\n   *\n   * Note: `[DECLARATION_COMPONENT_VIEW]` points to itself if the LView is a component view (the\n   *       simplest / most common case).\n   *\n   * see also:\n   *   - https://hackmd.io/@mhevery/rJUJsvv9H write up of the problem\n   *   - `LContainer[ACTIVE_INDEX]` for flag which marks which `LContainer` has transplanted views.\n   *   - `LContainer[TRANSPLANT_HEAD]` and `LContainer[TRANSPLANT_TAIL]` storage for transplanted\n   *   - `LView[DECLARATION_LCONTAINER]` similar problem for queries\n   *   - `LContainer[MOVED_VIEWS]` similar problem for queries\n   */\n  [DECLARATION_COMPONENT_VIEW]: LView;\n\n  /**\n   * A declaration point of embedded views (ones instantiated based on the content of a\n   * <ng-template>), null for other types of views.\n   *\n   * We need to track all embedded views created from a given declaration point so we can prepare\n   * query matches in a proper order (query matches are ordered based on their declaration point and\n   * _not_ the insertion point).\n   */\n  [DECLARATION_LCONTAINER]: LContainer|null;\n\n  /**\n   * More flags for this view. See PreOrderHookFlags for more info.\n   */\n  [PREORDER_HOOK_FLAGS]: PreOrderHookFlags;\n}\n\n/** Flags associated with an LView (saved in LView[FLAGS]) */\nexport const enum LViewFlags {\n  /** The state of the init phase on the first 2 bits */\n  InitPhaseStateIncrementer = 0b00000000001,\n  InitPhaseStateMask = 0b00000000011,\n\n  /**\n   * Whether or not the view is in creationMode.\n   *\n   * This must be stored in the view rather than using `data` as a marker so that\n   * we can properly support embedded views. Otherwise, when exiting a child view\n   * back into the parent view, `data` will be defined and `creationMode` will be\n   * improperly reported as false.\n   */\n  CreationMode = 0b00000000100,\n\n  /**\n   * Whether or not this LView instance is on its first processing pass.\n   *\n   * An LView instance is considered to be on its \"first pass\" until it\n   * has completed one creation mode run and one update mode run. At this\n   * time, the flag is turned off.\n   */\n  FirstLViewPass = 0b00000001000,\n\n  /** Whether this view has default change detection strategy (checks always) or onPush */\n  CheckAlways = 0b00000010000,\n\n  /**\n   * Whether or not manual change detection is turned on for onPush components.\n   *\n   * This is a special mode that only marks components dirty in two cases:\n   * 1) There has been a change to an @Input property\n   * 2) `markDirty()` has been called manually by the user\n   *\n   * Note that in this mode, the firing of events does NOT mark components\n   * dirty automatically.\n   *\n   * Manual mode is turned off by default for backwards compatibility, as events\n   * automatically mark OnPush components dirty in View Engine.\n   *\n   * TODO: Add a public API to ChangeDetectionStrategy to turn this mode on\n   */\n  ManualOnPush = 0b00000100000,\n\n  /** Whether or not this view is currently dirty (needing check) */\n  Dirty = 0b000001000000,\n\n  /** Whether or not this view is currently attached to change detection tree. */\n  Attached = 0b000010000000,\n\n  /** Whether or not this view is destroyed. */\n  Destroyed = 0b000100000000,\n\n  /** Whether or not this view is the root view */\n  IsRoot = 0b001000000000,\n\n  /**\n   * Index of the current init phase on last 22 bits\n   */\n  IndexWithinInitPhaseIncrementer = 0b010000000000,\n  IndexWithinInitPhaseShift = 10,\n  IndexWithinInitPhaseReset = 0b001111111111,\n}\n\n/**\n * Possible states of the init phase:\n * - 00: OnInit hooks to be run.\n * - 01: AfterContentInit hooks to be run\n * - 10: AfterViewInit hooks to be run\n * - 11: All init hooks have been run\n */\nexport const enum InitPhaseState {\n  OnInitHooksToBeRun = 0b00,\n  AfterContentInitHooksToBeRun = 0b01,\n  AfterViewInitHooksToBeRun = 0b10,\n  InitPhaseCompleted = 0b11,\n}\n\n/** More flags associated with an LView (saved in LView[PREORDER_HOOK_FLAGS]) */\nexport const enum PreOrderHookFlags {\n  /** The index of the next pre-order hook to be called in the hooks array, on the first 16\n     bits */\n  IndexOfTheNextPreOrderHookMaskMask = 0b01111111111111111,\n\n  /**\n   * The number of init hooks that have already been called, on the last 16 bits\n   */\n  NumberOfInitHooksCalledIncrementer = 0b010000000000000000,\n  NumberOfInitHooksCalledShift = 16,\n  NumberOfInitHooksCalledMask = 0b11111111111111110000000000000000,\n}\n\n/**\n * Set of instructions used to process host bindings efficiently.\n *\n * See VIEW_DATA.md for more information.\n */\nexport interface ExpandoInstructions extends Array<number|HostBindingsFunction<any>|null> {}\n\n/**\n * Explicitly marks `TView` as a specific type in `ngDevMode`\n *\n * It is useful to know conceptually what time of `TView` we are dealing with when\n * debugging an application (even if the runtime does not need it.) For this reason\n * we store this information in the `ngDevMode` `TView` and than use it for\n * better debugging experience.\n */\nexport const enum TViewType {\n  /**\n   * Root `TView` is the used to bootstrap components into. It is used in conjunction with\n   * `LView` which takes an existing DOM node not owned by Angular and wraps it in `TView`/`LView`\n   * so that other components can be loaded into it.\n   */\n  Root = 0,\n\n  /**\n   * `TView` associated with a Component. This would be the `TView` directly associated with the\n   * component view (as opposed an `Embedded` `TView` which would be a child of `Component` `TView`)\n   */\n  Component = 1,\n\n  /**\n   * `TView` associated with a template. Such as `*ngIf`, `<ng-template>` etc... A `Component`\n   * can have zero or more `Embedede` `TView`s.\n   */\n  Embedded = 2,\n}\n\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the `ComponentDef.tView`.\n */\nexport interface TView {\n  /**\n   * Type of `TView` (`Root`|`Component`|`Embedded`).\n   */\n  type: TViewType;\n\n  /**\n   * ID for inline views to determine whether a view is the same as the previous view\n   * in a certain position. If it's not, we know the new view needs to be inserted\n   * and the one that exists needs to be removed (e.g. if/else statements)\n   *\n   * If this is -1, then this is a component view or a dynamically created view.\n   */\n  readonly id: number;\n\n  /**\n   * This is a blueprint used to generate LView instances for this TView. Copying this\n   * blueprint is faster than creating a new LView from scratch.\n   */\n  blueprint: LView;\n\n  /**\n   * The template function used to refresh the view of dynamically created views\n   * and components. Will be null for inline views.\n   */\n  template: ComponentTemplate<{}>|null;\n\n  /**\n   * A function containing query-related instructions.\n   */\n  viewQuery: ViewQueriesFunction<{}>|null;\n\n  /**\n   * Pointer to the host `TNode` (not part of this TView).\n   *\n   * If this is a `TViewNode` for an `LViewNode`, this is an embedded view of a container.\n   * We need this pointer to be able to efficiently find this node when inserting the view\n   * into an anchor.\n   *\n   * If this is a `TElementNode`, this is the view of a root component. It has exactly one\n   * root TNode.\n   *\n   * If this is null, this is the view of a component that is not at root. We do not store\n   * the host TNodes for child component views because they can potentially have several\n   * different host TNodes, depending on where the component is being used. These host\n   * TNodes cannot be shared (due to different indices, etc).\n   */\n  node: TViewNode|TElementNode|null;\n\n  /** Whether or not this template has been processed in creation mode. */\n  firstCreatePass: boolean;\n\n  /** Whether or not the first update for this template has been processed. */\n  firstUpdatePass: boolean;\n\n  /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */\n  data: TData;\n\n  /**\n   * The binding start index is the index at which the data array\n   * starts to store bindings only. Saving this value ensures that we\n   * will begin reading bindings at the correct point in the array when\n   * we are in update mode.\n   *\n   * -1 means that it has not been initialized.\n   */\n  bindingStartIndex: number;\n\n  /**\n   * The index where the \"expando\" section of `LView` begins. The expando\n   * section contains injectors, directive instances, and host binding values.\n   * Unlike the \"decls\" and \"vars\" sections of `LView`, the length of this\n   * section cannot be calculated at compile-time because directives are matched\n   * at runtime to preserve locality.\n   *\n   * We store this start index so we know where to start checking host bindings\n   * in `setHostBindings`.\n   */\n  expandoStartIndex: number;\n\n  /**\n   * Whether or not there are any static view queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a view query\n   * refresh after creation mode to collect static query results.\n   */\n  staticViewQueries: boolean;\n\n  /**\n   * Whether or not there are any static content queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a content query\n   * refresh after creation mode to collect static query results.\n   */\n  staticContentQueries: boolean;\n\n  /**\n   * A reference to the first child node located in the view.\n   */\n  firstChild: TNode|null;\n\n  /**\n   * Set of instructions used to process host bindings efficiently.\n   *\n   * See VIEW_DATA.md for more information.\n   */\n  expandoInstructions: ExpandoInstructions|null;\n\n  /**\n   * Full registry of directives and components that may be found in this view.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  directiveRegistry: DirectiveDefList|null;\n\n  /**\n   * Full registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  pipeRegistry: PipeDefList|null;\n\n  /**\n   * Array of ngOnInit, ngOnChanges and ngDoCheck hooks that should be executed for this view in\n   * creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  preOrderHooks: HookData|null;\n\n  /**\n   * Array of ngOnChanges and ngDoCheck hooks that should be executed for this view in update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  preOrderCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n   * for this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentChecked hooks that should be executed for this view in update\n   * mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n   * this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewChecked hooks that should be executed for this view in\n   * update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewCheckHooks: HookData|null;\n\n  /**\n   * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  destroyHooks: HookData|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n   * and output data (in chunks of 2) for a particular view. Combining the arrays\n   * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n   * separate for loops).\n   *\n   * If it's a native DOM listener or output subscription being stored:\n   * 1st index is: event name  `name = tView.cleanup[i+0]`\n   * 2nd index is: index of native element or a function that retrieves global target (window,\n   *               document or body) reference based on the native element:\n   *    `typeof idxOrTargetGetter === 'function'`: global target getter function\n   *    `typeof idxOrTargetGetter === 'number'`: index of native element\n   *\n   * 3rd index is: index of listener function `listener = lView[CLEANUP][tView.cleanup[i+2]]`\n   * 4th index is: `useCaptureOrIndx = tView.cleanup[i+3]`\n   *    `typeof useCaptureOrIndx == 'boolean' : useCapture boolean\n   *    `typeof useCaptureOrIndx == 'number':\n   *         `useCaptureOrIndx >= 0` `removeListener = LView[CLEANUP][useCaptureOrIndx]`\n   *         `useCaptureOrIndx <  0` `subscription = LView[CLEANUP][-useCaptureOrIndx]`\n   *\n   * If it's an output subscription or query list destroy hook:\n   * 1st index is: output unsubscribe function / query list destroy function\n   * 2nd index is: index of function context in LView.cleanupInstances[]\n   *               `tView.cleanup[i+0].call(lView[CLEANUP][tView.cleanup[i+1]])`\n   */\n  cleanup: any[]|null;\n\n  /**\n   * A list of element indices for child components that will need to be\n   * refreshed when the current view has finished its check. These indices have\n   * already been adjusted for the HEADER_OFFSET.\n   *\n   */\n  components: number[]|null;\n\n  /**\n   * A collection of queries tracked in a given view.\n   */\n  queries: TQueries|null;\n\n  /**\n   * An array of indices pointing to directives with content queries alongside with the\n   * corresponding\n   * query index. Each entry in this array is a tuple of:\n   * - index of the first content query index declared by a given directive;\n   * - index of a directive.\n   *\n   * We are storing those indexes so we can refresh content queries as part of a view refresh\n   * process.\n   */\n  contentQueries: number[]|null;\n\n  /**\n   * Set of schemas that declare elements to be allowed inside the view.\n   */\n  schemas: SchemaMetadata[]|null;\n\n  /**\n   * Array of constants for the view. Includes attribute arrays, local definition arrays etc.\n   * Used for directive matching, attribute bindings, local definitions and more.\n   */\n  consts: TConstants|null;\n}\n\nexport const enum RootContextFlags {Empty = 0b00, DetectChanges = 0b01, FlushPlayers = 0b10}\n\n\n/**\n * RootContext contains information which is shared for all components which\n * were bootstrapped with {@link renderComponent}.\n */\nexport interface RootContext {\n  /**\n   * A function used for scheduling change detection in the future. Usually\n   * this is `requestAnimationFrame`.\n   */\n  scheduler: (workFn: () => void) => void;\n\n  /**\n   * A promise which is resolved when all components are considered clean (not dirty).\n   *\n   * This promise is overwritten every time a first call to {@link markDirty} is invoked.\n   */\n  clean: Promise<null>;\n\n  /**\n   * RootComponents - The components that were instantiated by the call to\n   * {@link renderComponent}.\n   */\n  components: {}[];\n\n  /**\n   * The player flushing handler to kick off all animations\n   */\n  playerHandler: PlayerHandler|null;\n\n  /**\n   * What render-related operations to run once a scheduler has been set\n   */\n  flags: RootContextFlags;\n}\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * For each node of the view, the following data is stored:\n * 1) Node index (optional)\n * 2) A series of number/function pairs where:\n *  - even indices are directive indices\n *  - odd indices are hook functions\n *\n * Special cases:\n *  - a negative directive index flags an init hook (ngOnInit, ngAfterContentInit, ngAfterViewInit)\n */\nexport type HookData = (number | (() => void))[];\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Each host property's name is stored here at the same index as its value in the\n * data array.\n *\n * Each property binding name is stored here at the same index as its value in\n * the data array. If the binding is an interpolation, the static string values\n * are stored parallel to the dynamic values. Example:\n *\n * id=\"prefix {{ v0 }} a {{ v1 }} b {{ v2 }} suffix\"\n *\n * LView       |   TView.data\n *------------------------\n *  v0 value   |   'a'\n *  v1 value   |   'b'\n *  v2 value   |   id ï¿½ prefix ï¿½ suffix\n *\n * Injector bloom filters are also stored here.\n */\nexport type TData =\n    (TNode | PipeDef<any>| DirectiveDef<any>| ComponentDef<any>| number | Type<any>|\n     InjectionToken<any>| TI18n | I18nUpdateOpCodes | null | string)[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewRef} from '../../linker/view_ref';\n\nimport {TNode} from './node';\nimport {RComment, RElement} from './renderer';\n\nimport {HOST, LView, NEXT, PARENT, T_HOST} from './view';\n\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nexport const TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\nexport const ACTIVE_INDEX = 2;\n\n// PARENT and NEXT are indices 3 and 4\n// As we already have these constants in LView, we don't need to re-create them.\n\nexport const MOVED_VIEWS = 5;\n\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\n\nexport const NATIVE = 7;\nexport const VIEW_REFS = 8;\n\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nexport const CONTAINER_HEADER_OFFSET = 9;\n\n\n/**\n * Used to track:\n *  - Inline embedded views (see: `ÉµÉµembeddedViewStart`)\n *  - Transplanted `LView`s (see: `LView[DECLARATION_COMPONENT_VIEW])`\n */\nexport const enum ActiveIndexFlag {\n  /**\n   * Flag which signifies that the `LContainer` does not have any inline embedded views.\n   */\n  DYNAMIC_EMBEDDED_VIEWS_ONLY = -1,\n\n  /**\n   * Flag to signify that this `LContainer` may have transplanted views which need to be change\n   * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n   *\n   * This flag once set is never unset for the `LContainer`. This means that when unset we can skip\n   * a lot of work in `refreshDynamicEmbeddedViews`. But when set we still need to verify\n   * that the `MOVED_VIEWS` are transplanted and on-push.\n   */\n  HAS_TRANSPLANTED_VIEWS = 1,\n\n  /**\n   * Number of bits to shift inline embedded views counter to make space for other flags.\n   */\n  SHIFT = 1,\n\n\n  /**\n   * When incrementing the active index for inline embedded views, the amount to increment to leave\n   * space for other flags.\n   */\n  INCREMENT = 1 << SHIFT,\n}\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n  /**\n   * The host element of this LContainer.\n   *\n   * The host could be an LView if this container is on a component node.\n   * In that case, the component LView is its HOST.\n   */\n  readonly[HOST]: RElement|RComment|LView;\n\n  /**\n   * This is a type field which allows us to differentiate `LContainer` from `StylingContext` in an\n   * efficient way. The value is always set to `true`\n   */\n  [TYPE]: true;\n\n  /**\n   * The next active index in the views array to read or write to. This helps us\n   * keep track of where we are in the views array.\n   * In the case the LContainer is created for a ViewContainerRef,\n   * it is set to null to identify this scenario, as indices are \"absolute\" in that case,\n   * i.e. provided directly by the user of the ViewContainerRef API.\n   *\n   * This is used by `ÉµÉµembeddedViewStart` to track which `LView` is currently active.\n   * Because `ÉµÉµembeddedViewStart` is not generated by the compiler this feature is essentially\n   * unused.\n   *\n   * The lowest bit signals that this `LContainer` has transplanted views which need to be change\n   * detected as part of the declaration CD. (See `LView[DECLARATION_COMPONENT_VIEW]`)\n   */\n  [ACTIVE_INDEX]: ActiveIndexFlag;\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent[NEXT].\n   */\n  [PARENT]: LView;\n\n  /**\n   * This allows us to jump from a container to a sibling container or component\n   * view with the same parent, so we can remove listeners efficiently.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /**\n   * A collection of views created based on the underlying `<ng-template>` element but inserted into\n   * a different `LContainer`. We need to track views created from a given declaration point since\n   * queries collect matches from the embedded view declaration point and _not_ the insertion point.\n   */\n  [MOVED_VIEWS]: LView[]|null;\n\n  /**\n   * Pointer to the `TNode` which represents the host of the container.\n   */\n  [T_HOST]: TNode;\n\n  /** The comment element that serves as an anchor for this LContainer. */\n  readonly[NATIVE]:\n      RComment;  // TODO(misko): remove as this value can be gotten by unwrapping `[HOST]`\n\n  /**\n   * Array of `ViewRef`s used by any `ViewContainerRef`s that point to this container.\n   *\n   * This is lazily initialized by `ViewContainerRef` when the first view is inserted.\n   */\n  [VIEW_REFS]: ViewRef[]|null;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentDef, DirectiveDef} from '..';\n\nimport {LContainer, TYPE} from './container';\nimport {TNode, TNodeFlags} from './node';\nimport {RNode} from './renderer';\nimport {FLAGS, LView, LViewFlags} from './view';\n\n\n/**\n* True if `value` is `LView`.\n* @param value wrapped value of `RNode`, `LView`, `LContainer`\n*/\nexport function isLView(value: RNode | LView | LContainer | {} | null): value is LView {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLContainer(value: RNode | LView | LContainer | {} | null): value is LContainer {\n  return Array.isArray(value) && value[TYPE] === true;\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponentHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponentHost) === TNodeFlags.isComponentHost;\n}\n\nexport function isDirectiveHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isDirectiveHost) === TNodeFlags.isDirectiveHost;\n}\n\nexport function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T> {\n  return (def as ComponentDef<T>).template !== null;\n}\n\nexport function isRootView(target: LView): boolean {\n  return (target[FLAGS] & LViewFlags.IsRoot) !== 0;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual, throwError} from '../util/assert';\n\nimport {getComponentDef, getNgModuleDef} from './definition';\nimport {TNode} from './interfaces/node';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {LView, TVIEW, TView} from './interfaces/view';\n\nexport function assertTNodeForLView(tNode: TNode, lView: LView) {\n  tNode.hasOwnProperty('tView_') && assertEqual(\n                                        (tNode as any as{tView_: TView}).tView_, lView[TVIEW],\n                                        'This TNode does not belong to this LView.');\n}\n\nexport function assertComponentType(\n    actual: any,\n    msg: string = 'Type passed in is not ComponentType, it does not have \\'Éµcmp\\' property.') {\n  if (!getComponentDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertNgModuleType(\n    actual: any,\n    msg: string = 'Type passed in is not NgModuleType, it does not have \\'Éµmod\\' property.') {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertPreviousIsParent(isParent: boolean) {\n  assertEqual(isParent, true, 'previousOrParentTNode should be a parent');\n}\n\nexport function assertHasParent(tNode: TNode | null) {\n  assertDefined(tNode, 'previousOrParentTNode should exist!');\n  assertDefined(tNode !.parent, 'previousOrParentTNode should have a parent');\n}\n\nexport function assertDataNext(lView: LView, index: number, arr?: any[]) {\n  if (arr == null) arr = lView;\n  assertEqual(\n      arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\n\nexport function assertLContainerOrUndefined(value: any): void {\n  value && assertEqual(isLContainer(value), true, 'Expecting LContainer or undefined or null');\n}\n\nexport function assertLContainer(value: any): void {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\n\nexport function assertLViewOrUndefined(value: any): void {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\n\nexport function assertLView(value: any) {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\n\nexport function assertFirstCreatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n      tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\n\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nexport function assertDirectiveDef(obj: any) {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(\n        `Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\nimport {assertDefined, assertEqual} from '../util/assert';\n\nimport {assertLViewOrUndefined} from './assert';\nimport {ComponentDef, DirectiveDef} from './interfaces/definition';\nimport {TNode} from './interfaces/node';\nimport {CONTEXT, DECLARATION_VIEW, LView, OpaqueViewState, TVIEW} from './interfaces/view';\n\n\n/**\n *\n */\ninterface LFrame {\n  /**\n   * Parent LFrame.\n   *\n   * This is needed when `leaveView` is called to restore the previous state.\n   */\n  parent: LFrame;\n\n  /**\n   * Child LFrame.\n   *\n   * This is used to cache existing LFrames to relieve the memory pressure.\n   */\n  child: LFrame|null;\n\n  /**\n   * State of the current view being processed.\n   *\n   * An array of nodes (text, element, container, etc), pipes, their bindings, and\n   * any local variables that need to be stored between invocations.\n   */\n  lView: LView;\n\n  /**\n   * Used to set the parent property when nodes are created and track query results.\n   *\n   * This is used in conjection with `isParent`.\n   */\n  previousOrParentTNode: TNode;\n\n  /**\n   * If `isParent` is:\n   *  - `true`: then `previousOrParentTNode` points to a parent node.\n   *  - `false`: then `previousOrParentTNode` points to previous node (sibling).\n   */\n  isParent: boolean;\n\n  /**\n   * Index of currently selected element in LView.\n   *\n   * Used by binding instructions. Updated as part of advance instruction.\n   */\n  selectedIndex: number;\n\n  /**\n   * Current pointer to the binding index.\n   */\n  bindingIndex: number;\n\n  /**\n   * The last viewData retrieved by nextContext().\n   * Allows building nextContext() and reference() calls.\n   *\n   * e.g. const inner = x().$implicit; const outer = x().$implicit;\n   */\n  contextLView: LView;\n\n  /**\n   * Store the element depth count. This is used to identify the root elements of the template\n   * so that we can then attach patch data `LView` to only those elements. We know that those\n   * are the only places where the patch data could change, this way we will save on number\n   * of places where tha patching occurs.\n   */\n  elementDepthCount: number;\n\n  /**\n   * Current namespace to be used when creating elements\n   */\n  currentNamespace: string|null;\n\n  /**\n   * Current sanitizer\n   */\n  currentSanitizer: StyleSanitizeFn|null;\n\n\n  /**\n   * Used when processing host bindings.\n   */\n  currentDirectiveDef: DirectiveDef<any>|ComponentDef<any>|null;\n\n  /**\n   * Used as the starting directive id value.\n   *\n   * All subsequent directives are incremented from this value onwards.\n   * The reason why this value is `1` instead of `0` is because the `0`\n   * value is reserved for the template.\n   */\n  activeDirectiveId: number;\n\n  /**\n   * The root index from which pure function instructions should calculate their binding\n   * indices. In component views, this is TView.bindingStartIndex. In a host binding\n   * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n   */\n  bindingRootIndex: number;\n\n  /**\n   * Current index of a View or Content Query which needs to be processed next.\n   * We iterate over the list of Queries and increment current query index at every step.\n   */\n  currentQueryIndex: number;\n}\n\n/**\n * All implicit instruction state is stored here.\n *\n * It is useful to have a single object where all of the state is stored as a mental model\n * (rather it being spread across many different variables.)\n *\n * PERF NOTE: Turns out that writing to a true global variable is slower than\n * having an intermediate object with properties.\n */\ninterface InstructionState {\n  /**\n   * Current `LFrame`\n   *\n   * `null` if we have not called `enterView`\n   */\n  lFrame: LFrame;\n\n  /**\n   * Stores whether directives should be matched to elements.\n   *\n   * When template contains `ngNonBindable` then we need to prevent the runtime from matching\n   * directives on children of that element.\n   *\n   * Example:\n   * ```\n   * <my-comp my-directive>\n   *   Should match component / directive.\n   * </my-comp>\n   * <div ngNonBindable>\n   *   <my-comp my-directive>\n   *     Should not match component / directive because we are in ngNonBindable.\n   *   </my-comp>\n   * </div>\n   * ```\n   */\n  bindingsEnabled: boolean;\n\n  /**\n   * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n   *\n   * Necessary to support ChangeDetectorRef.checkNoChanges().\n   */\n  checkNoChangesMode: boolean;\n\n  /**\n   * Function to be called when the element is exited.\n   *\n   * NOTE: The function is here for tree shakable purposes since it is only needed by styling.\n   */\n  elementExitFn: (() => void)|null;\n}\n\nexport const instructionState: InstructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true,\n  elementExitFn: null,\n  checkNoChangesMode: false,\n};\n\n\nexport function getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\n\nexport function increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\n\nexport function decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\n\nexport function getCurrentDirectiveDef(): DirectiveDef<any>|ComponentDef<any>|null {\n  return instructionState.lFrame.currentDirectiveDef;\n}\n\nexport function setCurrentDirectiveDef(def: DirectiveDef<any>| ComponentDef<any>| null): void {\n  instructionState.lFrame.currentDirectiveDef = def;\n}\n\nexport function getBindingsEnabled(): boolean {\n  return instructionState.bindingsEnabled;\n}\n\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ÉµÉµdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ÉµÉµenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ÉµÉµenableBindings(): void {\n  instructionState.bindingsEnabled = true;\n}\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ÉµÉµdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ÉµÉµenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ÉµÉµdisableBindings(): void {\n  instructionState.bindingsEnabled = false;\n}\n\n/**\n * Return the current LView.\n *\n * The return value can be `null` if the method is called outside of template. This can happen if\n * directive is instantiated by module injector (rather than by node injector.)\n */\nexport function getLView(): LView {\n  // TODO(misko): the return value should be `LView|null` but doing so breaks a lot of code.\n  const lFrame = instructionState.lFrame;\n  return lFrame === null ? null ! : lFrame.lView;\n}\n\n/**\n * Flags used for an active element during change detection.\n *\n * These flags are used within other instructions to inform cleanup or\n * exit operations to run when an element is being processed.\n *\n * Note that these flags are reset each time an element changes (whether it\n * happens when `advance()` is run or when change detection exits out of a template\n * function or when all host bindings are processed for an element).\n */\nexport const enum ActiveElementFlags {\n  Initial = 0b00,\n  RunExitFn = 0b01,\n  Size = 1,\n}\n\n/**\n * Determines whether or not a flag is currently set for the active element.\n */\nexport function hasActiveElementFlag(flag: ActiveElementFlags) {\n  return (instructionState.lFrame.selectedIndex & flag) === flag;\n}\n\n/**\n * Sets a flag is for the active element.\n */\nfunction setActiveElementFlag(flag: ActiveElementFlags) {\n  instructionState.lFrame.selectedIndex |= flag;\n}\n\n/**\n * Sets the active directive host element and resets the directive id value\n * (when the provided elementIndex value has changed).\n *\n * @param elementIndex the element index value for the host element where\n *                     the directive/component instance lives\n */\nexport function setActiveHostElement(elementIndex: number | null) {\n  if (hasActiveElementFlag(ActiveElementFlags.RunExitFn)) {\n    executeElementExitFn();\n  }\n  setSelectedIndex(elementIndex === null ? -1 : elementIndex);\n  instructionState.lFrame.activeDirectiveId = 0;\n}\n\nexport function executeElementExitFn() {\n  instructionState.elementExitFn !();\n  instructionState.lFrame.selectedIndex &= ~ActiveElementFlags.RunExitFn;\n}\n\n/**\n * Queues a function to be run once the element is \"exited\" in CD.\n *\n * Change detection will focus on an element either when the `advance()`\n * instruction is called or when the template or host bindings instruction\n * code is invoked. The element is then \"exited\" when the next element is\n * selected or when change detection for the template or host bindings is\n * complete. When this occurs (the element change operation) then an exit\n * function will be invoked if it has been set. This function can be used\n * to assign that exit function.\n *\n * @param fn\n */\nexport function setElementExitFn(fn: () => void): void {\n  setActiveElementFlag(ActiveElementFlags.RunExitFn);\n  if (instructionState.elementExitFn === null) {\n    instructionState.elementExitFn = fn;\n  }\n  ngDevMode &&\n      assertEqual(instructionState.elementExitFn, fn, 'Expecting to always get the same function');\n}\n\n/**\n * Returns the current id value of the current directive.\n *\n * For example we have an element that has two directives on it:\n * <div dir-one dir-two></div>\n *\n * dirOne->hostBindings() (id == 1)\n * dirTwo->hostBindings() (id == 2)\n *\n * Note that this is only active when `hostBinding` functions are being processed.\n *\n * Note that directive id values are specific to an element (this means that\n * the same id value could be present on another element with a completely\n * different set of directives).\n */\nexport function getActiveDirectiveId() {\n  return instructionState.lFrame.activeDirectiveId;\n}\n\n/**\n * Increments the current directive id value.\n *\n * For example we have an element that has two directives on it:\n * <div dir-one dir-two></div>\n *\n * dirOne->hostBindings() (index = 1)\n * // increment\n * dirTwo->hostBindings() (index = 2)\n *\n * Depending on whether or not a previous directive had any inherited\n * directives present, that value will be incremented in addition\n * to the id jumping up by one.\n *\n * Note that this is only active when `hostBinding` functions are being processed.\n *\n * Note that directive id values are specific to an element (this means that\n * the same id value could be present on another element with a completely\n * different set of directives).\n */\nexport function incrementActiveDirectiveId() {\n  // Each directive gets a uniqueId value that is the same for both\n  // create and update calls when the hostBindings function is called. The\n  // directive uniqueId is not set anywhere--it is just incremented between\n  // each hostBindings call and is useful for helping instruction code\n  // uniquely determine which directive is currently active when executed.\n  instructionState.lFrame.activeDirectiveId += 1;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n *\n * @codeGenApi\n */\nexport function ÉµÉµrestoreView(viewToRestore: OpaqueViewState) {\n  instructionState.lFrame.contextLView = viewToRestore as any as LView;\n}\n\nexport function getPreviousOrParentTNode(): TNode {\n  return instructionState.lFrame.previousOrParentTNode;\n}\n\nexport function setPreviousOrParentTNode(tNode: TNode, _isParent: boolean) {\n  instructionState.lFrame.previousOrParentTNode = tNode;\n  instructionState.lFrame.isParent = _isParent;\n}\n\nexport function getIsParent(): boolean {\n  return instructionState.lFrame.isParent;\n}\n\nexport function setIsNotParent(): void {\n  instructionState.lFrame.isParent = false;\n}\nexport function setIsParent(): void {\n  instructionState.lFrame.isParent = true;\n}\n\nexport function getContextLView(): LView {\n  return instructionState.lFrame.contextLView;\n}\n\nexport function getCheckNoChangesMode(): boolean {\n  return instructionState.checkNoChangesMode;\n}\n\nexport function setCheckNoChangesMode(mode: boolean): void {\n  instructionState.checkNoChangesMode = mode;\n}\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    const lView = lFrame.lView;\n    index = lFrame.bindingRootIndex = lView[TVIEW].bindingStartIndex;\n  }\n  return index;\n}\n\nexport function getBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex;\n}\n\nexport function setBindingIndex(value: number): number {\n  return instructionState.lFrame.bindingIndex = value;\n}\n\nexport function nextBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex++;\n}\n\nexport function incrementBindingIndex(count: number): number {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\n\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n * @param value\n */\nexport function setBindingRoot(value: number) {\n  instructionState.lFrame.bindingRootIndex = value;\n}\n\nexport function getCurrentQueryIndex(): number {\n  return instructionState.lFrame.currentQueryIndex;\n}\n\nexport function setCurrentQueryIndex(value: number): void {\n  instructionState.lFrame.currentQueryIndex = value;\n}\n\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n * @param newView\n * @param tNode\n */\nexport function enterDI(newView: LView, tNode: TNode) {\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  instructionState.lFrame = newLFrame;\n  newLFrame.previousOrParentTNode = tNode !;\n  newLFrame.lView = newView;\n  if (ngDevMode) {\n    // resetting for safety in dev mode only.\n    newLFrame.isParent = DEV_MODE_VALUE;\n    newLFrame.selectedIndex = DEV_MODE_VALUE;\n    newLFrame.contextLView = DEV_MODE_VALUE;\n    newLFrame.elementDepthCount = DEV_MODE_VALUE;\n    newLFrame.currentNamespace = DEV_MODE_VALUE;\n    newLFrame.currentSanitizer = DEV_MODE_VALUE;\n    newLFrame.currentDirectiveDef = DEV_MODE_VALUE;\n    newLFrame.activeDirectiveId = DEV_MODE_VALUE;\n    newLFrame.bindingRootIndex = DEV_MODE_VALUE;\n    newLFrame.currentQueryIndex = DEV_MODE_VALUE;\n  }\n}\n\nconst DEV_MODE_VALUE: any =\n    'Value indicating that DI is trying to read value which it should not need to know about.';\n\n/**\n * This is a light weight version of the `leaveView` which is needed by the DI system.\n *\n * Because the implementation is same it is only an alias\n */\nexport const leaveDI = leaveView;\n\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @param tNode Element to which the View is a child of\n * @returns the previously active lView;\n */\nexport function enterView(newView: LView, tNode: TNode | null): void {\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  instructionState.lFrame = newLFrame;\n  newLFrame.previousOrParentTNode = tNode !;\n  newLFrame.isParent = true;\n  newLFrame.lView = newView;\n  newLFrame.selectedIndex = 0;\n  newLFrame.contextLView = newView !;\n  newLFrame.elementDepthCount = 0;\n  newLFrame.currentNamespace = null;\n  newLFrame.currentSanitizer = null;\n  newLFrame.currentDirectiveDef = null;\n  newLFrame.activeDirectiveId = 0;\n  newLFrame.bindingRootIndex = -1;\n  newLFrame.bindingIndex = newView === null ? -1 : newView[TVIEW].bindingStartIndex;\n  newLFrame.currentQueryIndex = 0;\n}\n\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\n\nfunction createLFrame(parent: LFrame | null): LFrame {\n  const lFrame: LFrame = {\n    previousOrParentTNode: null !,  //\n    isParent: true,                 //\n    lView: null !,                  //\n    selectedIndex: 0,               //\n    contextLView: null !,           //\n    elementDepthCount: 0,           //\n    currentNamespace: null,         //\n    currentSanitizer: null,         //\n    currentDirectiveDef: null,      //\n    activeDirectiveId: 0,           //\n    bindingRootIndex: -1,           //\n    bindingIndex: -1,               //\n    currentQueryIndex: 0,           //\n    parent: parent !,               //\n    child: null,                    //\n  };\n  parent !== null && (parent.child = lFrame);  // link the new LFrame for reuse.\n  return lFrame;\n}\n\nexport function leaveViewProcessExit() {\n  if (hasActiveElementFlag(ActiveElementFlags.RunExitFn)) {\n    executeElementExitFn();\n  }\n  leaveView();\n}\n\nexport function leaveView() {\n  instructionState.lFrame = instructionState.lFrame.parent;\n}\n\nexport function nextContextImpl<T = any>(level: number): T {\n  const contextLView = instructionState.lFrame.contextLView =\n      walkUpViews(level, instructionState.lFrame.contextLView !);\n  return contextLView[CONTEXT] as T;\n}\n\nfunction walkUpViews(nestingLevel: number, currentView: LView): LView {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(\n                     currentView[DECLARATION_VIEW],\n                     'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW] !;\n    nestingLevel--;\n  }\n  return currentView;\n}\n\n/**\n * Gets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nexport function getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex >> ActiveElementFlags.Size;\n}\n\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nexport function setSelectedIndex(index: number) {\n  instructionState.lFrame.selectedIndex = index << ActiveElementFlags.Size;\n}\n\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nexport function ÉµÉµnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = 'http://www.w3.org/2000/svg';\n}\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nexport function ÉµÉµnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = 'http://www.w3.org/1998/MathML/';\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nexport function ÉµÉµnamespaceHTML() {\n  namespaceHTMLInternal();\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nexport function namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\n\nexport function getNamespace(): string|null {\n  return instructionState.lFrame.currentNamespace;\n}\n\nexport function setCurrentStyleSanitizer(sanitizer: StyleSanitizeFn | null) {\n  instructionState.lFrame.currentSanitizer = sanitizer;\n}\n\nexport function resetCurrentStyleSanitizer() {\n  setCurrentStyleSanitizer(null);\n}\n\nexport function getCurrentStyleSanitizer() {\n  // TODO(misko): This should throw when there is no LView, but it turns out we can get here from\n  // `NodeStyleDebug` hence we return `null`. This should be fixed\n  const lFrame = instructionState.lFrame;\n  return lFrame === null ? null : lFrame.currentSanitizer;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertNotEqual} from '../util/assert';\n\nimport {assertFirstCreatePass} from './assert';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TNode} from './interfaces/node';\nimport {FLAGS, HookData, InitPhaseState, LView, LViewFlags, PREORDER_HOOK_FLAGS, PreOrderHookFlags, TView} from './interfaces/view';\nimport {getCheckNoChangesMode} from './state';\n\n\n\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\nexport function registerPreOrderHooks(\n    directiveIndex: number, directiveDef: DirectiveDef<any>, tView: TView): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  const {onChanges, onInit, doCheck} = directiveDef;\n\n  if (onChanges) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, onChanges);\n    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, onChanges);\n  }\n\n  if (onInit) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(-directiveIndex, onInit);\n  }\n\n  if (doCheck) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, doCheck);\n    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, doCheck);\n  }\n}\n\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\nexport function registerPostOrderHooks(tView: TView, tNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  // It's necessary to loop through the directives at elementEnd() (rather than processing in\n  // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n  // hooks for projected components and directives must be called *before* their hosts.\n  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n    const directiveDef = tView.data[i] as DirectiveDef<any>;\n    if (directiveDef.afterContentInit) {\n      (tView.contentHooks || (tView.contentHooks = [])).push(-i, directiveDef.afterContentInit);\n    }\n\n    if (directiveDef.afterContentChecked) {\n      (tView.contentHooks || (tView.contentHooks = [])).push(i, directiveDef.afterContentChecked);\n      (tView.contentCheckHooks || (tView.contentCheckHooks = [\n       ])).push(i, directiveDef.afterContentChecked);\n    }\n\n    if (directiveDef.afterViewInit) {\n      (tView.viewHooks || (tView.viewHooks = [])).push(-i, directiveDef.afterViewInit);\n    }\n\n    if (directiveDef.afterViewChecked) {\n      (tView.viewHooks || (tView.viewHooks = [])).push(i, directiveDef.afterViewChecked);\n      (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, directiveDef.afterViewChecked);\n    }\n\n    if (directiveDef.onDestroy != null) {\n      (tView.destroyHooks || (tView.destroyHooks = [])).push(i, directiveDef.onDestroy);\n    }\n  }\n}\n\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n\n\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nexport function executeCheckHooks(lView: LView, hooks: HookData, nodeIndex?: number | null) {\n  callHooks(lView, hooks, InitPhaseState.InitPhaseCompleted, nodeIndex);\n}\n\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nexport function executeInitAndCheckHooks(\n    lView: LView, hooks: HookData, initPhase: InitPhaseState, nodeIndex?: number | null) {\n  ngDevMode && assertNotEqual(\n                   initPhase, InitPhaseState.InitPhaseCompleted,\n                   'Init pre-order hooks should not be called more than once');\n  if ((lView[FLAGS] & LViewFlags.InitPhaseStateMask) === initPhase) {\n    callHooks(lView, hooks, initPhase, nodeIndex);\n  }\n}\n\nexport function incrementInitPhaseFlags(lView: LView, initPhase: InitPhaseState): void {\n  ngDevMode &&\n      assertNotEqual(\n          initPhase, InitPhaseState.InitPhaseCompleted,\n          'Init hooks phase should not be incremented after all init hooks have been run.');\n  let flags = lView[FLAGS];\n  if ((flags & LViewFlags.InitPhaseStateMask) === initPhase) {\n    flags &= LViewFlags.IndexWithinInitPhaseReset;\n    flags += LViewFlags.InitPhaseStateIncrementer;\n    lView[FLAGS] = flags;\n  }\n}\n\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction callHooks(\n    currentView: LView, arr: HookData, initPhase: InitPhaseState,\n    currentNodeIndex: number | null | undefined): void {\n  ngDevMode && assertEqual(\n                   getCheckNoChangesMode(), false,\n                   'Hooks should never be run in the check no changes mode.');\n  const startIndex = currentNodeIndex !== undefined ?\n      (currentView[PREORDER_HOOK_FLAGS] & PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask) :\n      0;\n  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n  let lastNodeIndexFound = 0;\n  for (let i = startIndex; i < arr.length; i++) {\n    const hook = arr[i + 1] as() => void;\n    if (typeof hook === 'number') {\n      lastNodeIndexFound = arr[i] as number;\n      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n        break;\n      }\n    } else {\n      const isInitHook = arr[i] < 0;\n      if (isInitHook)\n        currentView[PREORDER_HOOK_FLAGS] += PreOrderHookFlags.NumberOfInitHooksCalledIncrementer;\n      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n        callHook(currentView, initPhase, arr, i);\n        currentView[PREORDER_HOOK_FLAGS] =\n            (currentView[PREORDER_HOOK_FLAGS] & PreOrderHookFlags.NumberOfInitHooksCalledMask) + i +\n            2;\n      }\n      i++;\n    }\n  }\n}\n\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\nfunction callHook(currentView: LView, initPhase: InitPhaseState, arr: HookData, i: number) {\n  const isInitHook = arr[i] < 0;\n  const hook = arr[i + 1] as() => void;\n  const directiveIndex = isInitHook ? -arr[i] : arr[i] as number;\n  const directive = currentView[directiveIndex];\n  if (isInitHook) {\n    const indexWithintInitPhase = currentView[FLAGS] >> LViewFlags.IndexWithinInitPhaseShift;\n    // The init phase state must be always checked here as it may have been recursively\n    // updated\n    if (indexWithintInitPhase <\n            (currentView[PREORDER_HOOK_FLAGS] >> PreOrderHookFlags.NumberOfInitHooksCalledShift) &&\n        (currentView[FLAGS] & LViewFlags.InitPhaseStateMask) === initPhase) {\n      currentView[FLAGS] += LViewFlags.IndexWithinInitPhaseIncrementer;\n      hook.call(directive);\n    }\n  } else {\n    hook.call(directive);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {InjectFlags} from '../../di/interface/injector';\nimport {Type} from '../../interface/type';\n\nimport {TDirectiveHostNode} from './node';\nimport {LView, TData} from './view';\n\nexport const TNODE = 8;\nexport const PARENT_INJECTOR = 8;\nexport const INJECTOR_BLOOM_PARENT_SIZE = 9;\n\n/**\n * Represents a relative location of parent injector.\n *\n * The interfaces encodes number of parents `LView`s to traverse and index in the `LView`\n * pointing to the parent injector.\n */\nexport interface RelativeInjectorLocation { __brand__: 'RelativeInjectorLocationFlags'; }\n\nexport const enum RelativeInjectorLocationFlags {\n  InjectorIndexMask = 0b111111111111111,\n  ViewOffsetShift = 16,\n  NO_PARENT = -1,\n}\n\nexport const NO_PARENT_INJECTOR: RelativeInjectorLocation = -1 as any;\n\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n\n/**\n* Factory for creating instances of injectors in the NodeInjector.\n*\n* This factory is complicated by the fact that it can resolve `multi` factories as well.\n*\n* NOTE: Some of the fields are optional which means that this class has two hidden classes.\n* - One without `multi` support (most common)\n* - One with `multi` values, (rare).\n*\n* Since VMs can cache up to 4 inline hidden classes this is OK.\n*\n* - Single factory: Only `resolving` and `factory` is defined.\n* - `providers` factory: `componentProviders` is a number and `index = -1`.\n* - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n*/\nexport class NodeInjectorFactory {\n  /**\n   * The inject implementation to be activated when using the factory.\n   */\n  injectImpl: null|(<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T);\n\n  /**\n   * Marker set to true during factory invocation to see if we get into recursive loop.\n   * Recursive loop causes an error to be displayed.\n   */\n  resolving = false;\n\n  /**\n   * Marks that the token can see other Tokens declared in `viewProviders` on the same node.\n   */\n  canSeeViewProviders: boolean;\n\n  /**\n   * An array of factories to use in case of `multi` provider.\n   */\n  multi?: Array<() => any>;\n\n  /**\n   * Number of `multi`-providers which belong to the component.\n   *\n   * This is needed because when multiple components and directives declare the `multi` provider\n   * they have to be concatenated in the correct order.\n   *\n   * Example:\n   *\n   * If we have a component and directive active an a single element as declared here\n   * ```\n   * component:\n   *   provides: [ {provide: String, useValue: 'component', multi: true} ],\n   *   viewProvides: [ {provide: String, useValue: 'componentView', multi: true} ],\n   *\n   * directive:\n   *   provides: [ {provide: String, useValue: 'directive', multi: true} ],\n   * ```\n   *\n   * Then the expected results are:\n   *\n   * ```\n   * providers: ['component', 'directive']\n   * viewProviders: ['component', 'componentView', 'directive']\n   * ```\n   *\n   * The way to think about it is that the `viewProviders` have been inserted after the component\n   * but before the directives, which is why we need to know how many `multi`s have been declared by\n   * the component.\n   */\n  componentProviders?: number;\n\n  /**\n   * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.\n   * See `providerFactory`.\n   */\n  index?: number;\n\n  /**\n   * Because the same `multi` provider can be declared in `provides` and `viewProvides` it is\n   * possible for `viewProvides` to shadow the `provides`. For this reason we store the\n   * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.\n   *\n   * Example:\n   *\n   * Given:\n   * ```\n   * provides: [ {provide: String, useValue: 'all', multi: true} ],\n   * viewProvides: [ {provide: String, useValue: 'viewOnly', multi: true} ],\n   * ```\n   *\n   * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case\n   * of view injection. We further have to make sure that the shared instances (in our case\n   * `all`) are the exact same instance in both the content as well as the view injection. (We\n   * have to make sure that we don't double instantiate.) For this reason the `viewProvides`\n   * `Factory` has a pointer to the shadowed `provides` factory so that it can instantiate the\n   * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =\n   * ['all', 'viewOnly']`).\n   */\n  providerFactory?: NodeInjectorFactory|null;\n\n\n  constructor(\n      /**\n       * Factory to invoke in order to create a new instance.\n       */\n      public factory:\n          (this: NodeInjectorFactory, _: undefined,\n           /**\n            * array where injectables tokens are stored. This is used in\n            * case of an error reporting to produce friendlier errors.\n            */\n           tData: TData,\n           /**\n            * array where existing instances of injectables are stored. This is used in case\n            * of multi shadow is needed. See `multi` field documentation.\n            */\n           lView: LView,\n           /**\n            * The TNode of the same element injector.\n            */\n           tNode: TDirectiveHostNode) => any,\n      /**\n       * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n       */\n      isViewProvider: boolean, injectImplementation: null|\n      (<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T)) {\n    this.canSeeViewProviders = isViewProvider;\n    this.injectImpl = injectImplementation;\n  }\n}\n\nexport function isFactory(obj: any): obj is NodeInjectorFactory {\n  return obj instanceof NodeInjectorFactory;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual} from '../util/assert';\nimport {TNode, TNodeType} from './interfaces/node';\n\nexport function assertNodeType(tNode: TNode, type: TNodeType) {\n  assertDefined(tNode, 'should be called with a TNode');\n  assertEqual(tNode.type, type, `should be a ${typeName(type)}`);\n}\n\nexport function assertNodeOfPossibleTypes(tNode: TNode, ...types: TNodeType[]) {\n  assertDefined(tNode, 'should be called with a TNode');\n  const found = types.some(type => tNode.type === type);\n  assertEqual(\n      found, true,\n      `Should be one of ${types.map(typeName).join(', ')} but got ${typeName(tNode.type)}`);\n}\n\nfunction typeName(type: TNodeType): string {\n  if (type == TNodeType.Projection) return 'Projection';\n  if (type == TNodeType.Container) return 'Container';\n  if (type == TNodeType.IcuContainer) return 'IcuContainer';\n  if (type == TNodeType.View) return 'View';\n  if (type == TNodeType.Element) return 'Element';\n  if (type == TNodeType.ElementContainer) return 'ElementContainer';\n  return '<unknown>';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser`, `Server`, and `WebWorker`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\nlet DOCUMENT: Document|undefined = undefined;\n\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nexport function setDocument(document: Document | undefined): void {\n  DOCUMENT = document;\n}\n\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\nexport function getDocument(): Document {\n  if (DOCUMENT !== undefined) {\n    return DOCUMENT;\n  } else if (typeof document !== 'undefined') {\n    return document;\n  }\n  // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n  // the current platform is not a browser. Since this is not a supported scenario at the moment\n  // this should not happen in Angular apps.\n  // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n  // public API. Meanwhile we just return `undefined` and let the application fail.\n  return undefined !;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The goal here is to make sure that the browser DOM API is the Renderer.\n * We do this by defining a subset of DOM API to be the renderer and then\n * use that at runtime for rendering.\n *\n * At runtime we can then use the DOM api directly, in server or web-worker\n * it will be easy to implement such API.\n */\n\nimport {RendererStyleFlags2, RendererType2} from '../../render/api';\nimport {getDocument} from './document';\n\n// TODO: cleanup once the code is merged in angular/angular\nexport enum RendererStyleFlags3 {\n  Important = 1 << 0,\n  DashCase = 1 << 1\n}\n\nexport type Renderer3 = ObjectOrientedRenderer3 | ProceduralRenderer3;\n\nexport type GlobalTargetName = 'document' | 'window' | 'body';\n\nexport type GlobalTargetResolver = (element: any) => {\n  name: GlobalTargetName, target: EventTarget\n};\n\n/**\n * Object Oriented style of API needed to create elements and text nodes.\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade\n * (reducing payload size).\n * */\nexport interface ObjectOrientedRenderer3 {\n  createComment(data: string): RComment;\n  createElement(tagName: string): RElement;\n  createElementNS(namespace: string, tagName: string): RElement;\n  createTextNode(data: string): RText;\n\n  querySelector(selectors: string): RElement|null;\n}\n\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\nexport function isProceduralRenderer(renderer: ProceduralRenderer3 | ObjectOrientedRenderer3):\n    renderer is ProceduralRenderer3 {\n  return !!((renderer as any).listen);\n}\n\n/**\n * Procedural style of API needed to create elements and text nodes.\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the\n * facade that enables element manipulation. This also facilitates backwards compatibility\n * with Renderer2.\n */\nexport interface ProceduralRenderer3 {\n  destroy(): void;\n  createComment(value: string): RComment;\n  createElement(name: string, namespace?: string|null): RElement;\n  createText(value: string): RText;\n  /**\n   * This property is allowed to be null / undefined,\n   * in which case the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  destroyNode?: ((node: RNode) => void)|null;\n  appendChild(parent: RElement, newChild: RNode): void;\n  insertBefore(parent: RNode, newChild: RNode, refChild: RNode|null): void;\n  removeChild(parent: RElement, oldChild: RNode, isHostElement?: boolean): void;\n  selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): RElement;\n\n  parentNode(node: RNode): RElement|null;\n  nextSibling(node: RNode): RNode|null;\n\n  setAttribute(el: RElement, name: string, value: string, namespace?: string|null): void;\n  removeAttribute(el: RElement, name: string, namespace?: string|null): void;\n  addClass(el: RElement, name: string): void;\n  removeClass(el: RElement, name: string): void;\n  setStyle(\n      el: RElement, style: string, value: any,\n      flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  setProperty(el: RElement, name: string, value: any): void;\n  setValue(node: RText|RComment, value: string): void;\n\n  // TODO(misko): Deprecate in favor of addEventListener/removeEventListener\n  listen(\n      target: GlobalTargetName|RNode, eventName: string,\n      callback: (event: any) => boolean | void): () => void;\n}\n\nexport interface RendererFactory3 {\n  createRenderer(hostElement: RElement|null, rendererType: RendererType2|null): Renderer3;\n  begin?(): void;\n  end?(): void;\n}\n\nexport const domRendererFactory3: RendererFactory3 = {\n  createRenderer: (hostElement: RElement | null, rendererType: RendererType2 | null):\n                      Renderer3 => { return getDocument();}\n};\n\n/** Subset of API needed for appending elements and text nodes. */\nexport interface RNode {\n  /**\n   * Returns the parent Element, Document, or DocumentFragment\n   */\n  parentNode: RNode|null;\n\n\n  /**\n   * Returns the parent Element if there is one\n   */\n  parentElement: RElement|null;\n\n  /**\n   * Gets the Node immediately following this one in the parent's childNodes\n   */\n  nextSibling: RNode|null;\n\n  /**\n   * Removes a child from the current node and returns the removed node\n   * @param oldChild the child node to remove\n   */\n  removeChild(oldChild: RNode): RNode;\n\n  /**\n   * Insert a child node.\n   *\n   * Used exclusively for adding View root nodes into ViewAnchor location.\n   */\n  insertBefore(newChild: RNode, refChild: RNode|null, isViewRoot: boolean): void;\n\n  /**\n   * Append a child node.\n   *\n   * Used exclusively for building up DOM which are static (ie not View roots)\n   */\n  appendChild(newChild: RNode): RNode;\n}\n\n/**\n * Subset of API needed for writing attributes, properties, and setting up\n * listeners on Element.\n */\nexport interface RElement extends RNode {\n  style: RCssStyleDeclaration;\n  classList: RDomTokenList;\n  className: string;\n  textContent: string|null;\n  setAttribute(name: string, value: string): void;\n  removeAttribute(name: string): void;\n  setAttributeNS(namespaceURI: string, qualifiedName: string, value: string): void;\n  addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\n  removeEventListener(type: string, listener?: EventListener, options?: boolean): void;\n\n  setProperty?(name: string, value: any): void;\n}\n\nexport interface RCssStyleDeclaration {\n  removeProperty(propertyName: string): string;\n  setProperty(propertyName: string, value: string|null, priority?: string): void;\n}\n\nexport interface RDomTokenList {\n  add(token: string): void;\n  remove(token: string): void;\n}\n\nexport interface RText extends RNode { textContent: string|null; }\n\nexport interface RComment extends RNode { textContent: string|null; }\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AttributeMarker, TAttributes} from '../interfaces/node';\nimport {CssSelector} from '../interfaces/projection';\nimport {ProceduralRenderer3, RElement, Renderer3, isProceduralRenderer} from '../interfaces/renderer';\n\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nexport function setUpAttributes(renderer: Renderer3, native: RElement, attrs: TAttributes): number {\n  const isProc = isProceduralRenderer(renderer);\n\n  let i = 0;\n  while (i < attrs.length) {\n    const value = attrs[i];\n    if (typeof value === 'number') {\n      // only namespaces are supported. Other value types (such as style/class\n      // entries) are not supported in this function.\n      if (value !== AttributeMarker.NamespaceURI) {\n        break;\n      }\n\n      // we just landed on the marker value ... therefore\n      // we should skip to the next entry\n      i++;\n\n      const namespaceURI = attrs[i++] as string;\n      const attrName = attrs[i++] as string;\n      const attrVal = attrs[i++] as string;\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      isProc ?\n          (renderer as ProceduralRenderer3).setAttribute(native, attrName, attrVal, namespaceURI) :\n          native.setAttributeNS(namespaceURI, attrName, attrVal);\n    } else {\n      // attrName is string;\n      const attrName = value as string;\n      const attrVal = attrs[++i];\n      // Standard attributes\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (isAnimationProp(attrName)) {\n        if (isProc) {\n          (renderer as ProceduralRenderer3).setProperty(native, attrName, attrVal);\n        }\n      } else {\n        isProc ?\n            (renderer as ProceduralRenderer3).setAttribute(native, attrName, attrVal as string) :\n            native.setAttribute(attrName, attrVal as string);\n      }\n      i++;\n    }\n  }\n\n  // another piece of code may iterate over the same attributes array. Therefore\n  // it may be helpful to return the exact spot where the attributes array exited\n  // whether by running into an unsupported marker or if all the static values were\n  // iterated over.\n  return i;\n}\n\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nexport function isNameOnlyAttributeMarker(marker: string | AttributeMarker | CssSelector) {\n  return marker === AttributeMarker.Bindings || marker === AttributeMarker.Template ||\n      marker === AttributeMarker.I18n;\n}\n\nexport function isAnimationProp(name: string): boolean {\n  // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n  // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n  // charCodeAt doesn't allocate memory to return a substring.\n  return name.charCodeAt(0) === 64;  // @\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {NO_PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags} from '../interfaces/injector';\nimport {DECLARATION_VIEW, LView} from '../interfaces/view';\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\nexport function hasParentInjector(parentLocation: RelativeInjectorLocation): boolean {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\n\nexport function getParentInjectorIndex(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) & RelativeInjectorLocationFlags.InjectorIndexMask;\n}\n\nexport function getParentInjectorViewOffset(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) >> RelativeInjectorLocationFlags.ViewOffsetShift;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nexport function getParentInjectorView(location: RelativeInjectorLocation, startView: LView): LView {\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView;\n  // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    viewOffset--;\n  }\n  return parentView;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from '../../util/global';\nimport {RElement} from '../interfaces/renderer';\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n */\nexport function renderStringify(value: any): string {\n  if (typeof value === 'string') return value;\n  if (value == null) return '';\n  return '' + value;\n}\n\n\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nexport function stringifyForError(value: any): string {\n  if (typeof value === 'function') return value.name || value.toString();\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n\n  return renderStringify(value);\n}\n\n\nexport const defaultScheduler =\n    (() =>\n         (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame ||  // browser only\n          setTimeout  // everything else\n          ).bind(global))();\n\n/**\n *\n * @codeGenApi\n */\nexport function ÉµÉµresolveWindow(element: RElement & {ownerDocument: Document}) {\n  return {name: 'window', target: element.ownerDocument.defaultView};\n}\n\n/**\n *\n * @codeGenApi\n */\nexport function ÉµÉµresolveDocument(element: RElement & {ownerDocument: Document}) {\n  return {name: 'document', target: element.ownerDocument};\n}\n\n/**\n *\n * @codeGenApi\n */\nexport function ÉµÉµresolveBody(element: RElement & {ownerDocument: Document}) {\n  return {name: 'body', target: element.ownerDocument.body};\n}\n\n/**\n * The special delimiter we use to separate property names, prefixes, and suffixes\n * in property binding metadata. See storeBindingMetadata().\n *\n * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\n * because it is a very uncommon character that is unlikely to be part of a user's\n * property names or interpolation strings. If it is in fact used in a property\n * binding, DebugElement.properties will not return the correct value for that\n * binding. However, there should be no runtime effect for real applications.\n *\n * This character is typically rendered as a question mark inside of a diamond.\n * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\n *\n */\nexport const INTERPOLATION_DELIMITER = `ï¿½`;\n\n/**\n * Unwrap a value which might be behind a closure (for forward declaration reasons).\n */\nexport function maybeUnwrapFn<T>(value: T | (() => T)): T {\n  if (value instanceof Function) {\n    return value();\n  } else {\n    return value;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from '../util/assert';\n\n\nexport const enum BypassType {\n  Url = 'URL',\n  Html = 'HTML',\n  ResourceUrl = 'ResourceURL',\n  Script = 'Script',\n  Style = 'Style',\n}\n\n/**\n * Marker interface for a value that's safe to use in a particular context.\n *\n * @publicApi\n */\nexport interface SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as HTML.\n *\n * @publicApi\n */\nexport interface SafeHtml extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as style (CSS).\n *\n * @publicApi\n */\nexport interface SafeStyle extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as JavaScript.\n *\n * @publicApi\n */\nexport interface SafeScript extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL linking to a document.\n *\n * @publicApi\n */\nexport interface SafeUrl extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL to load executable code from.\n *\n * @publicApi\n */\nexport interface SafeResourceUrl extends SafeValue {}\n\n\nabstract class SafeValueImpl implements SafeValue {\n  constructor(public changingThisBreaksApplicationSecurity: string) {}\n\n  abstract getTypeName(): string;\n\n  toString() {\n    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` +\n        ` (see http://g.co/ng/security#xss)`;\n  }\n}\n\nclass SafeHtmlImpl extends SafeValueImpl implements SafeHtml {\n  getTypeName() { return BypassType.Html; }\n}\nclass SafeStyleImpl extends SafeValueImpl implements SafeStyle {\n  getTypeName() { return BypassType.Style; }\n}\nclass SafeScriptImpl extends SafeValueImpl implements SafeScript {\n  getTypeName() { return BypassType.Script; }\n}\nclass SafeUrlImpl extends SafeValueImpl implements SafeUrl {\n  getTypeName() { return BypassType.Url; }\n}\nclass SafeResourceUrlImpl extends SafeValueImpl implements SafeResourceUrl {\n  getTypeName() { return BypassType.ResourceUrl; }\n}\n\nexport function unwrapSafeValue(value: SafeValue): string;\nexport function unwrapSafeValue<T>(value: T): T;\nexport function unwrapSafeValue<T>(value: T | SafeValue): T {\n  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity as any as T :\n                                          value as any as T;\n}\n\n\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Html): value is SafeHtml;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.ResourceUrl): value is SafeResourceUrl;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Script): value is SafeScript;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Style): value is SafeStyle;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType.Url): value is SafeUrl;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType): boolean;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType): boolean {\n  const actualType = getSanitizationBypassType(value);\n  if (actualType != null && actualType !== type) {\n    // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n    if (actualType === BypassType.ResourceUrl && type === BypassType.Url) return true;\n    throw new Error(\n        `Required a safe ${type}, got a ${actualType} (see http://g.co/ng/security#xss)`);\n  }\n  return actualType === type;\n}\n\nexport function getSanitizationBypassType(value: any): BypassType|null {\n  return value instanceof SafeValueImpl && value.getTypeName() as BypassType || null;\n}\n\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustHtml(trustedHtml: string): SafeHtml {\n  return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustStyle(trustedStyle: string): SafeStyle {\n  return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustScript(trustedScript: string): SafeScript {\n  return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustUrl(trustedUrl: string): SafeUrl {\n  return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustResourceUrl(trustedResourceUrl: string): SafeResourceUrl {\n  return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  brand: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE = {} as NO_CHANGE;\n","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\nimport {unwrapSafeValue} from '../../sanitization/bypass';\nimport {PropertyAliases, TNodeFlags} from '../interfaces/node';\nimport {LStylingData, StylingMapArray, StylingMapArrayIndex, TStylingContext, TStylingContextIndex, TStylingContextPropConfigFlags, TStylingNode} from '../interfaces/styling';\nimport {NO_CHANGE} from '../tokens';\n\nexport const MAP_BASED_ENTRY_PROP_NAME = '[MAP]';\nexport const TEMPLATE_DIRECTIVE_INDEX = 0;\n\n/**\n * Default fallback value for a styling binding.\n *\n * A value of `null` is used here which signals to the styling algorithm that\n * the styling value is not present. This way if there are no other values\n * detected then it will be removed once the style/class property is dirty and\n * diffed within the styling algorithm present in `flushStyling`.\n */\nexport const DEFAULT_BINDING_VALUE = null;\n\nexport const DEFAULT_BINDING_INDEX = 0;\n\nconst DEFAULT_TOTAL_SOURCES = 1;\n\n// The first bit value reflects a map-based binding value's bit.\n// The reason why it's always activated for every entry in the map\n// is so that if any map-binding values update then all other prop\n// based bindings will pass the guard check automatically without\n// any extra code or flags.\nexport const DEFAULT_GUARD_MASK_VALUE = 0b1;\n\n/**\n * Creates a new instance of the `TStylingContext`.\n *\n * The `TStylingContext` is used as a manifest of all style or all class bindings on\n * an element. Because it is a T-level data-structure, it is only created once per\n * tNode for styles and for classes. This function allocates a new instance of a\n * `TStylingContext` with the initial values (see `interfaces.ts` for more info).\n */\nexport function allocTStylingContext(\n    initialStyling: StylingMapArray | null, hasDirectives: boolean): TStylingContext {\n  initialStyling = initialStyling || allocStylingMapArray(null);\n  return [\n    DEFAULT_TOTAL_SOURCES,  // 1) total amount of styling sources (template, directives, etc...)\n    initialStyling,         // 2) initial styling values\n  ];\n}\n\nexport function allocStylingMapArray(value: {} | string | null): StylingMapArray {\n  return [value];\n}\n\nexport function hasConfig(tNode: TStylingNode, flag: TNodeFlags) {\n  return (tNode.flags & flag) !== 0;\n}\n\n/**\n * Determines whether or not to apply styles/classes directly or via context resolution.\n *\n * There are three cases that are matched here:\n * 1. there are no directives present AND `ngDevMode` is falsy\n * 2. the `firstUpdatePass` has not already run (which means that\n *    there are more bindings to register and, therefore, direct\n *    style/class application is not yet possible)\n * 3. There are no collisions (i.e. properties with more than one binding) across multiple\n *    sources (i.e. template + directive, directive + directive, directive + component)\n */\nexport function allowDirectStyling(\n    tNode: TStylingNode, isClassBased: boolean, firstUpdatePass: boolean): boolean {\n  let allow = false;\n\n  // if no directives are present then we do not need populate a context at all. This\n  // is because duplicate prop bindings cannot be registered through the template. If\n  // and when this happens we can safely apply the value directly without context\n  // resolution...\n  const hasDirectives = hasConfig(tNode, TNodeFlags.hasHostBindings);\n  if (!hasDirectives) {\n    // `ngDevMode` is required to be checked here because tests/debugging rely on the context being\n    // populated. If things are in production mode then there is no need to build a context\n    // therefore the direct apply can be allowed (even on the first update).\n    allow = ngDevMode ? !firstUpdatePass : true;\n  } else if (!firstUpdatePass) {\n    const duplicateStylingFlag =\n        isClassBased ? TNodeFlags.hasDuplicateClassBindings : TNodeFlags.hasDuplicateStyleBindings;\n    const hasDuplicates = hasConfig(tNode, duplicateStylingFlag);\n    const hasOnlyMapOrPropsFlag = isClassBased ? TNodeFlags.hasClassPropAndMapBindings :\n                                                 TNodeFlags.hasStylePropAndMapBindings;\n    const hasOnlyMapsOrOnlyProps = (tNode.flags & hasOnlyMapOrPropsFlag) !== hasOnlyMapOrPropsFlag;\n    allow = !hasDuplicates && hasOnlyMapsOrOnlyProps;\n  }\n\n  return allow;\n}\n\nexport function patchConfig(tNode: TStylingNode, flag: TNodeFlags): void {\n  tNode.flags |= flag;\n}\n\nexport function getProp(context: TStylingContext, index: number): string {\n  return context[index + TStylingContextIndex.PropOffset] as string;\n}\n\nfunction getPropConfig(context: TStylingContext, index: number): number {\n  return (context[index + TStylingContextIndex.ConfigOffset] as number) &\n      TStylingContextPropConfigFlags.Mask;\n}\n\nexport function isSanitizationRequired(context: TStylingContext, index: number): boolean {\n  return (getPropConfig(context, index) & TStylingContextPropConfigFlags.SanitizationRequired) !==\n      0;\n}\n\nexport function getGuardMask(\n    context: TStylingContext, index: number, isHostBinding: boolean): number {\n  const position = index + (isHostBinding ? TStylingContextIndex.HostBindingsBitGuardOffset :\n                                            TStylingContextIndex.TemplateBitGuardOffset);\n  return context[position] as number;\n}\n\nexport function setGuardMask(\n    context: TStylingContext, index: number, maskValue: number, isHostBinding: boolean) {\n  const position = index + (isHostBinding ? TStylingContextIndex.HostBindingsBitGuardOffset :\n                                            TStylingContextIndex.TemplateBitGuardOffset);\n  context[position] = maskValue;\n}\n\nexport function getValuesCount(context: TStylingContext): number {\n  return getTotalSources(context) + 1;\n}\n\nexport function getTotalSources(context: TStylingContext): number {\n  return context[TStylingContextIndex.TotalSourcesPosition];\n}\n\nexport function getBindingValue(context: TStylingContext, index: number, offset: number) {\n  return context[index + TStylingContextIndex.BindingsStartOffset + offset] as number | string;\n}\n\nexport function getDefaultValue(context: TStylingContext, index: number): string|boolean|null {\n  return context[index + TStylingContextIndex.BindingsStartOffset + getTotalSources(context)] as\n             string |\n      boolean | null;\n}\n\nexport function setDefaultValue(\n    context: TStylingContext, index: number, value: string | boolean | null) {\n  return context[index + TStylingContextIndex.BindingsStartOffset + getTotalSources(context)] =\n             value;\n}\n\nexport function setValue(data: LStylingData, bindingIndex: number, value: any) {\n  data[bindingIndex] = value;\n}\n\nexport function getValue<T = any>(data: LStylingData, bindingIndex: number): T|null {\n  return bindingIndex !== 0 ? data[bindingIndex] as T : null;\n}\n\nexport function getPropValuesStartPosition(\n    context: TStylingContext, tNode: TStylingNode, isClassBased: boolean) {\n  let startPosition = TStylingContextIndex.ValuesStartPosition;\n  const flag = isClassBased ? TNodeFlags.hasClassMapBindings : TNodeFlags.hasStyleMapBindings;\n  if (hasConfig(tNode, flag)) {\n    startPosition += TStylingContextIndex.BindingsStartOffset + getValuesCount(context);\n  }\n  return startPosition;\n}\n\nexport function hasValueChangedUnwrapSafeValue(\n    a: NO_CHANGE | StylingMapArray | number | String | string | null | boolean | undefined | {},\n    b: NO_CHANGE | StylingMapArray | number | String | string | null | boolean | undefined |\n        {}): boolean {\n  return hasValueChanged(unwrapSafeValue(a), unwrapSafeValue(b));\n}\n\n\nexport function hasValueChanged(\n    a: NO_CHANGE | StylingMapArray | number | string | null | boolean | undefined | {},\n    b: NO_CHANGE | StylingMapArray | number | string | null | boolean | undefined | {}): boolean {\n  if (b === NO_CHANGE) return false;\n\n  const compareValueA = Array.isArray(a) ? a[StylingMapArrayIndex.RawValuePosition] : a;\n  const compareValueB = Array.isArray(b) ? b[StylingMapArrayIndex.RawValuePosition] : b;\n  return !Object.is(compareValueA, compareValueB);\n}\n\n/**\n * Determines whether the provided styling value is truthy or falsy.\n */\nexport function isStylingValueDefined<T extends string|number|{}|null|undefined>(value: T):\n    value is NonNullable<T> {\n  // the reason why null is compared against is because\n  // a CSS class value that is set to `false` must be\n  // respected (otherwise it would be treated as falsy).\n  // Empty string values are because developers usually\n  // set a value to an empty string to remove it.\n  return value != null && value !== '';\n}\n\nexport function concatString(a: string, b: string, separator = ' '): string {\n  return a + ((b.length && a.length) ? separator : '') + b;\n}\n\nexport function hyphenate(value: string): string {\n  return value.replace(/[a-z][A-Z]/g, v => v.charAt(0) + '-' + v.charAt(1)).toLowerCase();\n}\n\n/**\n * Returns an instance of `StylingMapArray`.\n *\n * This function is designed to find an instance of `StylingMapArray` in case it is stored\n * inside of an instance of `TStylingContext`. When a styling context is created it\n * will copy over an initial styling values from the tNode (which are stored as a\n * `StylingMapArray` on the `tNode.classes` or `tNode.styles` values).\n */\nexport function getStylingMapArray(value: TStylingContext | StylingMapArray | null):\n    StylingMapArray|null {\n  return isStylingContext(value) ?\n      (value as TStylingContext)[TStylingContextIndex.InitialStylingValuePosition] :\n      value as StylingMapArray;\n}\n\nexport function isStylingContext(value: any): boolean {\n  // the StylingMapArray is in the format of [initial, prop, string, prop, string]\n  // and this is the defining value to distinguish between arrays\n  return Array.isArray(value) && value.length >= TStylingContextIndex.ValuesStartPosition &&\n      typeof value[1] !== 'string';\n}\n\nexport function isStylingMapArray(value: any): boolean {\n  // the StylingMapArray is in the format of [initial, prop, string, prop, string]\n  // and this is the defining value to distinguish between arrays\n  return Array.isArray(value) &&\n      (typeof(value as StylingMapArray)[StylingMapArrayIndex.ValuesStartPosition] === 'string');\n}\n\nexport function getInitialStylingValue(context: TStylingContext | StylingMapArray | null): string {\n  const map = getStylingMapArray(context);\n  return map && (map[StylingMapArrayIndex.RawValuePosition] as string | null) || '';\n}\n\nexport function hasClassInput(tNode: TStylingNode) {\n  return (tNode.flags & TNodeFlags.hasClassInput) !== 0;\n}\n\nexport function hasStyleInput(tNode: TStylingNode) {\n  return (tNode.flags & TNodeFlags.hasStyleInput) !== 0;\n}\n\nexport function getMapProp(map: StylingMapArray, index: number): string {\n  return map[index + StylingMapArrayIndex.PropOffset] as string;\n}\n\nconst MAP_DIRTY_VALUE =\n    typeof ngDevMode !== 'undefined' && ngDevMode ? {} : {MAP_DIRTY_VALUE: true};\n\nexport function setMapAsDirty(map: StylingMapArray): void {\n  map[StylingMapArrayIndex.RawValuePosition] = MAP_DIRTY_VALUE;\n}\n\nexport function setMapValue(\n    map: StylingMapArray, index: number, value: string | boolean | null): void {\n  map[index + StylingMapArrayIndex.ValueOffset] = value;\n}\n\nexport function getMapValue(map: StylingMapArray, index: number): string|null {\n  return map[index + StylingMapArrayIndex.ValueOffset] as string | null;\n}\n\nexport function forceClassesAsString(classes: string | {[key: string]: any} | null | undefined):\n    string {\n  if (classes && typeof classes !== 'string') {\n    classes = Object.keys(classes).join(' ');\n  }\n  return (classes as string) || '';\n}\n\nexport function forceStylesAsString(\n    styles: {[key: string]: any} | string | null | undefined, hyphenateProps: boolean): string {\n  if (typeof styles == 'string') return styles;\n  let str = '';\n  if (styles) {\n    const props = Object.keys(styles);\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i];\n      const propLabel = hyphenateProps ? hyphenate(prop) : prop;\n      const value = styles[prop];\n      if (value !== null) {\n        str = concatString(str, `${propLabel}:${value}`, ';');\n      }\n    }\n  }\n  return str;\n}\n\nexport function isHostStylingActive(directiveOrSourceId: number): boolean {\n  return directiveOrSourceId !== TEMPLATE_DIRECTIVE_INDEX;\n}\n\n/**\n * Converts the provided styling map array into a string.\n *\n * Classes => `one two three`\n * Styles => `prop:value; prop2:value2`\n */\nexport function stylingMapToString(map: StylingMapArray, isClassBased: boolean): string {\n  let str = '';\n  for (let i = StylingMapArrayIndex.ValuesStartPosition; i < map.length;\n       i += StylingMapArrayIndex.TupleSize) {\n    const prop = getMapProp(map, i);\n    const value = getMapValue(map, i) as string;\n    const attrValue = concatString(prop, isClassBased ? '' : value, ':');\n    str = concatString(str, attrValue, isClassBased ? ' ' : '; ');\n  }\n  return str;\n}\n\n/**\n * Converts the provided styling map array into a key value map.\n */\nexport function stylingMapToStringMap(map: StylingMapArray | null): {[key: string]: any} {\n  let stringMap: {[key: string]: any} = {};\n  if (map) {\n    for (let i = StylingMapArrayIndex.ValuesStartPosition; i < map.length;\n         i += StylingMapArrayIndex.TupleSize) {\n      const prop = getMapProp(map, i);\n      const value = getMapValue(map, i) as string;\n      stringMap[prop] = value;\n    }\n  }\n  return stringMap;\n}\n\n/**\n * Inserts the provided item into the provided styling array at the right spot.\n *\n * The `StylingMapArray` type is a sorted key/value array of entries. This means\n * that when a new entry is inserted it must be placed at the right spot in the\n * array. This function figures out exactly where to place it.\n */\nexport function addItemToStylingMap(\n    stylingMapArr: StylingMapArray, prop: string, value: string | boolean | null,\n    allowOverwrite?: boolean) {\n  for (let j = StylingMapArrayIndex.ValuesStartPosition; j < stylingMapArr.length;\n       j += StylingMapArrayIndex.TupleSize) {\n    const propAtIndex = getMapProp(stylingMapArr, j);\n    if (prop <= propAtIndex) {\n      let applied = false;\n      if (propAtIndex === prop) {\n        const valueAtIndex = stylingMapArr[j];\n        if (allowOverwrite || !isStylingValueDefined(valueAtIndex)) {\n          applied = true;\n          setMapValue(stylingMapArr, j, value);\n        }\n      } else {\n        applied = true;\n        stylingMapArr.splice(j, 0, prop, value);\n      }\n      return applied;\n    }\n  }\n\n  stylingMapArr.push(prop, value);\n  return true;\n}\n\n/**\n * Used to convert a {key:value} map into a `StylingMapArray` array.\n *\n * This function will either generate a new `StylingMapArray` instance\n * or it will patch the provided `newValues` map value into an\n * existing `StylingMapArray` value (this only happens if `bindingValue`\n * is an instance of `StylingMapArray`).\n *\n * If a new key/value map is provided with an old `StylingMapArray`\n * value then all properties will be overwritten with their new\n * values or with `null`. This means that the array will never\n * shrink in size (but it will also not be created and thrown\n * away whenever the `{key:value}` map entries change).\n */\nexport function normalizeIntoStylingMap(\n    bindingValue: null | StylingMapArray,\n    newValues: {[key: string]: any} | string | null | undefined,\n    normalizeProps?: boolean): StylingMapArray {\n  const stylingMapArr: StylingMapArray =\n      Array.isArray(bindingValue) ? bindingValue : allocStylingMapArray(null);\n  stylingMapArr[StylingMapArrayIndex.RawValuePosition] = newValues;\n\n  // because the new values may not include all the properties\n  // that the old ones had, all values are set to `null` before\n  // the new values are applied. This way, when flushed, the\n  // styling algorithm knows exactly what style/class values\n  // to remove from the element (since they are `null`).\n  for (let j = StylingMapArrayIndex.ValuesStartPosition; j < stylingMapArr.length;\n       j += StylingMapArrayIndex.TupleSize) {\n    setMapValue(stylingMapArr, j, null);\n  }\n\n  let props: string[]|null = null;\n  let map: {[key: string]: any}|undefined|null;\n  let allValuesTrue = false;\n  if (typeof newValues === 'string') {  // [class] bindings allow string values\n    props = splitOnWhitespace(newValues);\n    allValuesTrue = props !== null;\n  } else {\n    props = newValues ? Object.keys(newValues) : null;\n    map = newValues;\n  }\n\n  if (props) {\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i];\n      const newProp = normalizeProps ? hyphenate(prop) : prop;\n      const value = allValuesTrue ? true : map ![prop];\n      addItemToStylingMap(stylingMapArr, newProp, value, true);\n    }\n  }\n\n  return stylingMapArr;\n}\n\nexport function splitOnWhitespace(text: string): string[]|null {\n  let array: string[]|null = null;\n  let length = text.length;\n  let start = 0;\n  let foundChar = false;\n  for (let i = 0; i < length; i++) {\n    const char = text.charCodeAt(i);\n    if (char <= 32 /*' '*/) {\n      if (foundChar) {\n        if (array === null) array = [];\n        array.push(text.substring(start, i));\n        foundChar = false;\n      }\n      start = i + 1;\n    } else {\n      foundChar = true;\n    }\n  }\n  if (foundChar) {\n    if (array === null) array = [];\n    array.push(text.substring(start, length));\n    foundChar = false;\n  }\n  return array;\n}\n\n// TODO (matsko|AndrewKushnir): refactor this once we figure out how to generate separate\n// `input('class') + classMap()` instructions.\nexport function selectClassBasedInputName(inputs: PropertyAliases): string {\n  return inputs.hasOwnProperty('class') ? 'class' : 'className';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isForwardRef, resolveForwardRef} from '../di/forward_ref';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {injectRootLimpMode, setInjectImplementation} from '../di/injector_compatibility';\nimport {getInjectorDef} from '../di/interface/defs';\nimport {InjectFlags} from '../di/interface/injector';\nimport {Type} from '../interface/type';\nimport {assertDefined, assertEqual} from '../util/assert';\n\nimport {assertDirectiveDef} from './assert';\nimport {getFactoryDef} from './definition';\nimport {NG_ELEMENT_ID, NG_FACTORY_DEF} from './fields';\nimport {registerPreOrderHooks} from './hooks';\nimport {DirectiveDef, FactoryFn} from './interfaces/definition';\nimport {NO_PARENT_INJECTOR, NodeInjectorFactory, PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags, TNODE, isFactory} from './interfaces/injector';\nimport {AttributeMarker, TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TNode, TNodeProviderIndexes, TNodeType} from './interfaces/node';\nimport {isComponentDef, isComponentHost} from './interfaces/type_checks';\nimport {DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, INJECTOR, LView, TData, TVIEW, TView, T_HOST} from './interfaces/view';\nimport {assertNodeOfPossibleTypes} from './node_assert';\nimport {enterDI, leaveDI} from './state';\nimport {isNameOnlyAttributeMarker} from './util/attrs_utils';\nimport {getParentInjectorIndex, getParentInjectorView, hasParentInjector} from './util/injector_utils';\nimport {stringifyForError} from './util/misc_utils';\nimport {getInitialStylingValue} from './util/styling_utils';\n\n\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\n\nfunction setIncludeViewProviders(v: boolean): boolean {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nexport function bloomAdd(\n    injectorIndex: number, tView: TView, type: Type<any>| InjectionToken<any>| string): void {\n  ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n  let id: number|undefined =\n      typeof type !== 'string' ? (type as any)[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomBit = id & BLOOM_MASK;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Use the raw bloomBit number to determine which bloom filter bucket we should check\n  // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n  const b7 = bloomBit & 0x80;\n  const b6 = bloomBit & 0x40;\n  const b5 = bloomBit & 0x20;\n  const tData = tView.data as number[];\n\n  if (b7) {\n    b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :\n         (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));\n  } else {\n    b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :\n         (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));\n  }\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param hostView View where the node is stored\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(\n    tNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LView): number {\n  const existingInjectorIndex = getInjectorIndex(tNode, hostView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n\n  const tView = hostView[TVIEW];\n  if (tView.firstCreatePass) {\n    tNode.injectorIndex = hostView.length;\n    insertBloom(tView.data, tNode);  // foundation for node bloom\n    insertBloom(hostView, null);     // foundation for cumulative bloom\n    insertBloom(tView.blueprint, null);\n  }\n\n  const parentLoc = getParentInjectorLocation(tNode, hostView);\n  const injectorIndex = tNode.injectorIndex;\n\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (hasParentInjector(parentLoc)) {\n    const parentIndex = getParentInjectorIndex(parentLoc);\n    const parentLView = getParentInjectorView(parentLoc, hostView);\n    const parentData = parentLView[TVIEW].data as any;\n    // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n    for (let i = 0; i < 8; i++) {\n      hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n\n  hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;\n  return injectorIndex;\n}\n\nfunction insertBloom(arr: any[], footer: TNode | null): void {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\n\n\nexport function getInjectorIndex(tNode: TNode, hostView: LView): number {\n  if (tNode.injectorIndex === -1 ||\n      // If the injector index is the same as its parent's injector index, then the index has been\n      // copied down from the parent node. No injector has been created yet on this node.\n      (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n      // After the first template pass, the injector index might exist but the parent values\n      // might not have been calculated yet for this instance\n      hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {\n    return -1;\n  } else {\n    return tNode.injectorIndex;\n  }\n}\n\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`\n */\nexport function getParentInjectorLocation(tNode: TNode, view: LView): RelativeInjectorLocation {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    return tNode.parent.injectorIndex as any;  // ViewOffset is 0\n  }\n\n  // For most cases, the parent injector index can be found on the host node (e.g. for component\n  // or container), so this loop will be skipped, but we must keep the loop here to support\n  // the rarer case of deeply nested <ng-template> tags or inline views.\n  let hostTNode = view[T_HOST];\n  let viewOffset = 1;\n  while (hostTNode && hostTNode.injectorIndex === -1) {\n    view = view[DECLARATION_VIEW] !;\n    hostTNode = view ? view[T_HOST] : null;\n    viewOffset++;\n  }\n\n  return hostTNode ?\n      hostTNode.injectorIndex | (viewOffset << RelativeInjectorLocationFlags.ViewOffsetShift) :\n      -1 as any;\n}\n\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nexport function diPublicInInjector(\n    injectorIndex: number, tView: TView, token: InjectionToken<any>| Type<any>): void {\n  bloomAdd(injectorIndex, tView, token);\n}\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.Éµcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nexport function injectAttributeImpl(tNode: TNode, attrNameToInject: string): string|null {\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  if (attrNameToInject === 'class') {\n    return getInitialStylingValue(tNode.classes);\n  }\n  if (attrNameToInject === 'style') {\n    return getInitialStylingValue(tNode.styles);\n  }\n\n  const attrs = tNode.attrs;\n  if (attrs) {\n    const attrsLength = attrs.length;\n    let i = 0;\n    while (i < attrsLength) {\n      const value = attrs[i];\n\n      // If we hit a `Bindings` or `Template` marker then we are done.\n      if (isNameOnlyAttributeMarker(value)) break;\n\n      // Skip namespaced attributes\n      if (value === AttributeMarker.NamespaceURI) {\n        // we skip the next two values\n        // as namespaced attributes looks like\n        // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n        // 'existValue', ...]\n        i = i + 2;\n      } else if (typeof value === 'number') {\n        // Skip to the first value of the marked attribute.\n        i++;\n        while (i < attrsLength && typeof attrs[i] === 'string') {\n          i++;\n        }\n      } else if (value === attrNameToInject) {\n        return attrs[i + 1] as string;\n      } else {\n        i = i + 2;\n      }\n    }\n  }\n  return null;\n}\n\n\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. Negative values are reserved for special objects.\n *   - `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nexport function getOrCreateInjectable<T>(\n    tNode: TDirectiveHostNode | null, lView: LView, token: Type<T>| InjectionToken<T>,\n    flags: InjectFlags = InjectFlags.Default, notFoundValue?: any): T|null {\n  if (tNode !== null) {\n    const bloomHash = bloomHashBitOrFactory(token);\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n    // so just call the factory function to create it.\n    if (typeof bloomHash === 'function') {\n      enterDI(lView, tNode);\n      try {\n        const value = bloomHash();\n        if (value == null && !(flags & InjectFlags.Optional)) {\n          throw new Error(`No provider for ${stringifyForError(token)}!`);\n        } else {\n          return value;\n        }\n      } finally {\n        leaveDI();\n      }\n    } else if (typeof bloomHash == 'number') {\n      if (bloomHash === -1) {\n        // `-1` is a special value used to identify `Injector` types.\n        return new NodeInjector(tNode, lView) as any;\n      }\n      // If the token has a bloom hash, then it is a token which could be in NodeInjector.\n\n      // A reference to the previous injector TView that was found while climbing the element\n      // injector tree. This is used to know if viewProviders can be accessed on the current\n      // injector.\n      let previousTView: TView|null = null;\n      let injectorIndex = getInjectorIndex(tNode, lView);\n      let parentLocation: RelativeInjectorLocation = NO_PARENT_INJECTOR;\n      let hostTElementNode: TNode|null =\n          flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n\n      // If we should skip this injector, or if there is no injector on this node, start by\n      // searching\n      // the parent injector.\n      if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n        parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\n                                                lView[injectorIndex + PARENT_INJECTOR];\n\n        if (!shouldSearchParent(flags, false)) {\n          injectorIndex = -1;\n        } else {\n          previousTView = lView[TVIEW];\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        }\n      }\n\n      // Traverse up the injector tree until we find a potential match or until we know there\n      // *isn't* a match.\n      while (injectorIndex !== -1) {\n        parentLocation = lView[injectorIndex + PARENT_INJECTOR];\n\n        // Check the current injector. If it matches, see if it contains token.\n        const tView = lView[TVIEW];\n        if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n          // At this point, we have an injector which *may* contain the token, so we step through\n          // the providers and directives associated with the injector's corresponding node to get\n          // the instance.\n          const instance: T|null = searchTokensOnInjector<T>(\n              injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n          if (instance !== NOT_FOUND) {\n            return instance;\n          }\n        }\n        if (shouldSearchParent(\n                flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) &&\n            bloomHasToken(bloomHash, injectorIndex, lView)) {\n          // The def wasn't found anywhere on this node, so it was a false positive.\n          // Traverse up the tree and continue searching.\n          previousTView = tView;\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        } else {\n          // If we should not search parent OR If the ancestor bloom filter value does not have the\n          // bit corresponding to the directive we can give up on traversing up to find the specific\n          // injector.\n          injectorIndex = -1;\n        }\n      }\n    }\n  }\n\n  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR];\n    // switch to `injectInjectorOnly` implementation for module injector, since module injector\n    // should not have access to Component/Directive DI scope (that may happen through\n    // `directiveInject` implementation)\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      if (moduleInjector) {\n        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n      } else {\n        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n  if (flags & InjectFlags.Optional) {\n    return notFoundValue;\n  } else {\n    throw new Error(`NodeInjector: NOT_FOUND [${stringifyForError(token)}]`);\n  }\n}\n\nconst NOT_FOUND = {};\n\nfunction searchTokensOnInjector<T>(\n    injectorIndex: number, lView: LView, token: Type<T>| InjectionToken<T>,\n    previousTView: TView | null, flags: InjectFlags, hostTElementNode: TNode | null) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + TNODE] as TNode;\n  // First, we need to determine if view providers can be accessed by the starting element.\n  // There are two possibities\n  const canAccessViewProviders = previousTView == null ?\n      // 1) This is the first invocation `previousTView == null` which means that we are at the\n      // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n      // to look into the ViewProviders is if:\n      // - we are on a component\n      // - AND the injector set `includeViewProviders` to true (implying that the token can see\n      // ViewProviders because it is the Component or a Service which itself was declared in\n      // ViewProviders)\n      (isComponentHost(tNode) && includeViewProviders) :\n      // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n      // In such a case we are only allowed to look into the ViewProviders if:\n      // - We just crossed from child View to Parent View `previousTView != currentTView`\n      // - AND the parent TNode is an Element.\n      // This means that we just came from the Component's View and therefore are allowed to see\n      // into the ViewProviders.\n      (previousTView != currentTView && (tNode.type === TNodeType.Element));\n\n  // This special case happens when there is a @host on the inject and when we are searching\n  // on the host element node.\n  const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;\n\n  const injectableIdx = locateDirectiveOrProvider(\n      tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n  if (injectableIdx !== null) {\n    return getNodeInjectable(lView, currentTView, injectableIdx, tNode as TElementNode);\n  } else {\n    return NOT_FOUND;\n  }\n}\n\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nexport function locateDirectiveOrProvider<T>(\n    tNode: TNode, tView: TView, token: Type<T>| InjectionToken<T>, canAccessViewProviders: boolean,\n    isHostSpecialCase: boolean | number): number|null {\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n\n  const injectablesStart = nodeProviderIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount =\n      nodeProviderIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n  const startingIndex =\n      canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n  // When the host special case applies, only the viewProviders and the component are visible\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef = tInjectables[i] as InjectionToken<any>| Type<any>| DirectiveDef<any>;\n    if (i < directivesStart && token === providerTokenOrDef ||\n        i >= directivesStart && (providerTokenOrDef as DirectiveDef<any>).type === token) {\n      return i;\n    }\n  }\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart] as DirectiveDef<any>;\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n  return null;\n}\n\n/**\n* Retrieve or instantiate the injectable from the `LView` at particular `index`.\n*\n* This function checks to see if the value has already been instantiated and if so returns the\n* cached `injectable`. Otherwise if it detects that the value is still a factory it\n* instantiates the `injectable` and caches the value.\n*/\nexport function getNodeInjectable(\n    lView: LView, tView: TView, index: number, tNode: TDirectiveHostNode): any {\n  let value = lView[index];\n  const tData = tView.data;\n  if (isFactory(value)) {\n    const factory: NodeInjectorFactory = value;\n    if (factory.resolving) {\n      throw new Error(`Circular dep for ${stringifyForError(tData[index])}`);\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    let previousInjectImplementation;\n    if (factory.injectImpl) {\n      previousInjectImplementation = setInjectImplementation(factory.injectImpl);\n    }\n    enterDI(lView, tNode);\n    try {\n      value = lView[index] = factory.factory(undefined, tData, lView, tNode);\n      // This code path is hit for both directives and providers.\n      // For perf reasons, we want to avoid searching for hooks on providers.\n      // It does no harm to try (the hooks just won't exist), but the extra\n      // checks are unnecessary and this is a hot path. So we check to see\n      // if the index of the dependency is in the directive range for this\n      // tNode. If it's not, we know it's a provider and skip hook registration.\n      if (tView.firstCreatePass && index >= tNode.directiveStart) {\n        ngDevMode && assertDirectiveDef(tData[index]);\n        registerPreOrderHooks(index, tData[index] as DirectiveDef<any>, tView);\n      }\n    } finally {\n      if (factory.injectImpl) setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      leaveDI();\n    }\n  }\n  return value;\n}\n\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nexport function bloomHashBitOrFactory(token: Type<any>| InjectionToken<any>| string): number|\n    Function|undefined {\n  ngDevMode && assertDefined(token, 'token must be defined');\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId: number|undefined = (token as any)[NG_ELEMENT_ID];\n  // Negative token IDs are used for special objects such as `Injector`\n  return (typeof tokenId === 'number' && tokenId > 0) ? tokenId & BLOOM_MASK : tokenId;\n}\n\nexport function bloomHasToken(\n    bloomHash: number, injectorIndex: number, injectorView: LView | TData) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  const b7 = bloomHash & 0x80;\n  const b6 = bloomHash & 0x40;\n  const b5 = bloomHash & 0x20;\n\n  // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n  // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n  // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n  let value: number;\n\n  if (b7) {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :\n                 (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);\n  } else {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :\n                 (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);\n  }\n\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags: InjectFlags, isFirstHostTNode: boolean): boolean|number {\n  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\n\nexport class NodeInjector implements Injector {\n  constructor(\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode|null,\n      private _lView: LView) {}\n\n  get(token: any, notFoundValue?: any): any {\n    return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);\n  }\n}\n\n/**\n * @codeGenApi\n */\nexport function ÉµÉµgetFactoryOf<T>(type: Type<any>): FactoryFn<T>|null {\n  const typeAny = type as any;\n\n  if (isForwardRef(type)) {\n    return (() => {\n      const factory = ÉµÉµgetFactoryOf<T>(resolveForwardRef(typeAny));\n      return factory ? factory() : null;\n    }) as any;\n  }\n\n  let factory = getFactoryDef<T>(typeAny);\n  if (factory === null) {\n    const injectorDef = getInjectorDef<T>(typeAny);\n    factory = injectorDef && injectorDef.factory;\n  }\n  return factory || null;\n}\n\n/**\n * @codeGenApi\n */\nexport function ÉµÉµgetInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T {\n  const proto = Object.getPrototypeOf(type.prototype).constructor as Type<any>;\n  const factory = (proto as any)[NG_FACTORY_DEF] || ÉµÉµgetFactoryOf<T>(proto);\n  if (factory !== null) {\n    return factory;\n  } else {\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return (t) => new t();\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const ERROR_TYPE = 'ngType';\nexport const ERROR_DEBUG_CONTEXT = 'ngDebugContext';\nexport const ERROR_ORIGINAL_ERROR = 'ngOriginalError';\nexport const ERROR_LOGGER = 'ngErrorLogger';\n\n\nexport function wrappedError(message: string, originalError: any): Error {\n  const msg =\n      `${message} caused by: ${originalError instanceof Error ? originalError.message: originalError }`;\n  const error = Error(msg);\n  (error as any)[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ERROR_DEBUG_CONTEXT, ERROR_LOGGER, ERROR_ORIGINAL_ERROR, ERROR_TYPE} from './util/errors';\nimport {DebugContext} from './view';\n\nexport function getType(error: Error): Function {\n  return (error as any)[ERROR_TYPE];\n}\n\nexport function getDebugContext(error: Error): DebugContext {\n  return (error as any)[ERROR_DEBUG_CONTEXT];\n}\n\nexport function getOriginalError(error: Error): Error {\n  return (error as any)[ERROR_ORIGINAL_ERROR];\n}\n\nexport function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void {\n  return (error as any)[ERROR_LOGGER] || defaultErrorLogger;\n}\n\n\nfunction defaultErrorLogger(console: Console, ...values: any[]) {\n  (<any>console.error)(...values);\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getDebugContext, getErrorLogger, getOriginalError} from './errors';\n\n\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nexport class ErrorHandler {\n  /**\n   * @internal\n   */\n  _console: Console = console;\n\n  handleError(error: any): void {\n    const originalError = this._findOriginalError(error);\n    const context = this._findContext(error);\n    // Note: Browser consoles show the place from where console.error was called.\n    // We can use this to give users additional information about the error.\n    const errorLogger = getErrorLogger(error);\n\n    errorLogger(this._console, `ERROR`, error);\n    if (originalError) {\n      errorLogger(this._console, `ORIGINAL ERROR`, originalError);\n    }\n    if (context) {\n      errorLogger(this._console, 'ERROR CONTEXT', context);\n    }\n  }\n\n  /** @internal */\n  _findContext(error: any): any {\n    if (error) {\n      return getDebugContext(error) ? getDebugContext(error) :\n                                      this._findContext(getOriginalError(error));\n    }\n\n    return null;\n  }\n\n  /** @internal */\n  _findOriginalError(error: Error): any {\n    let e = getOriginalError(error);\n    while (e && getOriginalError(e)) {\n      e = getOriginalError(e);\n    }\n\n    return e;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * A schema definition associated with an NgModule.\n *\n * @see `@NgModule`, `CUSTOM_ELEMENTS_SCHEMA`, `NO_ERRORS_SCHEMA`\n *\n * @param name The name of a defined schema.\n *\n * @publicApi\n */\nexport interface SchemaMetadata { name: string; }\n\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements'\n};\n\n/**\n * Defines a schema that allows any property on any element.\n *\n * @publicApi\n */\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema'\n};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.\n *\n * For more information on how to run and debug tests with either Ivy or View Engine (legacy),\n * please see [BAZEL.md](./docs/BAZEL.md).\n */\n\nlet _devMode: boolean = true;\nlet _runModeLocked: boolean = false;\n\n\n/**\n * Returns whether Angular is in development mode. After called once,\n * the value is locked and won't change any more.\n *\n * By default, this is true, unless a user calls `enableProdMode` before calling this.\n *\n * @publicApi\n */\nexport function isDevMode(): boolean {\n  _runModeLocked = true;\n  return _devMode;\n}\n\n/**\n * Disable Angular's development mode, which turns off assertions and other\n * checks within the framework.\n *\n * One important assertion this disables verifies that a change detection pass\n * does not result in additional changes to any bindings (also known as\n * unidirectional data flow).\n *\n * @publicApi\n */\nexport function enableProdMode(): void {\n  if (_runModeLocked) {\n    throw new Error('Cannot enable prod mode after platform setup.');\n  }\n  _devMode = false;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we must use one of three strategies for doing this.\n * Support: Safari 10.x -> XHR strategy\n * Support: Firefox -> DomParser strategy\n * Default: InertDocument strategy\n */\nexport class InertBodyHelper {\n  private inertBodyElement: HTMLElement;\n  private inertDocument: Document;\n\n  constructor(private defaultDoc: Document) {\n    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n    this.inertBodyElement = this.inertDocument.body;\n\n    if (this.inertBodyElement == null) {\n      // usually there should be only one body element in the document, but IE doesn't have any, so\n      // we need to create one.\n      const inertHtml = this.inertDocument.createElement('html');\n      this.inertDocument.appendChild(inertHtml);\n      this.inertBodyElement = this.inertDocument.createElement('body');\n      inertHtml.appendChild(this.inertBodyElement);\n    }\n\n    this.inertBodyElement.innerHTML = '<svg><g onload=\"this.parentNode.remove()\"></g></svg>';\n    if (this.inertBodyElement.querySelector && !this.inertBodyElement.querySelector('svg')) {\n      // We just hit the Safari 10.1 bug - which allows JS to run inside the SVG G element\n      // so use the XHR strategy.\n      this.getInertBodyElement = this.getInertBodyElement_XHR;\n      return;\n    }\n\n    this.inertBodyElement.innerHTML =\n        '<svg><p><style><img src=\"</style><img src=x onerror=alert(1)//\">';\n    if (this.inertBodyElement.querySelector && this.inertBodyElement.querySelector('svg img')) {\n      // We just hit the Firefox bug - which prevents the inner img JS from being sanitized\n      // so use the DOMParser strategy, if it is available.\n      // If the DOMParser is not available then we are not in Firefox (Server/WebWorker?) so we\n      // fall through to the default strategy below.\n      if (isDOMParserAvailable()) {\n        this.getInertBodyElement = this.getInertBodyElement_DOMParser;\n        return;\n      }\n    }\n\n    // None of the bugs were hit so it is safe for us to use the default InertDocument strategy\n    this.getInertBodyElement = this.getInertBodyElement_InertDocument;\n  }\n\n  /**\n   * Get an inert DOM element containing DOM created from the dirty HTML string provided.\n   * The implementation of this is determined in the constructor, when the class is instantiated.\n   */\n  getInertBodyElement: (html: string) => HTMLElement | null;\n\n  /**\n   * Use XHR to create and fill an inert body element (on Safari 10.1)\n   * See\n   * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449\n   */\n  private getInertBodyElement_XHR(html: string) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      html = encodeURI(html);\n    } catch {\n      return null;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'document';\n    xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);\n    xhr.send(undefined);\n    const body: HTMLBodyElement = xhr.response.body;\n    body.removeChild(body.firstChild !);\n    return body;\n  }\n\n  /**\n   * Use DOMParser to create and fill an inert body element (on Firefox)\n   * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7\n   *\n   */\n  private getInertBodyElement_DOMParser(html: string) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      const body = new (window as any)\n                       .DOMParser()\n                       .parseFromString(html, 'text/html')\n                       .body as HTMLBodyElement;\n      body.removeChild(body.firstChild !);\n      return body;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Use an HTML5 `template` element, if supported, or an inert body element created via\n   * `createHtmlDocument` to create and fill an inert DOM element.\n   * This is the default sane strategy to use if the browser does not require one of the specialised\n   * strategies above.\n   */\n  private getInertBodyElement_InertDocument(html: string) {\n    // Prefer using <template> element if supported.\n    const templateEl = this.inertDocument.createElement('template');\n    if ('content' in templateEl) {\n      templateEl.innerHTML = html;\n      return templateEl;\n    }\n\n    this.inertBodyElement.innerHTML = html;\n\n    // Support: IE 9-11 only\n    // strip custom-namespaced attributes on IE<=11\n    if ((this.defaultDoc as any).documentMode) {\n      this.stripCustomNsAttrs(this.inertBodyElement);\n    }\n\n    return this.inertBodyElement;\n  }\n\n  /**\n   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n   * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n   * 'ns1:xlink:foo').\n   *\n   * This is undesirable since we don't want to allow any of these custom attributes. This method\n   * strips them all.\n   */\n  private stripCustomNsAttrs(el: Element) {\n    const elAttrs = el.attributes;\n    // loop backwards so that we can support removals.\n    for (let i = elAttrs.length - 1; 0 < i; i--) {\n      const attrib = elAttrs.item(i);\n      const attrName = attrib !.name;\n      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n        el.removeAttribute(attrName);\n      }\n    }\n    let childNode = el.firstChild as Node | null;\n    while (childNode) {\n      if (childNode.nodeType === Node.ELEMENT_NODE) this.stripCustomNsAttrs(childNode as Element);\n      childNode = childNode.nextSibling;\n    }\n  }\n}\n\n/**\n * We need to determine whether the DOMParser exists in the global context.\n * The try-catch is because, on some browsers, trying to access this property\n * on window can actually throw an error.\n *\n * @suppress {uselessCode}\n */\nfunction isDOMParserAvailable() {\n  try {\n    return !!(window as any).DOMParser;\n  } catch {\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode} from '../util/is_dev_mode';\n\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if (comment from here on and regex copied from\n * Soy's EscapingConventions):\n * (1) Either an allowed protocol (http, https, mailto or ftp).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n\n/* A pattern that matches safe srcset values */\nconst SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n\n/** A pattern that matches safe data URLs. Only matches image, video and audio types. */\nconst DATA_URL_PATTERN =\n    /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\n\nexport function _sanitizeUrl(url: string): string {\n  url = String(url);\n  if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;\n\n  if (isDevMode()) {\n    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see http://g.co/ng/security#xss)`);\n  }\n\n  return 'unsafe:' + url;\n}\n\nexport function sanitizeSrcset(srcset: string): string {\n  srcset = String(srcset);\n  return srcset.split(',').map((srcset) => _sanitizeUrl(srcset.trim())).join(', ');\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode} from '../util/is_dev_mode';\nimport {InertBodyHelper} from './inert_body';\nimport {_sanitizeUrl, sanitizeSrcset} from './url_sanitizer';\n\nfunction tagSet(tags: string): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const t of tags.split(',')) res[t] = true;\n  return res;\n}\n\nfunction merge(...sets: {[k: string]: boolean}[]): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const s of sets) {\n    for (const v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n  return res;\n}\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS =\n    merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(\n    OPTIONAL_END_TAG_BLOCK_ELEMENTS,\n    tagSet(\n        'address,article,' +\n        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(\n    OPTIONAL_END_TAG_INLINE_ELEMENTS,\n    tagSet(\n        'a,abbr,acronym,audio,b,' +\n        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\n        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\n\nexport const VALID_ELEMENTS =\n    merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n\n// Attributes that have href and hence need to be sanitized\nexport const URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\n\n// Attributes that have special href set hence need to be sanitized\nexport const SRCSET_ATTRS = tagSet('srcset');\n\nconst HTML_ATTRS = tagSet(\n    'abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\n    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\n    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +\n    'valign,value,vspace,width');\n\n// Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\nconst ARIA_ATTRS = tagSet(\n    'aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' +\n    'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' +\n    'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' +\n    'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' +\n    'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' +\n    'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' +\n    'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');\n\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\n\nexport const VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS);\n\n// Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\n//\n// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\n// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\n// don't want to preserve the content, if the elements themselves are going to be removed.\nconst SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\n\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n  // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n  // because characters were re-encoded.\n  public sanitizedSomething = false;\n  private buf: string[] = [];\n\n  sanitizeChildren(el: Element): string {\n    // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n    // However this code never accesses properties off of `document` before deleting its contents\n    // again, so it shouldn't be vulnerable to DOM clobbering.\n    let current: Node = el.firstChild !;\n    let traverseContent = true;\n    while (current) {\n      if (current.nodeType === Node.ELEMENT_NODE) {\n        traverseContent = this.startElement(current as Element);\n      } else if (current.nodeType === Node.TEXT_NODE) {\n        this.chars(current.nodeValue !);\n      } else {\n        // Strip non-element, non-text nodes.\n        this.sanitizedSomething = true;\n      }\n      if (traverseContent && current.firstChild) {\n        current = current.firstChild !;\n        continue;\n      }\n      while (current) {\n        // Leaving the element. Walk up and to the right, closing tags as we go.\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          this.endElement(current as Element);\n        }\n\n        let next = this.checkClobberedElement(current, current.nextSibling !);\n\n        if (next) {\n          current = next;\n          break;\n        }\n\n        current = this.checkClobberedElement(current, current.parentNode !);\n      }\n    }\n    return this.buf.join('');\n  }\n\n  /**\n   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n   * be traversed. Element content must always be traversed (even if the element itself is not\n   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n   *\n   * @param element The element to sanitize.\n   * @return True if the element's contents should be traversed.\n   */\n  private startElement(element: Element): boolean {\n    const tagName = element.nodeName.toLowerCase();\n    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.sanitizedSomething = true;\n      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n    }\n    this.buf.push('<');\n    this.buf.push(tagName);\n    const elAttrs = element.attributes;\n    for (let i = 0; i < elAttrs.length; i++) {\n      const elAttr = elAttrs.item(i);\n      const attrName = elAttr !.name;\n      const lower = attrName.toLowerCase();\n      if (!VALID_ATTRS.hasOwnProperty(lower)) {\n        this.sanitizedSomething = true;\n        continue;\n      }\n      let value = elAttr !.value;\n      // TODO(martinprobst): Special case image URIs for data:image/...\n      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);\n      if (SRCSET_ATTRS[lower]) value = sanitizeSrcset(value);\n      this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n    }\n    this.buf.push('>');\n    return true;\n  }\n\n  private endElement(current: Element) {\n    const tagName = current.nodeName.toLowerCase();\n    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.buf.push('</');\n      this.buf.push(tagName);\n      this.buf.push('>');\n    }\n  }\n\n  private chars(chars: string) { this.buf.push(encodeEntities(chars)); }\n\n  checkClobberedElement(node: Node, nextNode: Node): Node {\n    if (nextNode &&\n        (node.compareDocumentPosition(nextNode) &\n         Node.DOCUMENT_POSITION_CONTAINED_BY) ===Â Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      throw new Error(\n          `Failed to sanitize html because the element is clobbered: ${(node as Element).outerHTML}`);\n    }\n    return nextNode;\n  }\n}\n\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\nfunction encodeEntities(value: string) {\n  return value.replace(/&/g, '&amp;')\n      .replace(\n          SURROGATE_PAIR_REGEXP,\n          function(match: string) {\n            const hi = match.charCodeAt(0);\n            const low = match.charCodeAt(1);\n            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n          })\n      .replace(\n          NON_ALPHANUMERIC_REGEXP,\n          function(match: string) { return '&#' + match.charCodeAt(0) + ';'; })\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n}\n\nlet inertBodyHelper: InertBodyHelper;\n\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nexport function _sanitizeHtml(defaultDoc: any, unsafeHtmlInput: string): string {\n  let inertBodyElement: HTMLElement|null = null;\n  try {\n    inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);\n    // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n\n    // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n    // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n    let mXSSAttempts = 5;\n    let parsedHtml = unsafeHtml;\n\n    do {\n      if (mXSSAttempts === 0) {\n        throw new Error('Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n\n      unsafeHtml = parsedHtml;\n      parsedHtml = inertBodyElement !.innerHTML;\n      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    } while (unsafeHtml !== parsedHtml);\n\n    const sanitizer = new SanitizingHtmlSerializer();\n    const safeHtml = sanitizer.sanitizeChildren(\n        getTemplateContent(inertBodyElement !) as Element || inertBodyElement);\n    if (isDevMode() && sanitizer.sanitizedSomething) {\n      console.warn(\n          'WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss');\n    }\n\n    return safeHtml;\n  } finally {\n    // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n    if (inertBodyElement) {\n      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n      while (parent.firstChild) {\n        parent.removeChild(parent.firstChild);\n      }\n    }\n  }\n}\n\nexport function getTemplateContent(el: Node): Node|null {\n  return 'content' in (el as any /** Microsoft/TypeScript#21517 */) && isTemplateElement(el) ?\n      el.content :\n      null;\n}\nfunction isTemplateElement(el: Node): el is HTMLTemplateElement {\n  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode} from '../util/is_dev_mode';\nimport {SafeValue} from './bypass';\nimport {_sanitizeUrl} from './url_sanitizer';\n\n\n/**\n * Regular expression for safe style values.\n *\n * Quotes (\" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.\n *\n * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or\n * font-family) and hence could allow multiple values to get injected, but that should pose no risk\n * of XSS.\n *\n * The function expression checks only for XSS safety, not for CSS validity.\n *\n * This regular expression was taken from the Closure sanitization library, and augmented for\n * transformation values.\n */\nconst VALUES = '[-,.\"\\'%_!# a-zA-Z0-9]+';\nconst TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?';\nconst COLOR_FNS = '(?:rgb|hsl)a?';\nconst GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';\nconst CSS3_FNS = '(?:attr|calc|var)';\nconst FN_ARGS = '\\\\([-0-9.%, #a-zA-Z]+\\\\)';\nconst SAFE_STYLE_VALUE = new RegExp(\n    `^(${VALUES}|` +\n        `(?:${TRANSFORMATION_FNS}|${COLOR_FNS}|${GRADIENTS}|${CSS3_FNS})` +\n        `${FN_ARGS})$`,\n    'g');\n\n/**\n * Matches a `url(...)` value with an arbitrary argument as long as it does\n * not contain parentheses.\n *\n * The URL value still needs to be sanitized separately.\n *\n * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted\n * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.\n * by observing whether scroll bars are displayed, or character ranges used by a font face\n * definition.\n *\n * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that\n * binding a URL value without further cooperation from the page will cause an information leak, and\n * if so, it is just a leak, not a full blown XSS vulnerability.\n *\n * Given the common use case, low likelihood of attack vector, and low impact of an attack, this\n * code is permissive and allows URLs that sanitize otherwise.\n */\nconst URL_RE = /^url\\(([^)]+)\\)$/;\n\n/**\n * Checks that quotes (\" and ') are properly balanced inside a string. Assumes\n * that neither escape (\\) nor any other character that could result in\n * breaking out of a string parsing context are allowed;\n * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.\n *\n * This code was taken from the Closure sanitization library.\n */\nfunction hasBalancedQuotes(value: string) {\n  let outsideSingle = true;\n  let outsideDouble = true;\n  for (let i = 0; i < value.length; i++) {\n    const c = value.charAt(i);\n    if (c === '\\'' && outsideDouble) {\n      outsideSingle = !outsideSingle;\n    } else if (c === '\"' && outsideSingle) {\n      outsideDouble = !outsideDouble;\n    }\n  }\n  return outsideSingle && outsideDouble;\n}\n\n/**\n * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\n * value) and returns a value that is safe to use in a browser environment.\n */\nexport function _sanitizeStyle(value: string): string {\n  value = String(value).trim();  // Make sure it's actually a string.\n  if (!value) return '';\n\n  // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for\n  // reasoning behind this.\n  const urlMatch = value.match(URL_RE);\n  if ((urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||\n      value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {\n    return value;  // Safe style values.\n  }\n\n  if (isDevMode()) {\n    console.warn(\n        `WARNING: sanitizing unsafe style value ${value} (see http://g.co/ng/security#xss).`);\n  }\n\n  return 'unsafe';\n}\n\n\n/**\n * A series of flags to instruct a style sanitizer to either validate\n * or sanitize a value.\n *\n * Because sanitization is dependent on the style property (i.e. style\n * sanitization for `width` is much different than for `background-image`)\n * the sanitization function (e.g. `StyleSanitizerFn`) needs to check a\n * property value first before it actually sanitizes any values.\n *\n * This enum exist to allow a style sanitization function to either only\n * do validation (check the property to see whether a value will be\n * sanitized or not) or to sanitize the value (or both).\n *\n * @publicApi\n */\nexport const enum StyleSanitizeMode {\n  /** Just check to see if the property is required to be sanitized or not */\n  ValidateProperty = 0b01,\n  /** Skip checking the property; just sanitize the value */\n  SanitizeOnly = 0b10,\n  /** Check the property and (if true) then sanitize the value */\n  ValidateAndSanitize = 0b11,\n}\n\n/**\n * Used to intercept and sanitize style values before they are written to the renderer.\n *\n * This function is designed to be called in two modes. When a value is not provided\n * then the function will return a boolean whether a property will be sanitized later.\n * If a value is provided then the sanitized version of that will be returned.\n */\nexport interface StyleSanitizeFn {\n  (prop: string, value: string|SafeValue|null, mode?: StyleSanitizeMode): any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getDocument} from '../render3/interfaces/document';\nimport {SANITIZER} from '../render3/interfaces/view';\nimport {getLView} from '../render3/state';\nimport {renderStringify} from '../render3/util/misc_utils';\n\nimport {BypassType, allowSanitizationBypassAndThrow, unwrapSafeValue} from './bypass';\nimport {_sanitizeHtml as _sanitizeHtml} from './html_sanitizer';\nimport {Sanitizer} from './sanitizer';\nimport {SecurityContext} from './security';\nimport {StyleSanitizeFn, StyleSanitizeMode, _sanitizeStyle as _sanitizeStyle} from './style_sanitizer';\nimport {_sanitizeUrl as _sanitizeUrl} from './url_sanitizer';\n\n\n\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeHtml(unsafeHtml: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeHtml, BypassType.Html)) {\n    return unwrapSafeValue(unsafeHtml);\n  }\n  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));\n}\n\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `style` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties, because all of the\n * dangerous javascript and urls have been removed.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeStyle(unsafeStyle: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeStyle, BypassType.Style)) {\n    return unwrapSafeValue(unsafeStyle);\n  }\n  return _sanitizeStyle(renderStringify(unsafeStyle));\n}\n\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeUrl(unsafeUrl: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeUrl, BypassType.Url)) {\n    return unwrapSafeValue(unsafeUrl);\n  }\n  return _sanitizeUrl(renderStringify(unsafeUrl));\n}\n\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeResourceUrl(unsafeResourceUrl: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeResourceUrl, BypassType.ResourceUrl)) {\n    return unwrapSafeValue(unsafeResourceUrl);\n  }\n  throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');\n}\n\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link\n * bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts` have been allowed to pass.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeScript(unsafeScript: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeScript, BypassType.Script)) {\n    return unwrapSafeValue(unsafeScript);\n  }\n  throw new Error('unsafe value used in a script context');\n}\n\n/**\n * Detects which sanitizer to use for URL property, based on tag name and prop name.\n *\n * The rules are based on the RESOURCE_URL context config from\n * `packages/compiler/src/schema/dom_security_schema.ts`.\n * If tag and prop names don't match Resource URL schema, use URL sanitizer.\n */\nexport function getUrlSanitizer(tag: string, prop: string) {\n  if ((prop === 'src' && (tag === 'embed' || tag === 'frame' || tag === 'iframe' ||\n                          tag === 'media' || tag === 'script')) ||\n      (prop === 'href' && (tag === 'base' || tag === 'link'))) {\n    return ÉµÉµsanitizeResourceUrl;\n  }\n  return ÉµÉµsanitizeUrl;\n}\n\n/**\n * Sanitizes URL, selecting sanitizer function based on tag and property names.\n *\n * This function is used in case we can't define security context at compile time, when only prop\n * name is available. This happens when we generate host bindings for Directives/Components. The\n * host element is unknown at compile time, so we defer calculation of specific sanitizer to\n * runtime.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @param tag target element tag name.\n * @param prop name of the property that contains the value.\n * @returns `url` string which is safe to bind.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeUrlOrResourceUrl(unsafeUrl: any, tag: string, prop: string): any {\n  return getUrlSanitizer(tag, prop)(unsafeUrl);\n}\n\n/**\n * The default style sanitizer will handle sanitization for style properties by\n * sanitizing any CSS property that can include a `url` value (usually image-based properties)\n *\n * @publicApi\n */\nexport const ÉµÉµdefaultStyleSanitizer =\n    (function(prop: string, value: string|null, mode?: StyleSanitizeMode): string | boolean | null {\n      mode = mode || StyleSanitizeMode.ValidateAndSanitize;\n      let doSanitizeValue = true;\n      if (mode & StyleSanitizeMode.ValidateProperty) {\n        doSanitizeValue = prop === 'background-image' || prop === 'background' ||\n            prop === 'border-image' || prop === 'filter' || prop === 'list-style' ||\n            prop === 'list-style-image' || prop === 'clip-path';\n      }\n\n      if (mode & StyleSanitizeMode.SanitizeOnly) {\n        return doSanitizeValue ? ÉµÉµsanitizeStyle(value) : value;\n      } else {\n        return doSanitizeValue;\n      }\n    } as StyleSanitizeFn);\n\nexport function validateAgainstEventProperties(name: string) {\n  if (name.toLowerCase().startsWith('on')) {\n    const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +\n        `please use (${name.slice(2)})=...` +\n        `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n        ` current module.`;\n    throw new Error(msg);\n  }\n}\n\nexport function validateAgainstEventAttributes(name: string) {\n  if (name.toLowerCase().startsWith('on')) {\n    const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n        `please use (${name.slice(2)})=...`;\n    throw new Error(msg);\n  }\n}\n\nfunction getSanitizer(): Sanitizer|null {\n  const lView = getLView();\n  return lView && lView[SANITIZER];\n}\n","\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\n/**\n * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!\n */\n\n\n/**\n * Creates an `Array` construction with a given name. This is useful when\n * looking for memory consumption to see what time of array it is.\n *\n *\n * @param name Name to give to the constructor\n * @returns A subclass of `Array` if possible. This can only be done in\n *          environments which support `class` construct.\n */\nexport function createNamedArrayType(name: string): typeof Array {\n  // This should never be called in prod mode, so let's verify that is the case.\n  if (ngDevMode) {\n    try {\n      // We need to do it this way so that TypeScript does not down-level the below code.\n      const FunctionConstructor: any = createNamedArrayType.constructor;\n      return (new FunctionConstructor('Array', `return class ${name} extends Array{}`))(Array);\n    } catch (e) {\n      // If it does not work just give up and fall back to regular Array.\n      return Array;\n    }\n  } else {\n    throw new Error(\n        'Looks like we are in \\'prod mode\\', but we are creating a named Array type, which is wrong! Check your code');\n  }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function normalizeDebugBindingName(name: string) {\n  // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\n  name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\n  return `ng-reflect-${name}`;\n}\n\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\n\nfunction camelCaseToDashCase(input: string): string {\n  return input.replace(CAMEL_CASE_REGEXP, (...m: any[]) => '-' + m[1].toLowerCase());\n}\n\nexport function normalizeDebugBindingValue(value: any): string {\n  try {\n    // Limit the size of the value as otherwise the DOM just gets polluted.\n    return value != null ? value.toString().slice(0, 30) : value;\n  } catch (e) {\n    return '[ERROR] Exception while trying to serialize the value';\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {RNode} from './renderer';\nimport {LView} from './view';\n\n/**\n * This property will be monkey-patched on elements, components and directives\n */\nexport const MONKEY_PATCH_KEY_NAME = '__ngContext__';\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nexport interface LContext {\n  /**\n   * The component's parent view data.\n   */\n  lView: LView;\n\n  /**\n   * The index instance of the node.\n   */\n  nodeIndex: number;\n\n  /**\n   * The instance of the DOM node that is attached to the lNode.\n   */\n  native: RNode;\n\n  /**\n   * The instance of the Component node.\n   */\n  component: {}|null|undefined;\n\n  /**\n   * The list of active directives that exist on this element.\n   */\n  directives: any[]|null|undefined;\n\n  /**\n   * The map of local references (local reference name => element or directive instance) that exist\n   * on this element.\n   */\n  localRefs: {[key: string]: any}|null|undefined;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDataInRange, assertDefined, assertDomNode, assertGreaterThan, assertLessThan} from '../../util/assert';\nimport {assertTNodeForLView} from '../assert';\nimport {ACTIVE_INDEX, ActiveIndexFlag, LContainer, TYPE} from '../interfaces/container';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from '../interfaces/context';\nimport {TConstants, TNode} from '../interfaces/node';\nimport {RNode, isProceduralRenderer} from '../interfaces/renderer';\nimport {isLContainer, isLView} from '../interfaces/type_checks';\nimport {FLAGS, HEADER_OFFSET, HOST, LView, LViewFlags, PARENT, PREORDER_HOOK_FLAGS, RENDERER, TData, TVIEW} from '../interfaces/view';\n\n\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapRNode(value: RNode | LView | LContainer): RNode {\n  while (Array.isArray(value)) {\n    value = value[HOST] as any;\n  }\n  return value as RNode;\n}\n\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapLView(value: RNode | LView | LContainer): LView|null {\n  while (Array.isArray(value)) {\n    // This check is same as `isLView()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (typeof value[TYPE] === 'object') return value as LView;\n    value = value[HOST] as any;\n  }\n  return null;\n}\n\n/**\n * Returns `LContainer` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapLContainer(value: RNode | LView | LContainer): LContainer|null {\n  while (Array.isArray(value)) {\n    // This check is same as `isLContainer()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (value[TYPE] === true) return value as LContainer;\n    value = value[HOST] as any;\n  }\n  return null;\n}\n\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport function getNativeByIndex(index: number, lView: LView): RNode {\n  return unwrapRNode(lView[index + HEADER_OFFSET]);\n}\n\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNode(tNode: TNode, lView: LView): RNode {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertDataInRange(lView, tNode.index);\n  const node: RNode = unwrapRNode(lView[tNode.index]);\n  ngDevMode && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n  return node;\n}\n\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNodeOrNull(tNode: TNode, lView: LView): RNode|null {\n  const index = tNode.index;\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const node: RNode|null = unwrapRNode(lView[index]);\n    ngDevMode && node !== null && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n    return node;\n  }\n  return null;\n}\n\n\nexport function getTNode(index: number, view: LView): TNode {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, view[TVIEW].data.length, 'wrong index for TNode');\n  return view[TVIEW].data[index + HEADER_OFFSET] as TNode;\n}\n\n/** Retrieves a value from any `LView` or `TData`. */\nexport function load<T>(view: LView | TData, index: number): T {\n  ngDevMode && assertDataInRange(view, index + HEADER_OFFSET);\n  return view[index + HEADER_OFFSET];\n}\n\nexport function getComponentLViewByIndex(nodeIndex: number, hostView: LView): LView {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  ngDevMode && assertDataInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\n\n\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nexport function readPatchedData(target: any): LView|LContext|null {\n  ngDevMode && assertDefined(target, 'Target expected');\n  return target[MONKEY_PATCH_KEY_NAME] || null;\n}\n\nexport function readPatchedLView(target: any): LView|null {\n  const value = readPatchedData(target);\n  if (value) {\n    return Array.isArray(value) ? value : (value as LContext).lView;\n  }\n  return null;\n}\n\n/** Checks whether a given view is in creation mode */\nexport function isCreationMode(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n}\n\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nexport function viewAttachedToChangeDetector(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/** Returns a boolean for whether the view is attached to a container. */\nexport function viewAttachedToContainer(view: LView): boolean {\n  return isLContainer(view[PARENT]);\n}\n\n/** Returns a constant from `TConstants` instance. */\nexport function getConstant<T>(consts: TConstants | null, index: number | null | undefined): T|\n    null {\n  return consts === null || index == null ? null : consts[index] as unknown as T;\n}\n\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nexport function resetPreOrderHookFlags(lView: LView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\n\nexport function getLContainerActiveIndex(lContainer: LContainer) {\n  return lContainer[ACTIVE_INDEX] >> ActiveIndexFlag.SHIFT;\n}\n\nexport function setLContainerActiveIndex(lContainer: LContainer, index: number) {\n  lContainer[ACTIVE_INDEX] = index << ActiveIndexFlag.SHIFT;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../util/ng_dev_mode';\n\nimport {assertDomNode} from '../util/assert';\n\nimport {EMPTY_ARRAY} from './empty';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {TNode, TNodeFlags} from './interfaces/node';\nimport {RElement, RNode} from './interfaces/renderer';\nimport {CONTEXT, HEADER_OFFSET, HOST, LView, TVIEW} from './interfaces/view';\nimport {getComponentLViewByIndex, getNativeByTNodeOrNull, readPatchedData, unwrapRNode} from './util/view_utils';\n\n\n\n/** Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nexport function getLContext(target: any): LContext|null {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    // only when it's an array is it considered an LView instance\n    // ... otherwise it's an already constructed LContext instance\n    if (Array.isArray(mpValue)) {\n      const lView: LView = mpValue !;\n      let nodeIndex: number;\n      let component: any = undefined;\n      let directives: any[]|null|undefined = undefined;\n\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target as RElement);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n\n      // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, component, container, ICU\n      // expression or directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n      const native = unwrapRNode(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context: LContext = (existingCtx && !Array.isArray(existingCtx)) ?\n          existingCtx :\n          createLContext(lView, nodeIndex, native);\n\n      // only when the component has been discovered then update the monkey-patch\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      }\n\n      // only when the directives have been discovered then update the monkey-patch\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target as RElement;\n    ngDevMode && assertDomNode(rElement);\n\n    // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n    let parent = rElement as any;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        let lView: LView|null;\n        if (Array.isArray(parentContext)) {\n          lView = parentContext as LView;\n        } else {\n          lView = parentContext.lView;\n        }\n\n        // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n        if (!lView) {\n          return null;\n        }\n\n        const index = findViaNativeElement(lView, rElement);\n        if (index >= 0) {\n          const native = unwrapRNode(lView[index]);\n          const context = createLContext(lView, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n  return (mpValue as LContext) || null;\n}\n\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView: LView, nodeIndex: number, native: RNode): LContext {\n  return {\n    lView,\n    nodeIndex,\n    native,\n    component: undefined,\n    directives: undefined,\n    localRefs: undefined,\n  };\n}\n\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nexport function getComponentViewByInstance(componentInstance: {}): LView {\n  let lView = readPatchedData(componentInstance);\n  let view: LView;\n\n  if (Array.isArray(lView)) {\n    const nodeIndex = findViaComponent(lView, componentInstance);\n    view = getComponentLViewByIndex(nodeIndex, lView);\n    const context = createLContext(lView, nodeIndex, view[HOST] as RElement);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = lView as any as LContext;\n    view = getComponentLViewByIndex(context.nodeIndex, context.lView);\n  }\n  return view;\n}\n\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nexport function attachPatchData(target: any, data: LView | LContext) {\n  target[MONKEY_PATCH_KEY_NAME] = data;\n}\n\nexport function isComponentInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.Éµcmp;\n}\n\nexport function isDirectiveInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.Éµdir;\n}\n\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView: LView, target: RElement): number {\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const native = getNativeByTNodeOrNull(tNode, lView) !;\n    if (native === target) {\n      return tNode.index;\n    }\n    tNode = traverseNextElement(tNode);\n  }\n\n  return -1;\n}\n\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode: TNode): TNode|null {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else {\n    // Let's take the following template: <div><span>text</span></div><component/>\n    // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n    // in this case the parent `div`, so that we can find the component.\n    while (tNode.parent && !tNode.parent.next) {\n      tNode = tNode.parent;\n    }\n    return tNode.parent && tNode.parent.next;\n  }\n}\n\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView: LView, componentInstance: {}): number {\n  const componentIndices = lView[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\n\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView: LView, directiveInstance: {}): number {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LView of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = tNode.directiveStart;\n    const directiveIndexEnd = tNode.directiveEnd;\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\n\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nexport function getDirectivesAtNodeIndex(\n    nodeIndex: number, lView: LView, includeComponents: boolean): any[]|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  if (directiveStartIndex == 0) return EMPTY_ARRAY;\n  const directiveEndIndex = tNode.directiveEnd;\n  if (!includeComponents && tNode.flags & TNodeFlags.isComponentHost) directiveStartIndex++;\n  return lView.slice(directiveStartIndex, directiveEndIndex);\n}\n\nexport function getComponentAtNodeIndex(nodeIndex: number, lView: LView): {}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  return tNode.flags & TNodeFlags.isComponentHost ? lView[directiveStartIndex] : null;\n}\n\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nexport function discoverLocalRefs(lView: LView, nodeIndex: number): {[key: string]: any}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  if (tNode && tNode.localNames) {\n    const result: {[key: string]: any} = {};\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      result[tNode.localNames[i]] = lView[localIndex];\n      localIndex++;\n    }\n    return result;\n  }\n\n  return null;\n}\n","\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectorType} from '../di/interface/defs';\nimport {stringify} from '../util/stringify';\n\nimport {TNode} from './interfaces/node';\n\n\n/** Called when directives inject each other (creating a circular dependency) */\nexport function throwCyclicDependencyError(token: any): never {\n  throw new Error(`Cannot instantiate cyclic dependency! ${token}`);\n}\n\n/** Called when there are multiple component selectors that match a given node */\nexport function throwMultipleComponentError(tNode: TNode): never {\n  throw new Error(`Multiple components match node with tagname ${tNode.tagName}`);\n}\n\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\nexport function throwErrorIfNoChangesMode(\n    creationMode: boolean, oldValue: any, currValue: any): never|void {\n  let msg =\n      `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '${oldValue}'. Current value: '${currValue}'.`;\n  if (creationMode) {\n    msg +=\n        ` It seems like the view has been created after its parent and its children have been dirty checked.` +\n        ` Has it been created in a change detection hook ?`;\n  }\n  // TODO: include debug context\n  throw new Error(msg);\n}\n\nexport function throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\n\nexport function throwInvalidProviderError(\n    ngModuleType?: InjectorType<any>, providers?: any[], provider?: any) {\n  let ngModuleDetail = '';\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n    ngModuleDetail =\n        ` - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`;\n  }\n\n  throw new Error(\n      `Invalid provider for the NgModule '${stringify(ngModuleType)}'` + ngModuleDetail);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {StylingMapArray, TStylingContext} from '../interfaces/styling';\nimport {CssSelector} from './projection';\nimport {RNode} from './renderer';\nimport {LView, TView} from './view';\n\n\n/**\n * TNodeType corresponds to the {@link TNode} `type` property.\n */\nexport const enum TNodeType {\n  /**\n   * The TNode contains information about an {@link LContainer} for embedded views.\n   */\n  Container = 0,\n  /**\n   * The TNode contains information about an `<ng-content>` projection\n   */\n  Projection = 1,\n  /**\n   * The TNode contains information about an {@link LView}\n   */\n  View = 2,\n  /**\n   * The TNode contains information about a DOM element aka {@link RNode}.\n   */\n  Element = 3,\n  /**\n   * The TNode contains information about an `<ng-container>` element {@link RNode}.\n   */\n  ElementContainer = 4,\n  /**\n   * The TNode contains information about an ICU comment used in `i18n`.\n   */\n  IcuContainer = 5,\n}\n\n/**\n * Corresponds to the TNode.flags property.\n */\nexport const enum TNodeFlags {\n  /** Bit #1 - This bit is set if the node is a host for any directive (including a component) */\n  isDirectiveHost = 0x1,\n\n  /**\n   * Bit #2 - This bit is set if the node is a host for a component.\n   *\n   * Setting this bit implies that the `isDirectiveHost` bit is set as well.\n   * */\n  isComponentHost = 0x2,\n\n  /** Bit #3 - This bit is set if the node has been projected */\n  isProjected = 0x4,\n\n  /** Bit #4 - This bit is set if any directive on this node has content queries */\n  hasContentQuery = 0x8,\n\n  /** Bit #5 - This bit is set if the node has any \"class\" inputs */\n  hasClassInput = 0x10,\n\n  /** Bit #6 - This bit is set if the node has any \"style\" inputs */\n  hasStyleInput = 0x20,\n\n  /** Bit #7 This bit is set if the node has been detached by i18n */\n  isDetached = 0x40,\n\n  /**\n   * Bit #8 - This bit is set if the node has directives with host bindings.\n   *\n   * This flags allows us to guard host-binding logic and invoke it only on nodes\n   * that actually have directives with host bindings.\n   */\n  hasHostBindings = 0x80,\n\n  /** Bit #9 - This bit is set if the node has initial styling */\n  hasInitialStyling = 0x100,\n\n  /**\n   * Bit #10 - Whether or not there are class-based map bindings present.\n   *\n   * Examples include:\n   * 1. `<div [class]=\"x\">`\n   * 2. `@HostBinding('class') x`\n   */\n  hasClassMapBindings = 0x200,\n\n  /**\n   * Bit #11 - Whether or not there are any class-based prop bindings present.\n   *\n   * Examples include:\n   * 1. `<div [class.name]=\"x\">`\n   * 2. `@HostBinding('class.name') x`\n   */\n  hasClassPropBindings = 0x400,\n\n  /**\n   * Bit #12 - whether or not there are any active [class] and [class.name] bindings\n   */\n  hasClassPropAndMapBindings = hasClassMapBindings | hasClassPropBindings,\n\n  /**\n   * Bit #13 - Whether or not the context contains one or more class-based template bindings.\n   *\n   * Examples include:\n   * 1. `<div [class]=\"x\">`\n   * 2. `<div [class.name]=\"x\">`\n   */\n  hasTemplateClassBindings = 0x800,\n\n  /**\n   * Bit #14 - Whether or not the context contains one or more class-based host bindings.\n   *\n   * Examples include:\n   * 1. `@HostBinding('class') x`\n   * 2. `@HostBinding('class.name') x`\n   */\n  hasHostClassBindings = 0x1000,\n\n  /**\n   * Bit #15 - Whether or not there are two or more sources for a class property in the context.\n   *\n   * Examples include:\n   * 1. prop + prop: `<div [class.active]=\"x\" dir-that-sets-active-class>`\n   * 2. map + prop: `<div [class]=\"x\" [class.foo]>`\n   * 3. map + map: `<div [class]=\"x\" dir-that-sets-class>`\n   */\n  hasDuplicateClassBindings = 0x2000,\n\n  /**\n   * Bit #16 - Whether or not there are style-based map bindings present.\n   *\n   * Examples include:\n   * 1. `<div [style]=\"x\">`\n   * 2. `@HostBinding('style') x`\n   */\n  hasStyleMapBindings = 0x4000,\n\n  /**\n   * Bit #17 - Whether or not there are any style-based prop bindings present.\n   *\n   * Examples include:\n   * 1. `<div [style.prop]=\"x\">`\n   * 2. `@HostBinding('style.prop') x`\n   */\n  hasStylePropBindings = 0x8000,\n\n  /**\n   * Bit #18 - whether or not there are any active [style] and [style.prop] bindings\n   */\n  hasStylePropAndMapBindings = hasStyleMapBindings | hasStylePropBindings,\n\n  /**\n   * Bit #19 - Whether or not the context contains one or more style-based template bindings.\n   *\n   * Examples include:\n   * 1. `<div [style]=\"x\">`\n   * 2. `<div [style.prop]=\"x\">`\n   */\n  hasTemplateStyleBindings = 0x10000,\n\n  /**\n   * Bit #20 - Whether or not the context contains one or more style-based host bindings.\n   *\n   * Examples include:\n   * 1. `@HostBinding('style') x`\n   * 2. `@HostBinding('style.prop') x`\n   */\n  hasHostStyleBindings = 0x20000,\n\n  /**\n   * Bit #21 - Whether or not there are two or more sources for a style property in the context.\n   *\n   * Examples include:\n   * 1. prop + prop: `<div [style.width]=\"x\" dir-that-sets-width>`\n   * 2. map + prop: `<div [style]=\"x\" [style.prop]>`\n   * 3. map + map: `<div [style]=\"x\" dir-that-sets-style>`\n   */\n  hasDuplicateStyleBindings = 0x40000,\n}\n\n/**\n * Corresponds to the TNode.providerIndexes property.\n */\nexport const enum TNodeProviderIndexes {\n  /** The index of the first provider on this node is encoded on the least significant bits */\n  ProvidersStartIndexMask = 0b00000000000000001111111111111111,\n\n  /** The count of view providers from the component on this node is encoded on the 16 most\n     significant bits */\n  CptViewProvidersCountShift = 16,\n  CptViewProvidersCountShifter = 0b00000000000000010000000000000000,\n}\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n    * Signals class declaration.\n    *\n    * Each value following `Classes` designates a class name to include on the element.\n    * ## Example:\n    *\n    * Given:\n    * ```\n    * <div class=\"foo bar baz\">...<d/vi>\n    * ```\n    *\n    * the generated code is:\n    * ```\n    * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n    * ```\n    */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   */\n  I18n = 6,\n}\n\n/**\n * A combination of:\n * - Attribute names and values.\n * - Special markers acting as flags to alter attributes processing.\n * - Parsed ngProjectAs selectors.\n */\nexport type TAttributes = (string | AttributeMarker | CssSelector)[];\n\n/**\n * Constants that are associated with a view. Includes:\n * - Attribute arrays.\n * - Local definition arrays.\n */\nexport type TConstants = (TAttributes | string)[];\n\n/**\n * Binding data (flyweight) for a particular node that is shared between all templates\n * of a specific type.\n *\n * If a property is:\n *    - PropertyAliases: that property's data was generated and this is it\n *    - Null: that property's data was already generated and nothing was found.\n *    - Undefined: that property's data has not yet been generated\n *\n * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern\n */\nexport interface TNode {\n  /** The type of the TNode. See TNodeType. */\n  type: TNodeType;\n\n  /**\n   * Index of the TNode in TView.data and corresponding native element in LView.\n   *\n   * This is necessary to get from any TNode to its corresponding native element when\n   * traversing the node tree.\n   *\n   * If index is -1, this is a dynamically created container node or embedded view node.\n   */\n  index: number;\n\n  /**\n   * The index of the closest injector in this node's LView.\n   *\n   * If the index === -1, there is no injector on this node or any ancestor node in this view.\n   *\n   * If the index !== -1, it is the index of this node's injector OR the index of a parent injector\n   * in the same view. We pass the parent injector index down the node tree of a view so it's\n   * possible to find the parent injector without walking a potentially deep node tree. Injector\n   * indices are not set across view boundaries because there could be multiple component hosts.\n   *\n   * If tNode.injectorIndex === tNode.parent.injectorIndex, then the index belongs to a parent\n   * injector.\n   */\n  injectorIndex: number;\n\n  /**\n   * Stores starting index of the directives.\n   */\n  directiveStart: number;\n\n  /**\n   * Stores final exclusive index of the directives.\n   */\n  directiveEnd: number;\n\n  /**\n   * Stores indexes of property bindings. This field is only set in the ngDevMode and holds indexes\n   * of property bindings so TestBed can get bound property metadata for a given node.\n   */\n  propertyBindings: number[]|null;\n\n  /**\n   * Stores if Node isComponent, isProjected, hasContentQuery, hasClassInput and hasStyleInput etc.\n   */\n  flags: TNodeFlags;\n\n  /**\n   * This number stores two values using its bits:\n   *\n   * - the index of the first provider on that node (first 16 bits)\n   * - the count of view providers from the component on this node (last 16 bits)\n   */\n  // TODO(misko): break this into actual vars.\n  providerIndexes: TNodeProviderIndexes;\n\n  /** The tag name associated with this node. */\n  tagName: string|null;\n\n  /**\n   * Attributes associated with an element. We need to store attributes to support various use-cases\n   * (attribute injection, content projection with selectors, directives matching).\n   * Attributes are stored statically because reading them from the DOM would be way too slow for\n   * content projection and queries.\n   *\n   * Since attrs will always be calculated first, they will never need to be marked undefined by\n   * other instructions.\n   *\n   * For regular attributes a name of an attribute and its value alternate in the array.\n   * e.g. ['role', 'checkbox']\n   * This array can contain flags that will indicate \"special attributes\" (attributes with\n   * namespaces, attributes extracted from bindings and outputs).\n   */\n  attrs: TAttributes|null;\n\n  /**\n   * A set of local names under which a given element is exported in a template and\n   * visible to queries. An entry in this array can be created for different reasons:\n   * - an element itself is referenced, ex.: `<div #foo>`\n   * - a component is referenced, ex.: `<my-cmpt #foo>`\n   * - a directive is referenced, ex.: `<my-cmpt #foo=\"directiveExportAs\">`.\n   *\n   * A given element might have different local names and those names can be associated\n   * with a directive. We store local names at even indexes while odd indexes are reserved\n   * for directive index in a view (or `-1` if there is no associated directive).\n   *\n   * Some examples:\n   * - `<div #foo>` => `[\"foo\", -1]`\n   * - `<my-cmpt #foo>` => `[\"foo\", myCmptIdx]`\n   * - `<my-cmpt #foo #bar=\"directiveExportAs\">` => `[\"foo\", myCmptIdx, \"bar\", directiveIdx]`\n   * - `<div #foo #bar=\"directiveExportAs\">` => `[\"foo\", -1, \"bar\", directiveIdx]`\n   */\n  localNames: (string|number)[]|null;\n\n  /** Information about input properties that need to be set once from attribute data. */\n  initialInputs: InitialInputData|null|undefined;\n\n  /**\n   * Input data for all directives on this node. `null` means that there are no directives with\n   * inputs on this node.\n   */\n  inputs: PropertyAliases|null;\n\n  /**\n   * Output data for all directives on this node. `null` means that there are no directives with\n   * outputs on this node.\n   */\n  outputs: PropertyAliases|null;\n\n  /**\n   * The TView or TViews attached to this node.\n   *\n   * If this TNode corresponds to an LContainer with inline views, the container will\n   * need to store separate static data for each of its view blocks (TView[]). Otherwise,\n   * nodes in inline views with the same index as nodes in their parent views will overwrite\n   * each other, as they are in the same template.\n   *\n   * Each index in this array corresponds to the static data for a certain\n   * view. So if you had V(0) and V(1) in a container, you might have:\n   *\n   * [\n   *   [{tagName: 'div', attrs: ...}, null],     // V(0) TView\n   *   [{tagName: 'button', attrs ...}, null]    // V(1) TView\n   *\n   * If this TNode corresponds to an LContainer with a template (e.g. structural\n   * directive), the template's TView will be stored here.\n   *\n   * If this TNode corresponds to an element, tViews will be null .\n   */\n  tViews: TView|TView[]|null;\n\n  /**\n   * The next sibling node. Necessary so we can propagate through the root nodes of a view\n   * to insert them or remove them from the DOM.\n   */\n  next: TNode|null;\n\n  /**\n   * The next projected sibling. Since in Angular content projection works on the node-by-node basis\n   * the act of projecting nodes might change nodes relationship at the insertion point (target\n   * view). At the same time we need to keep initial relationship between nodes as expressed in\n   * content view.\n   */\n  projectionNext: TNode|null;\n\n  /**\n   * First child of the current node.\n   *\n   * For component nodes, the child will always be a ContentChild (in same view).\n   * For embedded view nodes, the child will be in their child view.\n   */\n  child: TNode|null;\n\n  /**\n   * Parent node (in the same view only).\n   *\n   * We need a reference to a node's parent so we can append the node to its parent's native\n   * element at the appropriate time.\n   *\n   * If the parent would be in a different view (e.g. component host), this property will be null.\n   * It's important that we don't try to cross component boundaries when retrieving the parent\n   * because the parent will change (e.g. index, attrs) depending on where the component was\n   * used (and thus shouldn't be stored on TNode). In these cases, we retrieve the parent through\n   * LView.node instead (which will be instance-specific).\n   *\n   * If this is an inline view node (V), the parent will be its container.\n   */\n  parent: TElementNode|TContainerNode|null;\n\n  /**\n   * List of projected TNodes for a given component host element OR index into the said nodes.\n   *\n   * For easier discussion assume this example:\n   * `<parent>`'s view definition:\n   * ```\n   * <child id=\"c1\">content1</child>\n   * <child id=\"c2\"><span>content2</span></child>\n   * ```\n   * `<child>`'s view definition:\n   * ```\n   * <ng-content id=\"cont1\"></ng-content>\n   * ```\n   *\n   * If `Array.isArray(projection)` then `TNode` is a host element:\n   * - `projection` stores the content nodes which are to be projected.\n   *    - The nodes represent categories defined by the selector: For example:\n   *      `<ng-content/><ng-content select=\"abc\"/>` would represent the heads for `<ng-content/>`\n   *      and `<ng-content select=\"abc\"/>` respectively.\n   *    - The nodes we store in `projection` are heads only, we used `.next` to get their\n   *      siblings.\n   *    - The nodes `.next` is sorted/rewritten as part of the projection setup.\n   *    - `projection` size is equal to the number of projections `<ng-content>`. The size of\n   *      `c1` will be `1` because `<child>` has only one `<ng-content>`.\n   * - we store `projection` with the host (`c1`, `c2`) rather than the `<ng-content>` (`cont1`)\n   *   because the same component (`<child>`) can be used in multiple locations (`c1`, `c2`) and as\n   *   a result have different set of nodes to project.\n   * - without `projection` it would be difficult to efficiently traverse nodes to be projected.\n   *\n   * If `typeof projection == 'number'` then `TNode` is a `<ng-content>` element:\n   * - `projection` is an index of the host's `projection`Nodes.\n   *   - This would return the first head node to project:\n   *     `getHost(currentTNode).projection[currentTNode.projection]`.\n   * - When projecting nodes the parent node retrieved may be a `<ng-content>` node, in which case\n   *   the process is recursive in nature.\n   *\n   * If `projection` is of type `RNode[][]` than we have a collection of native nodes passed as\n   * projectable nodes during dynamic component creation.\n   */\n  projection: (TNode|RNode[])[]|number|null;\n\n  /**\n   * A collection of all style bindings and/or static style values for an element.\n   *\n   * This field will be populated if and when:\n   *\n   * - There are one or more initial styles on an element (e.g. `<div style=\"width:200px\">`)\n   * - There are one or more style bindings on an element (e.g. `<div [style.width]=\"w\">`)\n   *\n   * If and when there are only initial styles (no bindings) then an instance of `StylingMapArray`\n   * will be used here. Otherwise an instance of `TStylingContext` will be created when there\n   * are one or more style bindings on an element.\n   *\n   * During element creation this value is likely to be populated with an instance of\n   * `StylingMapArray` and only when the bindings are evaluated (which happens during\n   * update mode) then it will be converted to a `TStylingContext` if any style bindings\n   * are encountered. If and when this happens then the existing `StylingMapArray` value\n   * will be placed into the initial styling slot in the newly created `TStylingContext`.\n   */\n  styles: StylingMapArray|TStylingContext|null;\n\n  /**\n   * A collection of all class bindings and/or static class values for an element.\n   *\n   * This field will be populated if and when:\n   *\n   * - There are one or more initial classes on an element (e.g. `<div class=\"one two three\">`)\n   * - There are one or more class bindings on an element (e.g. `<div [class.foo]=\"f\">`)\n   *\n   * If and when there are only initial classes (no bindings) then an instance of `StylingMapArray`\n   * will be used here. Otherwise an instance of `TStylingContext` will be created when there\n   * are one or more class bindings on an element.\n   *\n   * During element creation this value is likely to be populated with an instance of\n   * `StylingMapArray` and only when the bindings are evaluated (which happens during\n   * update mode) then it will be converted to a `TStylingContext` if any class bindings\n   * are encountered. If and when this happens then the existing `StylingMapArray` value\n   * will be placed into the initial styling slot in the newly created `TStylingContext`.\n   */\n  classes: StylingMapArray|TStylingContext|null;\n}\n\n/** Static data for an element  */\nexport interface TElementNode extends TNode {\n  /** Index in the data[] array */\n  index: number;\n  child: TElementNode|TTextNode|TElementContainerNode|TContainerNode|TProjectionNode|null;\n  /**\n   * Element nodes will have parents unless they are the first node of a component or\n   * embedded view (which means their parent is in a different view and must be\n   * retrieved using viewData[HOST_NODE]).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n\n  /**\n   * If this is a component TNode with projection, this will be an array of projected\n   * TNodes or native nodes (see TNode.projection for more info). If it's a regular element node or\n   * a component without projection, it will be null.\n   */\n  projection: (TNode|RNode[])[]|null;\n}\n\n/** Static data for a text node */\nexport interface TTextNode extends TNode {\n  /** Index in the data[] array */\n  index: number;\n  child: null;\n  /**\n   * Text nodes will have parents unless they are the first node of a component or\n   * embedded view (which means their parent is in a different view and must be\n   * retrieved using LView.node).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an LContainer */\nexport interface TContainerNode extends TNode {\n  /**\n   * Index in the data[] array.\n   *\n   * If it's -1, this is a dynamically created container node that isn't stored in\n   * data[] (e.g. when you inject ViewContainerRef) .\n   */\n  index: number;\n  child: null;\n\n  /**\n   * Container nodes will have parents unless:\n   *\n   * - They are the first node of a component or embedded view\n   * - They are dynamically created\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: TView|TView[]|null;\n  projection: null;\n}\n\n/** Static data for an <ng-container> */\nexport interface TElementContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: TElementNode|TTextNode|TContainerNode|TElementContainerNode|TProjectionNode|null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an ICU expression */\nexport interface TIcuContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: TElementNode|TTextNode|null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n  /**\n   * Indicates the current active case for an ICU expression.\n   * It is null when there is no active case.\n   */\n  activeCaseIndex: number|null;\n}\n\n/** Static data for a view  */\nexport interface TViewNode extends TNode {\n  /** If -1, it's a dynamically created view. Otherwise, it is the view block ID. */\n  index: number;\n  child: TElementNode|TTextNode|TElementContainerNode|TContainerNode|TProjectionNode|null;\n  parent: TContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an LProjectionNode  */\nexport interface TProjectionNode extends TNode {\n  /** Index in the data[] array */\n  child: null;\n  /**\n   * Projection nodes will have parents unless they are the first node of a component\n   * or embedded view (which means their parent is in a different view and must be\n   * retrieved using LView.node).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n\n  /** Index of the projection node. (See TNode.projection for more info.) */\n  projection: number;\n}\n\n/**\n * A union type representing all TNode types that can host a directive.\n */\nexport type TDirectiveHostNode = TElementNode | TContainerNode | TElementContainerNode;\n\n/**\n * This mapping is necessary so we can set input properties and output listeners\n * properly at runtime when property names are minified or aliased.\n *\n * Key: unminified / public input or output name\n * Value: array containing minified / internal name and related directive index\n *\n * The value must be an array to support inputs and outputs with the same name\n * on the same node.\n */\nexport type PropertyAliases = {\n  // This uses an object map because using the Map type would be too slow\n  [key: string]: PropertyAliasValue\n};\n\n/**\n * Store the runtime input or output names for all the directives.\n *\n * i+0: directive instance index\n * i+1: privateName\n *\n * e.g. [0, 'change-minified']\n */\nexport type PropertyAliasValue = (number | string)[];\n\n/**\n * This array contains information about input properties that\n * need to be set once from attribute data. It's ordered by\n * directive index (relative to element) so it's simple to\n * look up a specific directive's initial input data.\n *\n * Within each sub-array:\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * If a directive on a node does not have any input properties\n * that should be set from attributes, its index is set to null\n * to avoid a sparse array.\n *\n * e.g. [null, ['role-min', 'minified-input', 'button']]\n */\nexport type InitialInputData = (InitialInputs | null)[];\n\n/**\n * Used by InitialInputData to store input properties\n * that should be set once from attributes.\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * e.g. ['role-min', 'minified-input', 'button']\n */\nexport type InitialInputs = string[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Type representing a set of TNodes that can have local refs (`#foo`) placed on them.\n */\nexport type TNodeWithLocalRefs = TContainerNode | TElementNode | TElementContainerNode;\n\n/**\n * Type for a function that extracts a value for a local refs.\n * Example:\n * - `<div #nativeDivEl>` - `nativeDivEl` should point to the native `<div>` element;\n * - `<ng-template #tplRef>` - `tplRef` should point to the `TemplateRef` instance;\n */\nexport type LocalRefExtractor = (tNode: TNodeWithLocalRefs, currentView: LView) => any;\n","\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Expresses a single CSS Selector.\n *\n * Beginning of array\n * - First index: element name\n * - Subsequent odd indices: attr keys\n * - Subsequent even indices: attr values\n *\n * After SelectorFlags.CLASS flag\n * - Class name values\n *\n * SelectorFlags.NOT flag\n * - Changes the mode to NOT\n * - Can be combined with other flags to set the element / attr / class mode\n *\n * e.g. SelectorFlags.NOT | SelectorFlags.ELEMENT\n *\n * Example:\n * Original: `div.foo.bar[attr1=val1][attr2]`\n * Parsed: ['div', 'attr1', 'val1', 'attr2', '', SelectorFlags.CLASS, 'foo', 'bar']\n *\n * Original: 'div[attr1]:not(.foo[attr2])\n * Parsed: [\n *  'div', 'attr1', '',\n *  SelectorFlags.NOT | SelectorFlags.ATTRIBUTE 'attr2', '', SelectorFlags.CLASS, 'foo'\n * ]\n *\n * See more examples in node_selector_matcher_spec.ts\n */\nexport type CssSelector = (string | SelectorFlags)[];\n\n/**\n * A list of CssSelectors.\n *\n * A directive or component can have multiple selectors. This type is used for\n * directive defs so any of the selectors in the list will match that directive.\n *\n * Original: 'form, [ngForm]'\n * Parsed: [['form'], ['', 'ngForm', '']]\n */\nexport type CssSelectorList = CssSelector[];\n\n/**\n * List of slots for a projection. A slot can be either based on a parsed CSS selector\n * which will be used to determine nodes which are projected into that slot.\n *\n * When set to \"*\", the slot is reserved and can be used for multi-slot projection\n * using {@link ViewContainerRef#createComponent}. The last slot that specifies the\n * wildcard selector will retrieve all projectable nodes which do not match any selector.\n */\nexport type ProjectionSlots = (CssSelectorList | '*')[];\n\n/** Flags used to build up CssSelectors */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {assertDefined, assertNotEqual} from '../util/assert';\n\nimport {AttributeMarker, TAttributes, TNode, TNodeType, unusedValueExportToPlacateAjd as unused1} from './interfaces/node';\nimport {CssSelector, CssSelectorList, SelectorFlags, unusedValueExportToPlacateAjd as unused2} from './interfaces/projection';\nimport {isNameOnlyAttributeMarker} from './util/attrs_utils';\nimport {getInitialStylingValue} from './util/styling_utils';\n\nconst unusedValueToPlacateAjd = unused1 + unused2;\n\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n\nfunction isCssClassMatching(nodeClassAttrVal: string, cssClassToMatch: string): boolean {\n  const nodeClassesLen = nodeClassAttrVal.length;\n  // we lowercase the class attribute value to be able to match\n  // selectors without case-sensitivity\n  // (selectors are already in lowercase when generated)\n  const matchIndex = nodeClassAttrVal.toLowerCase().indexOf(cssClassToMatch);\n  const matchEndIdx = matchIndex + cssClassToMatch.length;\n  if (matchIndex === -1                                                  // no match\n      || (matchIndex > 0 && nodeClassAttrVal ![matchIndex - 1] !== ' ')  // no space before\n      ||\n      (matchEndIdx < nodeClassesLen && nodeClassAttrVal ![matchEndIdx] !== ' '))  // no space after\n  {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(\n    tNode: TNode, currentSelector: string, isProjectionMode: boolean): boolean {\n  const tagNameToCompare = tNode.type === TNodeType.Container && !isProjectionMode ?\n      NG_TEMPLATE_SELECTOR :\n      tNode.tagName;\n  return currentSelector === tagNameToCompare;\n}\n\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nexport function isNodeMatchingSelector(\n    tNode: TNode, selector: CssSelector, isProjectionMode: boolean): boolean {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n  let mode: SelectorFlags = SelectorFlags.ELEMENT;\n  const nodeAttrs = tNode.attrs || [];\n\n  // Find the index of first attribute that has no value, only a name.\n  const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\n\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = (current as number) | (mode & SelectorFlags.NOT);\n      continue;\n    }\n\n    if (skipToNextSelector) continue;\n\n    if (mode & SelectorFlags.ELEMENT) {\n      mode = SelectorFlags.ATTRIBUTE | mode & SelectorFlags.NOT;\n      if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) ||\n          current === '' && selector.length === 1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const selectorAttrValue = mode & SelectorFlags.CLASS ? current : selector[++i];\n\n      // special case for matching against classes when a tNode has been instantiated with\n      // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n      if ((mode & SelectorFlags.CLASS) && tNode.classes) {\n        if (!isCssClassMatching(\n                getInitialStylingValue(tNode.classes), selectorAttrValue as string)) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n        continue;\n      }\n\n      const isInlineTemplate =\n          tNode.type == TNodeType.Container && tNode.tagName !== NG_TEMPLATE_SELECTOR;\n      const attrName = (mode & SelectorFlags.CLASS) ? 'class' : current;\n      const attrIndexInNode =\n          findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate, isProjectionMode);\n\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue: string;\n        if (attrIndexInNode > nameOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode && assertNotEqual(\n                           nodeAttrs[attrIndexInNode], AttributeMarker.NamespaceURI,\n                           'We do not match directives on namespaced attributes');\n          // we lowercase the attribute value to be able to match\n          // selectors without case-sensitivity\n          // (selectors are already in lowercase when generated)\n          nodeAttrValue = (nodeAttrs[attrIndexInNode + 1] as string).toLowerCase();\n        }\n\n        const compareAgainstClassName = mode & SelectorFlags.CLASS ? nodeAttrValue : null;\n        if (compareAgainstClassName &&\n                !isCssClassMatching(compareAgainstClassName, selectorAttrValue as string) ||\n            mode & SelectorFlags.ATTRIBUTE && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n\n  return isPositive(mode) || skipToNextSelector;\n}\n\nfunction isPositive(mode: SelectorFlags): boolean {\n  return (mode & SelectorFlags.NOT) === 0;\n}\n\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(\n    name: string, attrs: TAttributes | null, isInlineTemplate: boolean,\n    isProjectionMode: boolean): number {\n  if (attrs === null) return -1;\n\n  let i = 0;\n\n  if (isProjectionMode || !isInlineTemplate) {\n    let bindingsMode = false;\n    while (i < attrs.length) {\n      const maybeAttrName = attrs[i];\n      if (maybeAttrName === name) {\n        return i;\n      } else if (\n          maybeAttrName === AttributeMarker.Bindings || maybeAttrName === AttributeMarker.I18n) {\n        bindingsMode = true;\n      } else if (\n          maybeAttrName === AttributeMarker.Classes || maybeAttrName === AttributeMarker.Styles) {\n        let value = attrs[++i];\n        // We should skip classes here because we have a separate mechanism for\n        // matching classes in projection mode.\n        while (typeof value === 'string') {\n          value = attrs[++i];\n        }\n        continue;\n      } else if (maybeAttrName === AttributeMarker.Template) {\n        // We do not care about Template attributes in this scenario.\n        break;\n      } else if (maybeAttrName === AttributeMarker.NamespaceURI) {\n        // Skip the whole namespaced attribute and value. This is by design.\n        i += 4;\n        continue;\n      }\n      // In binding mode there are only names, rather than name-value pairs.\n      i += bindingsMode ? 1 : 2;\n    }\n    // We did not match the attribute\n    return -1;\n  } else {\n    return matchTemplateAttribute(attrs, name);\n  }\n}\n\nexport function isNodeMatchingSelectorList(\n    tNode: TNode, selector: CssSelectorList, isProjectionMode: boolean = false): boolean {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function getProjectAsAttrValue(tNode: TNode): CssSelector|null {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(AttributeMarker.ProjectAs);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1] as CssSelector;\n    }\n  }\n  return null;\n}\n\nfunction getNameOnlyMarkerIndex(nodeAttrs: TAttributes) {\n  for (let i = 0; i < nodeAttrs.length; i++) {\n    const nodeAttr = nodeAttrs[i];\n    if (isNameOnlyAttributeMarker(nodeAttr)) {\n      return i;\n    }\n  }\n  return nodeAttrs.length;\n}\n\nfunction matchTemplateAttribute(attrs: TAttributes, name: string): number {\n  let i = attrs.indexOf(AttributeMarker.Template);\n  if (i > -1) {\n    i++;\n    while (i < attrs.length) {\n      if (attrs[i] === name) return i;\n      i++;\n    }\n  }\n  return -1;\n}\n\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nexport function isSelectorInSelectorList(selector: CssSelector, list: CssSelectorList): boolean {\n  selectorListLoop: for (let i = 0; i < list.length; i++) {\n    const currentSelectorInList = list[i];\n    if (selector.length !== currentSelectorInList.length) {\n      continue;\n    }\n    for (let j = 0; j < selector.length; j++) {\n      if (selector[j] !== currentSelectorInList[j]) {\n        continue selectorListLoop;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\nimport {RElement} from '../interfaces/renderer';\nimport {StylingMapArray} from '../interfaces/styling';\nimport {TEMPLATE_DIRECTIVE_INDEX} from '../util/styling_utils';\n\n/**\n * --------\n *\n * This file contains all state-based logic for styling in Angular.\n *\n * Styling in Angular is evaluated with a series of styling-specific\n * template instructions which are called one after another each time\n * change detection occurs in Angular.\n *\n * Styling makes use of various temporary, state-based variables between\n * instructions so that it can better cache and optimize its values.\n * These values are usually populated and cleared when an element is\n * exited in change detection (once all the instructions are run for\n * that element).\n *\n * To learn more about the algorithm see `TStylingContext`.\n *\n * --------\n */\n\n/**\n * Used as a state reference for update values between style/class binding instructions.\n *\n * In addition to storing the element and bit-mask related values, the state also\n * stores the `sourceIndex` value. The `sourceIndex` value is an incremented value\n * that identifies what \"source\" (i.e. the template, a specific directive by index or\n * component) is currently applying its styling bindings to the element.\n */\nexport interface StylingState {\n  /** The element that is currently being processed */\n  element: RElement|null;\n\n  /** The directive index that is currently active (`0` === template) */\n  directiveIndex: number;\n\n  /** The source (column) index that is currently active (`0` === template) */\n  sourceIndex: number;\n\n  /** The classes update bit mask value that is processed during each class binding */\n  classesBitMask: number;\n\n  /** The classes update bit index value that is processed during each class binding */\n  classesIndex: number;\n\n  /** The styles update bit mask value that is processed during each style binding */\n  stylesBitMask: number;\n\n  /** The styles update bit index value that is processed during each style binding */\n  stylesIndex: number;\n\n  /**\n   * The last class map that was applied (i.e. `[class]=\"x\"`).\n   *\n   * Note that this property is only populated when direct class values are applied\n   * (i.e. context resolution is not used).\n   *\n   * See `allowDirectStyling` for more info.\n  */\n  lastDirectClassMap: StylingMapArray|null;\n\n  /**\n   * The last style map that was applied (i.e. `[style]=\"x\"`)\n   *\n   * Note that this property is only populated when direct style values are applied\n   * (i.e. context resolution is not used).\n   *\n   * See `allowDirectStyling` for more info.\n  */\n  lastDirectStyleMap: StylingMapArray|null;\n}\n\n// these values will get filled in the very first time this is accessed...\nconst _state: StylingState = {\n  element: null,\n  directiveIndex: -1,\n  sourceIndex: -1,\n  classesBitMask: -1,\n  classesIndex: -1,\n  stylesBitMask: -1,\n  stylesIndex: -1,\n  lastDirectClassMap: null,\n  lastDirectStyleMap: null,\n};\n\nconst BIT_MASK_START_VALUE = 0;\n\n// the `0` start value is reserved for [map]-based entries\nconst INDEX_START_VALUE = 1;\n\n/**\n * Returns (or instantiates) the styling state for the given element.\n *\n * Styling state is accessed and processed each time a style or class binding\n * is evaluated.\n *\n * If and when the provided `element` doesn't match the current element in the\n * state then this means that styling was recently cleared or the element has\n * changed in change detection. In both cases the styling state is fully reset.\n *\n * If and when the provided `directiveIndex` doesn't match the current directive\n * index in the state then this means that a new source has introduced itself into\n * the styling code (or, in other words, another directive or component has started\n * to apply its styling host bindings to the element).\n */\nexport function getStylingState(element: RElement, directiveIndex: number): StylingState {\n  if (_state.element !== element) {\n    _state.element = element;\n    _state.directiveIndex = directiveIndex;\n    _state.sourceIndex = directiveIndex === TEMPLATE_DIRECTIVE_INDEX ? 0 : 1;\n    _state.classesBitMask = BIT_MASK_START_VALUE;\n    _state.classesIndex = INDEX_START_VALUE;\n    _state.stylesBitMask = BIT_MASK_START_VALUE;\n    _state.stylesIndex = INDEX_START_VALUE;\n    _state.lastDirectClassMap = null;\n    _state.lastDirectStyleMap = null;\n  } else if (_state.directiveIndex !== directiveIndex) {\n    _state.directiveIndex = directiveIndex;\n    _state.sourceIndex++;\n  }\n  return _state;\n}\n\n/**\n * Clears the styling state so that it can be used by another element's styling code.\n */\nexport function resetStylingState() {\n  _state.element = null;\n}\n","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\nimport {SafeValue, unwrapSafeValue} from '../../sanitization/bypass';\nimport {StyleSanitizeFn, StyleSanitizeMode} from '../../sanitization/style_sanitizer';\nimport {global} from '../../util/global';\nimport {TNodeFlags} from '../interfaces/node';\nimport {ProceduralRenderer3, RElement, Renderer3, RendererStyleFlags3, isProceduralRenderer} from '../interfaces/renderer';\nimport {ApplyStylingFn, LStylingData, StylingMapArray, StylingMapArrayIndex, StylingMapsSyncMode, SyncStylingMapsFn, TStylingContext, TStylingContextIndex, TStylingContextPropConfigFlags, TStylingNode} from '../interfaces/styling';\nimport {NO_CHANGE} from '../tokens';\nimport {DEFAULT_BINDING_INDEX, DEFAULT_BINDING_VALUE, DEFAULT_GUARD_MASK_VALUE, MAP_BASED_ENTRY_PROP_NAME, TEMPLATE_DIRECTIVE_INDEX, concatString, forceStylesAsString, getBindingValue, getDefaultValue, getGuardMask, getInitialStylingValue, getMapProp, getMapValue, getProp, getPropValuesStartPosition, getStylingMapArray, getTotalSources, getValue, getValuesCount, hasConfig, hasValueChanged, isHostStylingActive, isSanitizationRequired, isStylingMapArray, isStylingValueDefined, normalizeIntoStylingMap, patchConfig, setDefaultValue, setGuardMask, setMapAsDirty, setValue} from '../util/styling_utils';\n\nimport {getStylingState, resetStylingState} from './state';\n\nconst VALUE_IS_EXTERNALLY_MODIFIED = {};\n\n/**\n * --------\n *\n * This file contains the core logic for styling in Angular.\n *\n * All styling bindings (i.e. `[style]`, `[style.prop]`, `[class]` and `[class.name]`)\n * will have their values be applied through the logic in this file.\n *\n * When a binding is encountered (e.g. `<div [style.width]=\"w\">`) then\n * the binding data will be populated into a `TStylingContext` data-structure.\n * There is only one `TStylingContext` per `TStylingNode` and each element instance\n * will update its style/class binding values in concert with the styling\n * context.\n *\n * To learn more about the algorithm see `TStylingContext`.\n *\n * --------\n */\n\n/**\n * The guard/update mask bit index location for map-based bindings.\n *\n * All map-based bindings (i.e. `[style]` and `[class]` )\n */\nconst STYLING_INDEX_FOR_MAP_BINDING = 0;\n\n/**\n * Visits a class-based binding and updates the new value (if changed).\n *\n * This function is called each time a class-based styling instruction\n * is executed. It's important that it's always called (even if the value\n * has not changed) so that the inner counter index value is incremented.\n * This way, each instruction is always guaranteed to get the same counter\n * state each time it's called (which then allows the `TStylingContext`\n * and the bit mask values to be in sync).\n */\nexport function updateClassViaContext(\n    context: TStylingContext, tNode: TStylingNode, data: LStylingData, element: RElement,\n    directiveIndex: number, prop: string | null, bindingIndex: number,\n    value: boolean | string | null | undefined | StylingMapArray | NO_CHANGE, forceUpdate: boolean,\n    firstUpdatePass: boolean): boolean {\n  const isMapBased = !prop;\n  const state = getStylingState(element, directiveIndex);\n  const countIndex = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.classesIndex++;\n\n  // even if the initial value is a `NO_CHANGE` value (e.g. interpolation or [ngClass])\n  // then we still need to register the binding within the context so that the context\n  // is aware of the binding even if things change after the first update pass.\n  if (firstUpdatePass || value !== NO_CHANGE) {\n    const updated = updateBindingData(\n        context, tNode, data, countIndex, state.sourceIndex, prop, bindingIndex, value, forceUpdate,\n        false, firstUpdatePass, true);\n    if (updated || forceUpdate) {\n      // We flip the bit in the bitMask to reflect that the binding\n      // at the `index` slot has changed. This identifies to the flushing\n      // phase that the bindings for this particular CSS class need to be\n      // applied again because on or more of the bindings for the CSS\n      // class have changed.\n      state.classesBitMask |= 1 << countIndex;\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Visits a style-based binding and updates the new value (if changed).\n *\n * This function is called each time a style-based styling instruction\n * is executed. It's important that it's always called (even if the value\n * has not changed) so that the inner counter index value is incremented.\n * This way, each instruction is always guaranteed to get the same counter\n * state each time it's called (which then allows the `TStylingContext`\n * and the bit mask values to be in sync).\n */\nexport function updateStyleViaContext(\n    context: TStylingContext, tNode: TStylingNode, data: LStylingData, element: RElement,\n    directiveIndex: number, prop: string | null, bindingIndex: number,\n    value: string | number | SafeValue | null | undefined | StylingMapArray | NO_CHANGE,\n    sanitizer: StyleSanitizeFn | null, forceUpdate: boolean, firstUpdatePass: boolean): boolean {\n  const isMapBased = !prop;\n  const state = getStylingState(element, directiveIndex);\n  const countIndex = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.stylesIndex++;\n\n  // even if the initial value is a `NO_CHANGE` value (e.g. interpolation or [ngStyle])\n  // then we still need to register the binding within the context so that the context\n  // is aware of the binding even if things change after the first update pass.\n  if (firstUpdatePass || value !== NO_CHANGE) {\n    const sanitizationRequired = isMapBased ?\n        true :\n        (sanitizer ? sanitizer(prop !, null, StyleSanitizeMode.ValidateProperty) : false);\n    const updated = updateBindingData(\n        context, tNode, data, countIndex, state.sourceIndex, prop, bindingIndex, value, forceUpdate,\n        sanitizationRequired, firstUpdatePass, false);\n    if (updated || forceUpdate) {\n      // We flip the bit in the bitMask to reflect that the binding\n      // at the `index` slot has changed. This identifies to the flushing\n      // phase that the bindings for this particular property need to be\n      // applied again because on or more of the bindings for the CSS\n      // property have changed.\n      state.stylesBitMask |= 1 << countIndex;\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Called each time a binding value has changed within the provided `TStylingContext`.\n *\n * This function is designed to be called from `updateStyleBinding` and `updateClassBinding`.\n * If called during the first update pass, the binding will be registered in the context.\n *\n * This function will also update binding slot in the provided `LStylingData` with the\n * new binding entry (if it has changed).\n *\n * @returns whether or not the binding value was updated in the `LStylingData`.\n */\nfunction updateBindingData(\n    context: TStylingContext, tNode: TStylingNode, data: LStylingData, counterIndex: number,\n    sourceIndex: number, prop: string | null, bindingIndex: number,\n    value: string | SafeValue | number | boolean | null | undefined | StylingMapArray,\n    forceUpdate: boolean, sanitizationRequired: boolean, firstUpdatePass: boolean,\n    isClassBased: boolean): boolean {\n  const hostBindingsMode = isHostStylingActive(sourceIndex);\n  const hostBindingsFlag =\n      isClassBased ? TNodeFlags.hasHostClassBindings : TNodeFlags.hasHostStyleBindings;\n  if (firstUpdatePass) {\n    // this will only happen during the first update pass of the\n    // context. The reason why we can't use `tView.firstCreatePass`\n    // here is because its not guaranteed to be true when the first\n    // update pass is executed (remember that all styling instructions\n    // are run in the update phase, and, as a result, are no more\n    // styling instructions that are run in the creation phase).\n    registerBinding(\n        context, tNode, counterIndex, sourceIndex, prop, bindingIndex, sanitizationRequired,\n        isClassBased);\n  }\n\n  const changed = forceUpdate || hasValueChanged(data[bindingIndex], value);\n  if (changed) {\n    setValue(data, bindingIndex, value);\n    const doSetValuesAsStale =\n        hasConfig(tNode, hostBindingsFlag) && !hostBindingsMode && (prop ? !value : true);\n    if (doSetValuesAsStale) {\n      renderHostBindingsAsStale(context, tNode, data, prop, isClassBased);\n    }\n  }\n  return changed;\n}\n\n/**\n * Iterates over all host-binding values for the given `prop` value in the context and sets their\n * corresponding binding values to `null`.\n *\n * Whenever a template binding changes its value to `null`, all host-binding values should be\n * re-applied\n * to the element when the host bindings are evaluated. This may not always happen in the event\n * that none of the bindings changed within the host bindings code. For this reason this function\n * is expected to be called each time a template binding becomes falsy or when a map-based template\n * binding changes.\n */\nfunction renderHostBindingsAsStale(\n    context: TStylingContext, tNode: TStylingNode, data: LStylingData, prop: string | null,\n    isClassBased: boolean): void {\n  const valuesCount = getValuesCount(context);\n\n  const hostBindingsFlag =\n      isClassBased ? TNodeFlags.hasHostClassBindings : TNodeFlags.hasHostStyleBindings;\n  if (prop !== null && hasConfig(tNode, hostBindingsFlag)) {\n    const itemsPerRow = TStylingContextIndex.BindingsStartOffset + valuesCount;\n\n    let i = TStylingContextIndex.ValuesStartPosition;\n    let found = false;\n    while (i < context.length) {\n      if (getProp(context, i) === prop) {\n        found = true;\n        break;\n      }\n      i += itemsPerRow;\n    }\n\n    if (found) {\n      const bindingsStart = i + TStylingContextIndex.BindingsStartOffset;\n      const valuesStart = bindingsStart + 1;  // the first column is template bindings\n      const valuesEnd = bindingsStart + valuesCount - 1;\n\n      for (let i = valuesStart; i < valuesEnd; i++) {\n        const bindingIndex = context[i] as number;\n        if (bindingIndex !== 0) {\n          setValue(data, bindingIndex, null);\n        }\n      }\n    }\n  }\n\n  const mapBindingsFlag =\n      isClassBased ? TNodeFlags.hasClassMapBindings : TNodeFlags.hasStyleMapBindings;\n  if (hasConfig(tNode, mapBindingsFlag)) {\n    const bindingsStart =\n        TStylingContextIndex.ValuesStartPosition + TStylingContextIndex.BindingsStartOffset;\n    const valuesStart = bindingsStart + 1;  // the first column is template bindings\n    const valuesEnd = bindingsStart + valuesCount - 1;\n    for (let i = valuesStart; i < valuesEnd; i++) {\n      const stylingMap = getValue<StylingMapArray>(data, context[i] as number);\n      if (stylingMap) {\n        setMapAsDirty(stylingMap);\n      }\n    }\n  }\n}\n\n/**\n * Registers the provided binding (prop + bindingIndex) into the context.\n *\n * It is needed because it will either update or insert a styling property\n * into the context at the correct spot.\n *\n * When called, one of two things will happen:\n *\n * 1) If the property already exists in the context then it will just add\n *    the provided `bindingValue` to the end of the binding sources region\n *    for that particular property.\n *\n *    - If the binding value is a number then it will be added as a new\n *      binding index source next to the other binding sources for the property.\n *\n *    - Otherwise, if the binding value is a string/boolean/null type then it will\n *      replace the default value for the property if the default value is `null`.\n *\n * 2) If the property does not exist then it will be inserted into the context.\n *    The styling context relies on all properties being stored in alphabetical\n *    order, so it knows exactly where to store it.\n *\n *    When inserted, a default `null` value is created for the property which exists\n *    as the default value for the binding. If the bindingValue property is inserted\n *    and it is either a string, number or null value then that will replace the default\n *    value.\n *\n * Note that this function is also used for map-based styling bindings. They are treated\n * much the same as prop-based bindings, but, their property name value is set as `[MAP]`.\n */\nexport function registerBinding(\n    context: TStylingContext, tNode: TStylingNode, countId: number, sourceIndex: number,\n    prop: string | null, bindingValue: number | null | string | boolean,\n    sanitizationRequired: boolean, isClassBased: boolean): void {\n  let found = false;\n  prop = prop || MAP_BASED_ENTRY_PROP_NAME;\n\n  let totalSources = getTotalSources(context);\n\n  // if a new source is detected then a new column needs to be allocated into\n  // the styling context. The column is basically a new allocation of binding\n  // sources that will be available to each property.\n  while (totalSources <= sourceIndex) {\n    addNewSourceColumn(context);\n    totalSources++;\n  }\n\n  const collisionFlag =\n      isClassBased ? TNodeFlags.hasDuplicateClassBindings : TNodeFlags.hasDuplicateStyleBindings;\n  const isBindingIndexValue = typeof bindingValue === 'number';\n  const entriesPerRow = TStylingContextIndex.BindingsStartOffset + getValuesCount(context);\n  let i = TStylingContextIndex.ValuesStartPosition;\n\n  // all style/class bindings are sorted by property name\n  while (i < context.length) {\n    const p = getProp(context, i);\n    if (prop <= p) {\n      if (prop < p) {\n        allocateNewContextEntry(context, i, prop, sanitizationRequired);\n      } else if (isBindingIndexValue) {\n        patchConfig(tNode, collisionFlag);\n      }\n      addBindingIntoContext(context, i, bindingValue, countId, sourceIndex);\n      found = true;\n      break;\n    }\n    i += entriesPerRow;\n  }\n\n  if (!found) {\n    allocateNewContextEntry(context, context.length, prop, sanitizationRequired);\n    addBindingIntoContext(context, i, bindingValue, countId, sourceIndex);\n  }\n}\n\n/**\n * Inserts a new row into the provided `TStylingContext` and assigns the provided `prop` value as\n * the property entry.\n */\nfunction allocateNewContextEntry(\n    context: TStylingContext, index: number, prop: string, sanitizationRequired?: boolean): void {\n  const config = sanitizationRequired ? TStylingContextPropConfigFlags.SanitizationRequired :\n                                        TStylingContextPropConfigFlags.Default;\n  context.splice(\n      index, 0,\n      config,                    // 1) config value\n      DEFAULT_GUARD_MASK_VALUE,  // 2) template bit mask\n      DEFAULT_GUARD_MASK_VALUE,  // 3) host bindings bit mask\n      prop,                      // 4) prop value (e.g. `width`, `myClass`, etc...)\n      );\n\n  index += 4;  // the 4 values above\n\n  // 5...) default binding index for the template value\n  // depending on how many sources already exist in the context,\n  // multiple default index entries may need to be inserted for\n  // the new value in the context.\n  const totalBindingsPerEntry = getTotalSources(context);\n  for (let i = 0; i < totalBindingsPerEntry; i++) {\n    context.splice(index, 0, DEFAULT_BINDING_INDEX);\n    index++;\n  }\n\n  // 6) default binding value for the new entry\n  context.splice(index, 0, DEFAULT_BINDING_VALUE);\n}\n\n/**\n * Inserts a new binding value into a styling property tuple in the `TStylingContext`.\n *\n * A bindingValue is inserted into a context during the first update pass\n * of a template or host bindings function. When this occurs, two things\n * happen:\n *\n * - If the bindingValue value is a number then it is treated as a bindingIndex\n *   value (a index in the `LView`) and it will be inserted next to the other\n *   binding index entries.\n *\n * - Otherwise the binding value will update the default value for the property\n *   and this will only happen if the default value is `null`.\n */\nfunction addBindingIntoContext(\n    context: TStylingContext, index: number, bindingValue: number | string | boolean | null,\n    bitIndex: number, sourceIndex: number) {\n  if (typeof bindingValue === 'number') {\n    const hostBindingsMode = isHostStylingActive(sourceIndex);\n    const cellIndex = index + TStylingContextIndex.BindingsStartOffset + sourceIndex;\n    context[cellIndex] = bindingValue;\n    const updatedBitMask = getGuardMask(context, index, hostBindingsMode) | (1 << bitIndex);\n    setGuardMask(context, index, updatedBitMask, hostBindingsMode);\n  } else if (bindingValue !== null && getDefaultValue(context, index) === null) {\n    setDefaultValue(context, index, bindingValue);\n  }\n}\n\n/**\n * Registers a new column into the provided `TStylingContext`.\n *\n * If and when a new source is detected then a new column needs to\n * be allocated into the styling context. The column is basically\n * a new allocation of binding sources that will be available to each\n * property.\n *\n * Each column that exists in the styling context resembles a styling\n * source. A styling source an either be the template or one or more\n * components or directives all containing styling host bindings.\n */\nfunction addNewSourceColumn(context: TStylingContext): void {\n  // we use -1 here because we want to insert right before the last value (the default value)\n  const insertOffset = TStylingContextIndex.BindingsStartOffset + getValuesCount(context) - 1;\n\n  let index = TStylingContextIndex.ValuesStartPosition;\n  while (index < context.length) {\n    index += insertOffset;\n    context.splice(index++, 0, DEFAULT_BINDING_INDEX);\n\n    // the value was inserted just before the default value, but the\n    // next entry in the context starts just after it. Therefore++.\n    index++;\n  }\n  context[TStylingContextIndex.TotalSourcesPosition]++;\n}\n\n/**\n * Applies all pending style and class bindings to the provided element.\n *\n * This function will attempt to flush styling via the provided `classesContext`\n * and `stylesContext` context values. This function is designed to be run from\n * the internal `stylingApply` function (which is scheduled to run at the very\n * end of change detection for an element if one or more style/class bindings\n * were processed) and will rely on any state values that are set from when\n * any of the styling bindings executed.\n *\n * This function is designed to be called twice: one when change detection has\n * processed an element within the template bindings (i.e. just as `advance()`\n * is called) and when host bindings have been processed. In both cases the\n * styles and classes in both contexts will be applied to the element, but the\n * algorithm will selectively decide which bindings to run depending on the\n * columns in the context. The provided `directiveIndex` value will help the\n * algorithm determine which bindings to apply: either the template bindings or\n * the host bindings (see `applyStylingToElement` for more information).\n *\n * Note that once this function is called all temporary styling state data\n * (i.e. the `bitMask` and `counter` values for styles and classes will be cleared).\n */\nexport function flushStyling(\n    renderer: Renderer3 | ProceduralRenderer3 | null, data: LStylingData, tNode: TStylingNode,\n    classesContext: TStylingContext | null, stylesContext: TStylingContext | null,\n    element: RElement, directiveIndex: number, styleSanitizer: StyleSanitizeFn | null,\n    firstUpdatePass: boolean): void {\n  ngDevMode && ngDevMode.flushStyling++;\n\n  const state = getStylingState(element, directiveIndex);\n  const hostBindingsMode = isHostStylingActive(state.sourceIndex);\n\n  if (stylesContext) {\n    firstUpdatePass && syncContextInitialStyling(stylesContext, tNode, false);\n\n    if (state.stylesBitMask !== 0) {\n      applyStylingViaContext(\n          stylesContext, tNode, renderer, element, data, state.stylesBitMask, setStyle,\n          styleSanitizer, hostBindingsMode, false);\n    }\n  }\n\n  if (classesContext) {\n    firstUpdatePass && syncContextInitialStyling(classesContext, tNode, true);\n\n    if (state.classesBitMask !== 0) {\n      applyStylingViaContext(\n          classesContext, tNode, renderer, element, data, state.classesBitMask, setClass, null,\n          hostBindingsMode, true);\n    }\n  }\n\n  resetStylingState();\n}\n\n/**\n * Registers all static styling values into the context as default values.\n *\n * Static styles are stored on the `tNode.styles` and `tNode.classes`\n * properties as instances of `StylingMapArray`. When an instance of\n * `TStylingContext` is assigned to `tNode.styles` and `tNode.classes`\n * then the existing initial styling values are copied into the the\n * `InitialStylingValuePosition` slot.\n *\n * Because all static styles/classes are collected and registered on\n * the initial styling array each time a directive is instantiated,\n * the context may not yet know about the static values. When this\n * function is called it will copy over all the static style/class\n * values from the initial styling array into the context as default\n * values for each of the matching entries in the context.\n *\n * Let's imagine the following example:\n *\n * ```html\n * <div style=\"color:red\"\n *     [style.color]=\"myColor\"\n *     dir-that-has-static-height>\n *   ...\n * </div>\n * ```\n *\n * When the code above is processed, the underlying element/styling\n * instructions will create an instance of `TStylingContext` for\n * the `tNode.styles` property. Here's what that looks like:\n *\n * ```typescript\n * tNode.styles = [\n *   // ...\n *   // initial styles\n *   ['color:red; height:200px', 'color', 'red', 'height', '200px'],\n *\n *   0, 0b1, 0b0, 'color', 20, null, // [style.color] binding\n * ]\n * ```\n *\n * After this function is called it will balance out the context with\n * the static `color` and `height` values and set them as defaults within\n * the context:\n *\n * ```typescript\n * tNode.styles = [\n *   // ...\n *   // initial styles\n *   ['color:red; height:200px', 'color', 'red', 'height', '200px'],\n *\n *   0, 0b1, 0b0, 'color', 20, 'red',\n *   0, 0b0, 0b0, 'height', 0, '200px',\n * ]\n * ```\n */\nfunction syncContextInitialStyling(\n    context: TStylingContext, tNode: TStylingNode, isClassBased: boolean): void {\n  // the TStylingContext always has initial style/class values which are\n  // stored in styling array format.\n  updateInitialStylingOnContext(context, tNode, getStylingMapArray(context) !, isClassBased);\n}\n\n/**\n * Registers all initial styling entries into the provided context.\n *\n * This function will iterate over all entries in the provided `initialStyling` ar}ray and register\n * them as default (initial) values in the provided context. Initial styling values in a context are\n * the default values that are to be applied unless overwritten by a binding.\n *\n * The reason why this function exists and isn't a part of the context construction is because\n * host binding is evaluated at a later stage after the element is created. This means that\n * if a directive or component contains any initial styling code (i.e. `<div class=\"foo\">`)\n * then that initial styling data can only be applied once the styling for that element\n * is first applied (at the end of the update phase). Once that happens then the context will\n * update itself with the complete initial styling for the element.\n */\nfunction updateInitialStylingOnContext(\n    context: TStylingContext, tNode: TStylingNode, initialStyling: StylingMapArray,\n    isClassBased: boolean): void {\n  // `-1` is used here because all initial styling data is not a apart\n  // of a binding (since it's static)\n  const COUNT_ID_FOR_STYLING = -1;\n\n  let hasInitialStyling = false;\n  for (let i = StylingMapArrayIndex.ValuesStartPosition; i < initialStyling.length;\n       i += StylingMapArrayIndex.TupleSize) {\n    const value = getMapValue(initialStyling, i);\n    if (value) {\n      const prop = getMapProp(initialStyling, i);\n      registerBinding(context, tNode, COUNT_ID_FOR_STYLING, 0, prop, value, false, isClassBased);\n      hasInitialStyling = true;\n    }\n  }\n\n  if (hasInitialStyling) {\n    patchConfig(tNode, TNodeFlags.hasInitialStyling);\n  }\n}\n\n/**\n * Runs through the provided styling context and applies each value to\n * the provided element (via the renderer) if one or more values are present.\n *\n * This function will iterate over all entries present in the provided\n * `TStylingContext` array (both prop-based and map-based bindings).-\n *\n * Each entry, within the `TStylingContext` array, is stored alphabetically\n * and this means that each prop/value entry will be applied in order\n * (so long as it is marked dirty in the provided `bitMask` value).\n *\n * If there are any map-based entries present (which are applied to the\n * element via the `[style]` and `[class]` bindings) then those entries\n * will be applied as well. However, the code for that is not a part of\n * this function. Instead, each time a property is visited, then the\n * code below will call an external function called `stylingMapsSyncFn`\n * and, if present, it will keep the application of styling values in\n * map-based bindings up to sync with the application of prop-based\n * bindings.\n *\n * Visit `styling/map_based_bindings.ts` to learn more about how the\n * algorithm works for map-based styling bindings.\n *\n * Note that this function is not designed to be called in isolation (use\n * the `flushStyling` function so that it can call this function for both\n * the styles and classes contexts).\n */\nexport function applyStylingViaContext(\n    context: TStylingContext, tNode: TStylingNode, renderer: Renderer3 | ProceduralRenderer3 | null,\n    element: RElement, bindingData: LStylingData, bitMaskValue: number | boolean,\n    applyStylingFn: ApplyStylingFn, sanitizer: StyleSanitizeFn | null, hostBindingsMode: boolean,\n    isClassBased: boolean): void {\n  const bitMask = normalizeBitMaskValue(bitMaskValue);\n\n  let stylingMapsSyncFn: SyncStylingMapsFn|null = null;\n  let applyAllValues = false;\n  const mapBindingsFlag =\n      isClassBased ? TNodeFlags.hasClassMapBindings : TNodeFlags.hasStyleMapBindings;\n  if (hasConfig(tNode, mapBindingsFlag)) {\n    stylingMapsSyncFn = getStylingMapsSyncFn();\n    const mapsGuardMask =\n        getGuardMask(context, TStylingContextIndex.ValuesStartPosition, hostBindingsMode);\n    applyAllValues = (bitMask & mapsGuardMask) !== 0;\n  }\n\n  const valuesCount = getValuesCount(context);\n  let totalBindingsToVisit = 1;\n  let mapsMode =\n      applyAllValues ? StylingMapsSyncMode.ApplyAllValues : StylingMapsSyncMode.TraverseValues;\n  if (hostBindingsMode) {\n    mapsMode |= StylingMapsSyncMode.RecurseInnerMaps;\n    totalBindingsToVisit = valuesCount - 1;\n  }\n\n  let i = getPropValuesStartPosition(context, tNode, isClassBased);\n  while (i < context.length) {\n    const guardMask = getGuardMask(context, i, hostBindingsMode);\n    if (bitMask & guardMask) {\n      let valueApplied = false;\n      const prop = getProp(context, i);\n      const defaultValue = getDefaultValue(context, i);\n\n      // Part 1: Visit the `[styling.prop]` value\n      for (let j = 0; j < totalBindingsToVisit; j++) {\n        const bindingIndex = getBindingValue(context, i, j) as number;\n        if (!valueApplied && bindingIndex !== 0) {\n          const value = getValue(bindingData, bindingIndex);\n          if (isStylingValueDefined(value)) {\n            const checkValueOnly = hostBindingsMode && j === 0;\n            if (!checkValueOnly) {\n              const finalValue = sanitizer && isSanitizationRequired(context, i) ?\n                  sanitizer(prop, value, StyleSanitizeMode.SanitizeOnly) :\n                  unwrapSafeValue(value);\n              applyStylingFn(renderer, element, prop, finalValue, bindingIndex);\n            }\n            valueApplied = true;\n          }\n        }\n\n        // Part 2: Visit the `[style]` or `[class]` map-based value\n        if (stylingMapsSyncFn) {\n          // determine whether or not to apply the target property or to skip it\n          let mode = mapsMode | (valueApplied ? StylingMapsSyncMode.SkipTargetProp :\n                                                StylingMapsSyncMode.ApplyTargetProp);\n\n          // the first column in the context (when `j == 0`) is special-cased for\n          // template bindings. If and when host bindings are being processed then\n          // the first column will still be iterated over, but the values will only\n          // be checked against (not applied). If and when this happens we need to\n          // notify the map-based syncing code to know not to apply the values it\n          // comes across in the very first map-based binding (which is also located\n          // in column zero).\n          if (hostBindingsMode && j === 0) {\n            mode |= StylingMapsSyncMode.CheckValuesOnly;\n          }\n\n          const valueAppliedWithinMap = stylingMapsSyncFn(\n              context, renderer, element, bindingData, j, applyStylingFn, sanitizer, mode, prop,\n              defaultValue);\n          valueApplied = valueApplied || valueAppliedWithinMap;\n        }\n      }\n\n      // Part 3: apply the default value (e.g. `<div style=\"width:200\">` => `200px` gets applied)\n      // if the value has not yet been applied then a truthy value does not exist in the\n      // prop-based or map-based bindings code. If and when this happens, just apply the\n      // default value (even if the default value is `null`).\n      if (!valueApplied) {\n        applyStylingFn(renderer, element, prop, defaultValue);\n      }\n    }\n\n    i += TStylingContextIndex.BindingsStartOffset + valuesCount;\n  }\n\n  // the map-based styling entries may have not applied all their\n  // values. For this reason, one more call to the sync function\n  // needs to be issued at the end.\n  if (stylingMapsSyncFn) {\n    if (hostBindingsMode) {\n      mapsMode |= StylingMapsSyncMode.CheckValuesOnly;\n    }\n    stylingMapsSyncFn(\n        context, renderer, element, bindingData, 0, applyStylingFn, sanitizer, mapsMode);\n  }\n}\n\n/**\n * Applies the provided styling map to the element directly (without context resolution).\n *\n * This function is designed to be run from the styling instructions and will be called\n * automatically. This function is intended to be used for performance reasons in the\n * event that there is no need to apply styling via context resolution.\n *\n * This function has three different cases that can occur (for each item in the map):\n *\n * - Case 1: Attempt to apply the current value in the map to the element (if it's `non null`).\n *\n * - Case 2: If a map value fails to be applied then the algorithm will find a matching entry in\n *           the initial values present in the context and attempt to apply that.\n *\n * - Default Case: If the initial value cannot be applied then a default value of `null` will be\n *                 applied (which will remove the style/class value from the element).\n *\n * See `allowDirectStylingApply` to learn the logic used to determine whether any style/class\n * bindings can be directly applied.\n *\n * @returns whether or not the styling map was applied to the element.\n */\nexport function applyStylingMapDirectly(\n    renderer: any, context: TStylingContext, tNode: TStylingNode, element: RElement,\n    data: LStylingData, bindingIndex: number, value: {[key: string]: any} | string | null,\n    isClassBased: boolean, sanitizer: StyleSanitizeFn | null, forceUpdate: boolean,\n    bindingValueContainsInitial: boolean): void {\n  const oldValue = getValue(data, bindingIndex);\n  if (forceUpdate || hasValueChanged(oldValue, value)) {\n    const hasInitial = hasConfig(tNode, TNodeFlags.hasInitialStyling);\n    const initialValue =\n        hasInitial && !bindingValueContainsInitial ? getInitialStylingValue(context) : null;\n    setValue(data, bindingIndex, value);\n\n    // the cached value is the last snapshot of the style or class\n    // attribute value and is used in the if statement below to\n    // keep track of internal/external changes.\n    const cachedValueIndex = bindingIndex + 1;\n    let cachedValue = getValue(data, cachedValueIndex);\n    if (cachedValue === NO_CHANGE) {\n      cachedValue = initialValue;\n    }\n    cachedValue = typeof cachedValue !== 'string' ? '' : cachedValue;\n\n    // If a class/style value was modified externally then the styling\n    // fast pass cannot guarantee that the external values are retained.\n    // When this happens, the algorithm will bail out and not write to\n    // the style or className attribute directly.\n    const propBindingsFlag =\n        isClassBased ? TNodeFlags.hasClassPropBindings : TNodeFlags.hasStylePropBindings;\n    let writeToAttrDirectly = !hasConfig(tNode, propBindingsFlag);\n    if (writeToAttrDirectly &&\n        checkIfExternallyModified(element as HTMLElement, cachedValue, isClassBased)) {\n      writeToAttrDirectly = false;\n      if (oldValue !== VALUE_IS_EXTERNALLY_MODIFIED) {\n        // direct styling will reset the attribute entirely each time,\n        // and, for this reason, if the algorithm decides it cannot\n        // write to the class/style attributes directly then it must\n        // reset all the previous style/class values before it starts\n        // to apply values in the non-direct way.\n        removeStylingValues(renderer, element, oldValue, isClassBased);\n\n        // this will instruct the algorithm not to apply class or style\n        // values directly anymore.\n        setValue(data, cachedValueIndex, VALUE_IS_EXTERNALLY_MODIFIED);\n      }\n    }\n\n    if (writeToAttrDirectly) {\n      const initialValue =\n          hasInitial && !bindingValueContainsInitial ? getInitialStylingValue(context) : null;\n      const valueToApply =\n          writeStylingValueDirectly(renderer, element, value, isClassBased, initialValue);\n      setValue(data, cachedValueIndex, valueToApply || null);\n    } else {\n      const applyFn = isClassBased ? setClass : setStyle;\n      const map = normalizeIntoStylingMap(oldValue, value, !isClassBased);\n      const initialStyles = hasInitial ? getStylingMapArray(context) : null;\n\n      for (let i = StylingMapArrayIndex.ValuesStartPosition; i < map.length;\n           i += StylingMapArrayIndex.TupleSize) {\n        const prop = getMapProp(map, i);\n        const value = getMapValue(map, i);\n\n        // case 1: apply the map value (if it exists)\n        let applied =\n            applyStylingValue(renderer, element, prop, value, applyFn, bindingIndex, sanitizer);\n\n        // case 2: apply the initial value (if it exists)\n        if (!applied && initialStyles) {\n          applied = findAndApplyMapValue(\n              renderer, element, applyFn, initialStyles, prop, bindingIndex, sanitizer);\n        }\n\n        // default case: apply `null` to remove the value\n        if (!applied) {\n          applyFn(renderer, element, prop, null, bindingIndex);\n        }\n      }\n\n      const state = getStylingState(element, TEMPLATE_DIRECTIVE_INDEX);\n      if (isClassBased) {\n        state.lastDirectClassMap = map;\n      } else {\n        state.lastDirectStyleMap = map;\n      }\n    }\n  }\n}\n\nexport function writeStylingValueDirectly(\n    renderer: any, element: RElement, value: {[key: string]: any} | string | null,\n    isClassBased: boolean, initialValue: string | null): string {\n  let valueToApply: string;\n  if (isClassBased) {\n    valueToApply = typeof value === 'string' ? value : objectToClassName(value);\n    if (initialValue !== null) {\n      valueToApply = concatString(initialValue, valueToApply, ' ');\n    }\n    setClassName(renderer, element, valueToApply);\n  } else {\n    valueToApply = forceStylesAsString(value, true);\n    if (initialValue !== null) {\n      valueToApply = initialValue + ';' + valueToApply;\n    }\n    setStyleAttr(renderer, element, valueToApply);\n  }\n  return valueToApply;\n}\n\n/**\n * Applies the provided styling prop/value to the element directly (without context resolution).\n *\n * This function is designed to be run from the styling instructions and will be called\n * automatically. This function is intended to be used for performance reasons in the\n * event that there is no need to apply styling via context resolution.\n *\n * This function has four different cases that can occur:\n *\n * - Case 1: Apply the provided prop/value (style or class) entry to the element\n *           (if it is `non null`).\n *\n * - Case 2: If value does not get applied (because its `null` or `undefined`) then the algorithm\n *           will check to see if a styling map value was applied to the element as well just\n *           before this (via `styleMap` or `classMap`). If and when a map is present then the\n  *          algorithm will find the matching property in the map and apply its value.\n  *\n * - Case 3: If a map value fails to be applied then the algorithm will check to see if there\n *           are any initial values present and attempt to apply a matching value based on\n *           the target prop.\n *\n * - Default Case: If a matching initial value cannot be applied then a default value\n *                 of `null` will be applied (which will remove the style/class value\n *                 from the element).\n *\n * See `allowDirectStylingApply` to learn the logic used to determine whether any style/class\n * bindings can be directly applied.\n *\n * @returns whether or not the prop/value styling was applied to the element.\n */\nexport function applyStylingValueDirectly(\n    renderer: any, context: TStylingContext, tNode: TStylingNode, element: RElement,\n    data: LStylingData, bindingIndex: number, prop: string, value: any, isClassBased: boolean,\n    sanitizer?: StyleSanitizeFn | null): boolean {\n  let applied = false;\n  if (hasValueChanged(data[bindingIndex], value)) {\n    setValue(data, bindingIndex, value);\n    const applyFn = isClassBased ? setClass : setStyle;\n\n    // case 1: apply the provided value (if it exists)\n    applied = applyStylingValue(renderer, element, prop, value, applyFn, bindingIndex, sanitizer);\n\n    // case 2: find the matching property in a styling map and apply the detected value\n    const mapBindingsFlag =\n        isClassBased ? TNodeFlags.hasClassMapBindings : TNodeFlags.hasStyleMapBindings;\n    if (!applied && hasConfig(tNode, mapBindingsFlag)) {\n      const state = getStylingState(element, TEMPLATE_DIRECTIVE_INDEX);\n      const map = isClassBased ? state.lastDirectClassMap : state.lastDirectStyleMap;\n      applied = map ?\n          findAndApplyMapValue(renderer, element, applyFn, map, prop, bindingIndex, sanitizer) :\n          false;\n    }\n\n    // case 3: apply the initial value (if it exists)\n    if (!applied && hasConfig(tNode, TNodeFlags.hasInitialStyling)) {\n      const map = getStylingMapArray(context);\n      applied =\n          map ? findAndApplyMapValue(renderer, element, applyFn, map, prop, bindingIndex) : false;\n    }\n\n    // default case: apply `null` to remove the value\n    if (!applied) {\n      applyFn(renderer, element, prop, null, bindingIndex);\n    }\n  }\n  return applied;\n}\n\nfunction applyStylingValue(\n    renderer: any, element: RElement, prop: string, value: any, applyFn: ApplyStylingFn,\n    bindingIndex: number, sanitizer?: StyleSanitizeFn | null): boolean {\n  let valueToApply: string|null = unwrapSafeValue(value);\n  if (isStylingValueDefined(valueToApply)) {\n    valueToApply =\n        sanitizer ? sanitizer(prop, value, StyleSanitizeMode.ValidateAndSanitize) : valueToApply;\n    applyFn(renderer, element, prop, valueToApply, bindingIndex);\n    return true;\n  }\n  return false;\n}\n\nfunction findAndApplyMapValue(\n    renderer: any, element: RElement, applyFn: ApplyStylingFn, map: StylingMapArray, prop: string,\n    bindingIndex: number, sanitizer?: StyleSanitizeFn | null) {\n  for (let i = StylingMapArrayIndex.ValuesStartPosition; i < map.length;\n       i += StylingMapArrayIndex.TupleSize) {\n    const p = getMapProp(map, i);\n    if (p === prop) {\n      let valueToApply = getMapValue(map, i);\n      valueToApply = sanitizer ?\n          sanitizer(prop, valueToApply, StyleSanitizeMode.ValidateAndSanitize) :\n          valueToApply;\n      applyFn(renderer, element, prop, valueToApply, bindingIndex);\n      return true;\n    }\n    if (p > prop) {\n      break;\n    }\n  }\n  return false;\n}\n\nfunction normalizeBitMaskValue(value: number | boolean): number {\n  // if pass => apply all values (-1 implies that all bits are flipped to true)\n  if (value === true) return -1;\n\n  // if pass => skip all values\n  if (value === false) return 0;\n\n  // return the bit mask value as is\n  return value;\n}\n\nlet _activeStylingMapApplyFn: SyncStylingMapsFn|null = null;\nexport function getStylingMapsSyncFn() {\n  return _activeStylingMapApplyFn;\n}\n\nexport function setStylingMapsSyncFn(fn: SyncStylingMapsFn) {\n  _activeStylingMapApplyFn = fn;\n}\n\n/**\n * Assigns a style value to a style property for the given element.\n */\nexport const setStyle: ApplyStylingFn =\n    (renderer: Renderer3 | null, native: RElement, prop: string, value: string | null) => {\n      if (renderer !== null) {\n        // Use `isStylingValueDefined` to account for falsy values that should be bound like 0.\n        if (isStylingValueDefined(value)) {\n          // opacity, z-index and flexbox all have number values\n          // and these need to be converted into strings so that\n          // they can be assigned properly.\n          value = value.toString();\n          ngDevMode && ngDevMode.rendererSetStyle++;\n          if (isProceduralRenderer(renderer)) {\n            renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase);\n          } else {\n            // The reason why native style may be `null` is either because\n            // it's a container element or it's a part of a test\n            // environment that doesn't have styling. In either\n            // case it's safe not to apply styling to the element.\n            const nativeStyle = native.style;\n            if (nativeStyle != null) {\n              nativeStyle.setProperty(prop, value);\n            }\n          }\n        } else {\n          ngDevMode && ngDevMode.rendererRemoveStyle++;\n\n          if (isProceduralRenderer(renderer)) {\n            renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase);\n          } else {\n            const nativeStyle = native.style;\n            if (nativeStyle != null) {\n              nativeStyle.removeProperty(prop);\n            }\n          }\n        }\n      }\n    };\n\n/**\n * Adds/removes the provided className value to the provided element.\n */\nexport const setClass: ApplyStylingFn =\n    (renderer: Renderer3 | null, native: RElement, className: string, value: any) => {\n      if (renderer !== null && className !== '') {\n        if (value) {\n          ngDevMode && ngDevMode.rendererAddClass++;\n          if (isProceduralRenderer(renderer)) {\n            renderer.addClass(native, className);\n          } else {\n            // the reason why classList may be `null` is either because\n            // it's a container element or it's a part of a test\n            // environment that doesn't have styling. In either\n            // case it's safe not to apply styling to the element.\n            const classList = native.classList;\n            if (classList != null) {\n              classList.add(className);\n            }\n          }\n        } else {\n          ngDevMode && ngDevMode.rendererRemoveClass++;\n          if (isProceduralRenderer(renderer)) {\n            renderer.removeClass(native, className);\n          } else {\n            const classList = native.classList;\n            if (classList != null) {\n              classList.remove(className);\n            }\n          }\n        }\n      }\n    };\n\nexport const setClassName = (renderer: Renderer3 | null, native: RElement, className: string) => {\n  if (renderer !== null) {\n    if (isProceduralRenderer(renderer)) {\n      renderer.setAttribute(native, 'class', className);\n    } else {\n      native.className = className;\n    }\n  }\n};\n\nexport const setStyleAttr = (renderer: Renderer3 | null, native: RElement, value: string) => {\n  if (renderer !== null) {\n    if (isProceduralRenderer(renderer)) {\n      renderer.setAttribute(native, 'style', value);\n    } else {\n      native.setAttribute('style', value);\n    }\n  }\n};\n\n/**\n * Iterates over all provided styling entries and renders them on the element.\n *\n * This function is used alongside a `StylingMapArray` entry. This entry is not\n * the same as the `TStylingContext` and is only really used when an element contains\n * initial styling values (e.g. `<div style=\"width:200px\">`), but no style/class bindings\n * are present. If and when that happens then this function will be called to render all\n * initial styling values on an element.\n */\nexport function renderStylingMap(\n    renderer: Renderer3, element: RElement, stylingValues: TStylingContext | StylingMapArray | null,\n    isClassBased: boolean): void {\n  const stylingMapArr = getStylingMapArray(stylingValues);\n  if (stylingMapArr) {\n    for (let i = StylingMapArrayIndex.ValuesStartPosition; i < stylingMapArr.length;\n         i += StylingMapArrayIndex.TupleSize) {\n      const prop = getMapProp(stylingMapArr, i);\n      const value = getMapValue(stylingMapArr, i);\n      if (isClassBased) {\n        setClass(renderer, element, prop, value, null);\n      } else {\n        setStyle(renderer, element, prop, value, null);\n      }\n    }\n  }\n}\n\nfunction objectToClassName(obj: {[key: string]: any} | null): string {\n  let str = '';\n  if (obj) {\n    for (let key in obj) {\n      const value = obj[key];\n      if (value) {\n        str += (str.length ? ' ' : '') + key;\n      }\n    }\n  }\n  return str;\n}\n\n/**\n * Determines whether or not an element style/className value has changed since the last update.\n *\n * This function helps Angular determine if a style or class attribute value was\n * modified by an external plugin or API outside of the style binding code. This\n * means any JS code that adds/removes class/style values on an element outside\n * of Angular's styling binding algorithm.\n *\n * @returns true when the value was modified externally.\n */\nfunction checkIfExternallyModified(element: HTMLElement, cachedValue: any, isClassBased: boolean) {\n  // this means it was checked before and there is no reason\n  // to compare the style/class values again. Either that or\n  // web workers are being used.\n  if (global.Node === 'undefined' || cachedValue === VALUE_IS_EXTERNALLY_MODIFIED) return true;\n\n  // comparing the DOM value against the cached value is the best way to\n  // see if something has changed.\n  const currentValue =\n      (isClassBased ? element.className : (element.style && element.style.cssText)) || '';\n  return currentValue !== (cachedValue || '');\n}\n\n/**\n * Removes provided styling values from the element\n */\nfunction removeStylingValues(\n    renderer: any, element: RElement, values: string | {[key: string]: any} | StylingMapArray,\n    isClassBased: boolean) {\n  let arr: StylingMapArray;\n  if (isStylingMapArray(values)) {\n    arr = values as StylingMapArray;\n  } else {\n    arr = normalizeIntoStylingMap(null, values, !isClassBased);\n  }\n\n  const applyFn = isClassBased ? setClass : setStyle;\n  for (let i = StylingMapArrayIndex.ValuesStartPosition; i < arr.length;\n       i += StylingMapArrayIndex.TupleSize) {\n    const value = getMapValue(arr, i);\n    if (value) {\n      const prop = getMapProp(arr, i);\n      applyFn(renderer, element, prop, null);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from '../../util/assert';\nimport {assertLView} from '../assert';\nimport {isLContainer, isLView} from '../interfaces/type_checks';\nimport {CONTEXT, FLAGS, LView, LViewFlags, PARENT, RootContext} from '../interfaces/view';\nimport {readPatchedLView} from './view_utils';\n\n\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nexport function getLViewParent(lView: LView): LView|null {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT] ! : parent;\n}\n\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nexport function getRootView(componentOrLView: LView | {}): LView {\n  ngDevMode && assertDefined(componentOrLView, 'component');\n  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView) !;\n  while (lView && !(lView[FLAGS] & LViewFlags.IsRoot)) {\n    lView = getLViewParent(lView) !;\n  }\n  ngDevMode && assertLView(lView);\n  return lView;\n}\n\n/**\n * Returns the `RootContext` instance that is associated with\n * the application where the target is situated. It does this by walking the parent views until it\n * gets to the root view, then getting the context off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nexport function getRootContext(viewOrComponent: LView | {}): RootContext {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode &&\n      assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT] as RootContext;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertDataInRange, assertGreaterThan} from '../../util/assert';\nimport {executeCheckHooks, executeInitAndCheckHooks} from '../hooks';\nimport {FLAGS, HEADER_OFFSET, InitPhaseState, LView, LViewFlags, TVIEW} from '../interfaces/view';\nimport {ActiveElementFlags, executeElementExitFn, getCheckNoChangesMode, getLView, getSelectedIndex, hasActiveElementFlag, setSelectedIndex} from '../state';\n\n\n\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n  *   if (rf & 1) {\n  *     text(0, 'Hello');\n  *     text(1, 'Goodbye')\n  *     element(2, 'div');\n  *   }\n  *   if (rf & 2) {\n  *     advance(2); // Advance twice to the <div>.\n  *     property('title', 'test');\n  *   }\n  *  }\n  * ```\n  * @param delta Number of elements to advance forwards by.\n  *\n  * @codeGenApi\n  */\nexport function ÉµÉµadvance(delta: number): void {\n  ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n  selectIndexInternal(getLView(), getSelectedIndex() + delta, getCheckNoChangesMode());\n}\n\n/**\n * Selects an element for later binding instructions.\n * @deprecated No longer being generated, but still used in unit tests.\n * @codeGenApi\n */\nexport function ÉµÉµselect(index: number): void {\n  selectIndexInternal(getLView(), index, getCheckNoChangesMode());\n}\n\nexport function selectIndexInternal(lView: LView, index: number, checkNoChangesMode: boolean) {\n  ngDevMode && assertGreaterThan(index, -1, 'Invalid index');\n  ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\n\n  if (hasActiveElementFlag(ActiveElementFlags.RunExitFn)) {\n    executeElementExitFn();\n  }\n\n  // Flush the initial hooks for elements in the view that have been added up to this point.\n  // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n  if (!checkNoChangesMode) {\n    const hooksInitPhaseCompleted =\n        (lView[FLAGS] & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n    if (hooksInitPhaseCompleted) {\n      const preOrderCheckHooks = lView[TVIEW].preOrderCheckHooks;\n      if (preOrderCheckHooks !== null) {\n        executeCheckHooks(lView, preOrderCheckHooks, index);\n      }\n    } else {\n      const preOrderHooks = lView[TVIEW].preOrderHooks;\n      if (preOrderHooks !== null) {\n        executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, index);\n      }\n    }\n  }\n\n  // We must set the selected index *after* running the hooks, because hooks may have side-effects\n  // that cause other template functions to run, thus updating the selected index, which is global\n  // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n  // will be altered by the time we leave the `ÉµÉµadvance` instruction.\n  setSelectedIndex(index);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n *\n * OpCodes contain three parts:\n *  1) Parent node index offset.\n *  2) Reference node index offset.\n *  3) The OpCode to execute.\n *\n * See: `I18nCreateOpCodes` for example of usage.\n */\nimport {SanitizerFn} from './sanitization';\n\nexport const enum I18nMutateOpCode {\n  /**\n   * Stores shift amount for bits 17-3 that contain reference index.\n   */\n  SHIFT_REF = 3,\n  /**\n   * Stores shift amount for bits 31-17 that contain parent index.\n   */\n  SHIFT_PARENT = 17,\n  /**\n   * Mask for OpCode\n   */\n  MASK_OPCODE = 0b111,\n\n  /**\n   * OpCode to select a node. (next OpCode will contain the operation.)\n   */\n  Select = 0b000,\n  /**\n   * OpCode to append the current node to `PARENT`.\n   */\n  AppendChild = 0b001,\n  /**\n   * OpCode to remove the `REF` node from `PARENT`.\n   */\n  Remove = 0b011,\n  /**\n   * OpCode to set the attribute of a node.\n   */\n  Attr = 0b100,\n  /**\n   * OpCode to simulate elementEnd()\n   */\n  ElementEnd = 0b101,\n  /**\n   * OpCode to read the remove OpCodes for the nested ICU\n   */\n  RemoveNestedIcu = 0b110,\n}\n\n/**\n * Marks that the next string is for element.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ELEMENT_MARKER: ELEMENT_MARKER = {\n  marker: 'element'\n};\nexport interface ELEMENT_MARKER { marker: 'element'; }\n\n/**\n * Marks that the next string is for comment.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const COMMENT_MARKER: COMMENT_MARKER = {\n  marker: 'comment'\n};\n\nexport interface COMMENT_MARKER { marker: 'comment'; }\n\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```ts\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createTextNode('abc');\n *   //   lView[1].insertBefore(node, lView[2]);\n *   'abc', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createTextNode('xyz');\n *   //   lView[1].appendChild(node);\n *   'xyz', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createElement('div');\n *   //   lView[1].insertBefore(node, lView[2]);\n *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createElement('div');\n *   //   lView[1].appendChild(node);\n *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createComment('');\n *   //   lView[1].insertBefore(node, lView[2]);\n *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createComment('');\n *   //   lView[1].appendChild(node);\n *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].insertBefore(node, lView[3]);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 3 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   removeChild(tView.data(1), node, lView);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Select, 'attr', 'value'\n *            // NOTE: Select followed by two string (vs select followed by OpCode)\n * ];\n * ```\n * NOTE:\n *   - `index` is initial location where the extra nodes should be stored in the EXPANDO section of\n * `LVIewData`.\n *\n * See: `applyI18nCreateOpCodes`;\n */\nexport interface I18nMutateOpCodes extends Array<number|string|ELEMENT_MARKER|COMMENT_MARKER|null> {\n}\n\nexport const enum I18nUpdateOpCode {\n  /**\n   * Stores shift amount for bits 17-2 that contain reference index.\n   */\n  SHIFT_REF = 2,\n  /**\n   * Mask for OpCode\n   */\n  MASK_OPCODE = 0b11,\n\n  /**\n   * OpCode to update a text node.\n   */\n  Text = 0b00,\n  /**\n   * OpCode to update a attribute of a node.\n   */\n  Attr = 0b01,\n  /**\n   * OpCode to switch the current ICU case.\n   */\n  IcuSwitch = 0b10,\n  /**\n   * OpCode to update the current ICU case.\n   */\n  IcuUpdate = 0b11,\n}\n\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```ts\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(ctx.exp1); // If changed set mask bit 1\n *    i18nExp(ctx.exp2); // If changed set mask bit 2\n *    i18nExp(ctx.exp3); // If changed set mask bit 3\n *    i18nExp(ctx.exp4); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * ### OpCodes\n * ```ts\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `7` values and start processing next OpCodes.\n *   0b11, 7,\n *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lView[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b1000, 4,\n *   // Concatenate `newValue = lView[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lView[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\nexport interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null> {}\n\n/**\n * Store information for the i18n translation block.\n */\nexport interface TI18n {\n  /**\n   * Number of slots to allocate in expando.\n   *\n   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n   * write into them.\n   */\n  vars: number;\n\n  /**\n   * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n   *\n   * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n   */\n  create: I18nMutateOpCodes;\n\n  /**\n   * A set of OpCodes which will be executed on each change detection to determine if any changes to\n   * DOM are required.\n   */\n  update: I18nUpdateOpCodes;\n\n  /**\n   * A list of ICUs in a translation block (or `null` if block has no ICUs).\n   *\n   * Example:\n   * Given: `<div i18n>You have {count, plural, ...} and {state, switch, ...}</div>`\n   * There would be 2 ICUs in this array.\n   *   1. `{count, plural, ...}`\n   *   2. `{state, switch, ...}`\n   */\n  icus: TIcu[]|null;\n}\n\n/**\n * Defines the ICU type of `select` or `plural`\n */\nexport const enum IcuType {\n  select = 0,\n  plural = 1,\n}\n\nexport interface TIcu {\n  /**\n   * Defines the ICU type of `select` or `plural`\n   */\n  type: IcuType;\n\n  /**\n   * Number of slots to allocate in expando for each case.\n   *\n   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n   * write into them.\n   */\n  vars: number[];\n\n  /**\n   * An optional array of child/sub ICUs.\n   *\n   * In case of nested ICUs such as:\n   * ```\n   * {ï¿½0ï¿½, plural,\n   *   =0 {zero}\n   *   other {ï¿½0ï¿½ {ï¿½1ï¿½, select,\n   *                     cat {cats}\n   *                     dog {dogs}\n   *                     other {animals}\n   *                   }!\n   *   }\n   * }\n   * ```\n   * When the parent ICU is changing it must clean up child ICUs as well. For this reason it needs\n   * to know which child ICUs to run clean up for as well.\n   *\n   * In the above example this would be:\n   * ```ts\n   * [\n   *   [],   // `=0` has no sub ICUs\n   *   [1],  // `other` has one subICU at `1`st index.\n   * ]\n   * ```\n   *\n   * The reason why it is Array of Arrays is because first array represents the case, and second\n   * represents the child ICUs to clean up. There may be more than one child ICUs per case.\n   */\n  childIcus: number[][];\n\n  /**\n   * A list of case values which the current ICU will try to match.\n   *\n   * The last value is `other`\n   */\n  cases: any[];\n\n  /**\n   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n   */\n  create: I18nMutateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n   */\n  remove: I18nMutateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n   */\n  update: I18nUpdateOpCodes[];\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {global} from '../util/global';\n\n/**\n * Used to inform TS about the `Proxy` class existing globally.\n */\ninterface GlobalWithProxy {\n  Proxy: typeof Proxy;\n}\n\n/**\n * Creates an instance of a `Proxy` and creates with an empty target object and binds it to the\n * provided handler.\n *\n * The reason why this function exists is because IE doesn't support\n * the `Proxy` class. For this reason an error must be thrown.\n */\nexport function createProxy(handler: ProxyHandler<any>): {} {\n  const g = global as any as GlobalWithProxy;\n  if (!g.Proxy) {\n    throw new Error('Proxy is not supported in this browser');\n  }\n  return new g.Proxy({}, handler);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport function attachDebugObject(obj: any, debug: any) {\n  Object.defineProperty(obj, 'debug', {value: debug, enumerable: false});\n}\n","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\nimport {unwrapSafeValue} from '../../sanitization/bypass';\nimport {StyleSanitizeFn, StyleSanitizeMode} from '../../sanitization/style_sanitizer';\nimport {ProceduralRenderer3, RElement, Renderer3} from '../interfaces/renderer';\nimport {ApplyStylingFn, LStylingData, StylingMapArray, StylingMapArrayIndex, StylingMapsSyncMode, SyncStylingMapsFn, TStylingContext, TStylingContextIndex} from '../interfaces/styling';\nimport {getBindingValue, getMapProp, getMapValue, getValue, getValuesCount, isStylingValueDefined} from '../util/styling_utils';\n\nimport {setStylingMapsSyncFn} from './bindings';\n\n\n/**\n * --------\n *\n * This file contains the algorithm logic for applying map-based bindings\n * such as `[style]` and `[class]`.\n *\n * --------\n */\n\n/**\n * Enables support for map-based styling bindings (e.g. `[style]` and `[class]` bindings).\n */\nexport function activateStylingMapFeature() {\n  setStylingMapsSyncFn(syncStylingMap);\n}\n\n/**\n * Used to apply styling values presently within any map-based bindings on an element.\n *\n * Angular supports map-based styling bindings which can be applied via the\n * `[style]` and `[class]` bindings which can be placed on any HTML element.\n * These bindings can work independently, together or alongside prop-based\n * styling bindings (e.g. `<div [style]=\"x\" [style.width]=\"w\">`).\n *\n * If a map-based styling binding is detected by the compiler, the following\n * AOT code is produced:\n *\n * ```typescript\n * styleMap(ctx.styles); // styles = {key:value}\n * classMap(ctx.classes); // classes = {key:value}|string\n * ```\n *\n * If and when either of the instructions above are evaluated, then the code\n * present in this file is included into the bundle. The mechanism used, to\n * activate support for map-based bindings at runtime is possible via the\n * `activeStylingMapFeature` function (which is also present in this file).\n *\n * # The Algorithm\n * Whenever a map-based binding updates (which is when the identity of the\n * map-value changes) then the map is iterated over and a `StylingMapArray` array\n * is produced. The `StylingMapArray` instance is stored in the binding location\n * where the `BINDING_INDEX` is situated when the `styleMap()` or `classMap()`\n * instruction were called. Once the binding changes, then the internal `bitMask`\n * value is marked as dirty.\n *\n * Styling values are applied once CD exits the element (which happens when\n * the `advance(n)` instruction is called or the template function exits). When\n * this occurs, all prop-based bindings are applied. If a map-based binding is\n * present then a special flushing function (called a sync function) is made\n * available and it will be called each time a styling property is flushed.\n *\n * The flushing algorithm is designed to apply styling for a property (which is\n * a CSS property or a className value) one by one. If map-based bindings\n * are present, then the flushing algorithm will keep calling the maps styling\n * sync function each time a property is visited. This way, the flushing\n * behavior of map-based bindings will always be at the same property level\n * as the current prop-based property being iterated over (because everything\n * is alphabetically sorted).\n *\n * Let's imagine we have the following HTML template code:\n *\n * ```html\n * <div [style]=\"{width:'100px', height:'200px', 'z-index':'10'}\"\n *      [style.width.px]=\"200\">...</div>\n * ```\n *\n * When CD occurs, both the `[style]` and `[style.width]` bindings\n * are evaluated. Then when the styles are flushed on screen, the\n * following operations happen:\n *\n * 1. `[style.width]` is attempted to be written to the element.\n *\n * 2.  Once that happens, the algorithm instructs the map-based\n *     entries (`[style]` in this case) to \"catch up\" and apply\n *     all values up to the `width` value. When this happens the\n *     `height` value is applied to the element (since it is\n *     alphabetically situated before the `width` property).\n *\n * 3. Since there are no more prop-based entries anymore, the\n *    loop exits and then, just before the flushing ends, it\n *    instructs all map-based bindings to \"finish up\" applying\n *    their values.\n *\n * 4. The only remaining value within the map-based entries is\n *    the `z-index` value (`width` got skipped because it was\n *    successfully applied via the prop-based `[style.width]`\n *    binding). Since all map-based entries are told to \"finish up\",\n *    the `z-index` value is iterated over and it is then applied\n *    to the element.\n *\n * The most important thing to take note of here is that prop-based\n * bindings are evaluated in order alongside map-based bindings.\n * This allows all styling across an element to be applied in O(n)\n * time (a similar algorithm is that of the array merge algorithm\n * in merge sort).\n */\nexport const syncStylingMap: SyncStylingMapsFn =\n    (context: TStylingContext, renderer: Renderer3 | ProceduralRenderer3 | null, element: RElement,\n     data: LStylingData, sourceIndex: number, applyStylingFn: ApplyStylingFn,\n     sanitizer: StyleSanitizeFn | null, mode: StylingMapsSyncMode, targetProp?: string | null,\n     defaultValue?: string | boolean | null): boolean => {\n      let targetPropValueWasApplied = false;\n\n      // once the map-based styling code is activate it is never deactivated. For this reason a\n      // check to see if the current styling context has any map based bindings is required.\n      const totalMaps = getValuesCount(context);\n      if (totalMaps) {\n        let runTheSyncAlgorithm = true;\n        const loopUntilEnd = !targetProp;\n\n        // If the code is told to finish up (run until the end), but the mode\n        // hasn't been flagged to apply values (it only traverses values) then\n        // there is no point in iterating over the array because nothing will\n        // be applied to the element.\n        if (loopUntilEnd && (mode & StylingMapsSyncMode.ApplyAllValues) === 0) {\n          runTheSyncAlgorithm = false;\n          targetPropValueWasApplied = true;\n        }\n\n        if (runTheSyncAlgorithm) {\n          targetPropValueWasApplied = innerSyncStylingMap(\n              context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp || null,\n              sourceIndex, defaultValue || null);\n        }\n\n        if (loopUntilEnd) {\n          resetSyncCursors();\n        }\n      }\n\n      return targetPropValueWasApplied;\n    };\n\n/**\n * Recursive function designed to apply map-based styling to an element one map at a time.\n *\n * This function is designed to be called from the `syncStylingMap` function and will\n * apply map-based styling data one map at a time to the provided `element`.\n *\n * This function is recursive and it will call itself if a follow-up map value is to be\n * processed. To learn more about how the algorithm works, see `syncStylingMap`.\n */\nfunction innerSyncStylingMap(\n    context: TStylingContext, renderer: Renderer3 | ProceduralRenderer3 | null, element: RElement,\n    data: LStylingData, applyStylingFn: ApplyStylingFn, sanitizer: StyleSanitizeFn | null,\n    mode: StylingMapsSyncMode, targetProp: string | null, currentMapIndex: number,\n    defaultValue: string | boolean | null): boolean {\n  const totalMaps = getValuesCount(context) - 1;  // maps have no default value\n  const mapsLimit = totalMaps - 1;\n  const recurseInnerMaps =\n      currentMapIndex < mapsLimit && (mode & StylingMapsSyncMode.RecurseInnerMaps) !== 0;\n  const checkValuesOnly = (mode & StylingMapsSyncMode.CheckValuesOnly) !== 0;\n\n  if (checkValuesOnly) {\n    // inner modes do not check values ever (that can only happen\n    // when sourceIndex === 0)\n    mode &= ~StylingMapsSyncMode.CheckValuesOnly;\n  }\n\n  let targetPropValueWasApplied = false;\n  if (currentMapIndex <= mapsLimit) {\n    let cursor = getCurrentSyncCursor(currentMapIndex);\n    const bindingIndex = getBindingValue(\n        context, TStylingContextIndex.ValuesStartPosition, currentMapIndex) as number;\n    const stylingMapArr = getValue<StylingMapArray>(data, bindingIndex);\n\n    if (stylingMapArr) {\n      while (cursor < stylingMapArr.length) {\n        const prop = getMapProp(stylingMapArr, cursor);\n        const iteratedTooFar = targetProp && prop > targetProp;\n        const isTargetPropMatched = !iteratedTooFar && prop === targetProp;\n        const value = getMapValue(stylingMapArr, cursor);\n        const valueIsDefined = isStylingValueDefined(value);\n\n        // the recursive code is designed to keep applying until\n        // it reaches or goes past the target prop. If and when\n        // this happens then it will stop processing values, but\n        // all other map values must also catch up to the same\n        // point. This is why a recursive call is still issued\n        // even if the code has iterated too far.\n        const innerMode =\n            iteratedTooFar ? mode : resolveInnerMapMode(mode, valueIsDefined, isTargetPropMatched);\n\n        const innerProp = iteratedTooFar ? targetProp : prop;\n        let valueApplied = recurseInnerMaps ?\n            innerSyncStylingMap(\n                context, renderer, element, data, applyStylingFn, sanitizer, innerMode, innerProp,\n                currentMapIndex + 1, defaultValue) :\n            false;\n\n        if (iteratedTooFar) {\n          if (!targetPropValueWasApplied) {\n            targetPropValueWasApplied = valueApplied;\n          }\n          break;\n        }\n\n        if (!valueApplied && isValueAllowedToBeApplied(mode, isTargetPropMatched)) {\n          valueApplied = true;\n\n          if (!checkValuesOnly) {\n            const useDefault = isTargetPropMatched && !valueIsDefined;\n            const bindingIndexToApply = isTargetPropMatched ? bindingIndex : null;\n\n            let finalValue: any;\n            if (useDefault) {\n              finalValue = defaultValue;\n            } else {\n              finalValue = sanitizer ?\n                  sanitizer(prop, value, StyleSanitizeMode.ValidateAndSanitize) :\n                  (value ? unwrapSafeValue(value) : null);\n            }\n\n            applyStylingFn(renderer, element, prop, finalValue, bindingIndexToApply);\n          }\n        }\n\n        targetPropValueWasApplied = valueApplied && isTargetPropMatched;\n        cursor += StylingMapArrayIndex.TupleSize;\n      }\n      setCurrentSyncCursor(currentMapIndex, cursor);\n\n      // this is a fallback case in the event that the styling map is `null` for this\n      // binding but there are other map-based bindings that need to be evaluated\n      // afterwards. If the `prop` value is falsy then the intention is to cycle\n      // through all of the properties in the remaining maps as well. If the current\n      // styling map is too short then there are no values to iterate over. In either\n      // case the follow-up maps need to be iterated over.\n      if (recurseInnerMaps &&\n          (stylingMapArr.length === StylingMapArrayIndex.ValuesStartPosition || !targetProp)) {\n        targetPropValueWasApplied = innerSyncStylingMap(\n            context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp,\n            currentMapIndex + 1, defaultValue);\n      }\n    } else if (recurseInnerMaps) {\n      targetPropValueWasApplied = innerSyncStylingMap(\n          context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp,\n          currentMapIndex + 1, defaultValue);\n    }\n  }\n\n  return targetPropValueWasApplied;\n}\n\n/**\n * Used to determine the mode for the inner recursive call.\n *\n * If an inner map is iterated on then this is done so for one\n * of two reasons:\n *\n * - value is being applied:\n *   if the value is being applied from this current styling\n *   map then there is no need to apply it in a deeper map\n *   (i.e. the `SkipTargetProp` flag is set)\n *\n * - value is being not applied:\n *   apply the value if it is found in a deeper map.\n *   (i.e. the `SkipTargetProp` flag is unset)\n *\n * When these reasons are encountered the flags will for the\n * inner map mode will be configured.\n */\nfunction resolveInnerMapMode(\n    currentMode: number, valueIsDefined: boolean, isTargetPropMatched: boolean): number {\n  let innerMode = currentMode;\n\n  // the statements below figures out whether or not an inner styling map\n  // is allowed to apply its value or not. The main thing to keep note\n  // of is that if the target prop isn't matched then its expected that\n  // all values before it are allowed to be applied so long as \"apply all values\"\n  // is set to true.\n  const applyAllValues = currentMode & StylingMapsSyncMode.ApplyAllValues;\n  const applyTargetProp = currentMode & StylingMapsSyncMode.ApplyTargetProp;\n  const allowInnerApply =\n      !valueIsDefined && (isTargetPropMatched ? applyTargetProp : applyAllValues);\n\n  if (allowInnerApply) {\n    // case 1: set the mode to apply the targeted prop value if it\n    // ends up being encountered in another map value\n    innerMode |= StylingMapsSyncMode.ApplyTargetProp;\n    innerMode &= ~StylingMapsSyncMode.SkipTargetProp;\n  } else {\n    // case 2: set the mode to skip the targeted prop value if it\n    // ends up being encountered in another map value\n    innerMode |= StylingMapsSyncMode.SkipTargetProp;\n    innerMode &= ~StylingMapsSyncMode.ApplyTargetProp;\n  }\n\n  return innerMode;\n}\n\n/**\n * Decides whether or not a prop/value entry will be applied to an element.\n *\n * To determine whether or not a value is to be applied,\n * the following procedure is evaluated:\n *\n * First check to see the current `mode` status:\n *  1. If the mode value permits all props to be applied then allow.\n *    - But do not allow if the current prop is set to be skipped.\n *  2. Otherwise if the current prop is permitted then allow.\n */\nfunction isValueAllowedToBeApplied(mode: StylingMapsSyncMode, isTargetPropMatched: boolean) {\n  let doApplyValue = (mode & StylingMapsSyncMode.ApplyAllValues) !== 0;\n  if (!doApplyValue) {\n    if (mode & StylingMapsSyncMode.ApplyTargetProp) {\n      doApplyValue = isTargetPropMatched;\n    }\n  } else if ((mode & StylingMapsSyncMode.SkipTargetProp) && isTargetPropMatched) {\n    doApplyValue = false;\n  }\n  return doApplyValue;\n}\n\n/**\n * Used to keep track of concurrent cursor values for multiple map-based styling bindings present on\n * an element.\n */\nconst MAP_CURSORS: number[] = [];\n\n/**\n * Used to reset the state of each cursor value being used to iterate over map-based styling\n * bindings.\n */\nfunction resetSyncCursors() {\n  for (let i = 0; i < MAP_CURSORS.length; i++) {\n    MAP_CURSORS[i] = StylingMapArrayIndex.ValuesStartPosition;\n  }\n}\n\n/**\n * Returns an active cursor value at a given mapIndex location.\n */\nfunction getCurrentSyncCursor(mapIndex: number) {\n  if (mapIndex >= MAP_CURSORS.length) {\n    MAP_CURSORS.push(StylingMapArrayIndex.ValuesStartPosition);\n  }\n  return MAP_CURSORS[mapIndex];\n}\n\n/**\n * Sets a cursor value at a given mapIndex location.\n */\nfunction setCurrentSyncCursor(mapIndex: number, indexValue: number) {\n  MAP_CURSORS[mapIndex] = indexValue;\n}\n","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\nimport {createProxy} from '../../debug/proxy';\nimport {StyleSanitizeFn} from '../../sanitization/style_sanitizer';\nimport {TNodeFlags} from '../interfaces/node';\nimport {RElement} from '../interfaces/renderer';\nimport {ApplyStylingFn, LStylingData, TStylingContext, TStylingContextIndex, TStylingNode} from '../interfaces/styling';\nimport {getCurrentStyleSanitizer} from '../state';\nimport {attachDebugObject} from '../util/debug_utils';\nimport {MAP_BASED_ENTRY_PROP_NAME, TEMPLATE_DIRECTIVE_INDEX, allowDirectStyling as _allowDirectStyling, getBindingValue, getDefaultValue, getGuardMask, getProp, getPropValuesStartPosition, getValue, getValuesCount, hasConfig, isSanitizationRequired, isStylingContext, normalizeIntoStylingMap, setValue} from '../util/styling_utils';\n\nimport {applyStylingViaContext} from './bindings';\nimport {activateStylingMapFeature} from './map_based_bindings';\n\n\n\n/**\n * --------\n *\n * This file contains the core debug functionality for styling in Angular.\n *\n * To learn more about the algorithm see `TStylingContext`.\n *\n * --------\n */\n\n/**\n * A debug-friendly version of `TStylingContext`.\n *\n * An instance of this is attached to `tStylingContext.debug` when `ngDevMode` is active.\n */\nexport interface DebugStylingContext {\n  /** The configuration settings of the associated `TStylingContext` */\n  config: DebugStylingConfig;\n\n  /** The associated TStylingContext instance */\n  context: TStylingContext;\n\n  /** The associated TStylingContext instance */\n  entries: {[prop: string]: DebugStylingContextEntry};\n\n  /** A status report of all the sources within the context */\n  printSources(): void;\n\n  /** A status report of all the entire context as a table */\n  printTable(): void;\n}\n\n\n/**\n * A debug/testing-oriented summary of all styling information in `TNode.flags`.\n */\nexport interface DebugStylingConfig {\n  hasMapBindings: boolean;       //\n  hasPropBindings: boolean;      //\n  hasCollisions: boolean;        //\n  hasTemplateBindings: boolean;  //\n  hasHostBindings: boolean;      //\n  allowDirectStyling: boolean;   //\n}\n\n\n/**\n * A debug/testing-oriented summary of all styling entries within a `TStylingContext`.\n */\nexport interface DebugStylingContextEntry {\n  /** The property (style or class property) that this entry represents */\n  prop: string;\n\n  /** The total amount of styling entries a part of this entry */\n  valuesCount: number;\n\n  /**\n   * The bit guard mask that is used to compare and protect against\n   * styling changes when any template style/class bindings update\n   */\n  templateBitMask: number;\n\n  /**\n   * The bit guard mask that is used to compare and protect against\n   * styling changes when any host style/class bindings update\n   */\n  hostBindingsBitMask: number;\n\n  /**\n   * Whether or not the entry requires sanitization\n   */\n  sanitizationRequired: boolean;\n\n  /**\n   * The default value that will be applied if any bindings are falsy\n   */\n  defaultValue: string|boolean|null;\n\n  /**\n   * All bindingIndex sources that have been registered for this style\n   */\n  sources: (number|null|string)[];\n}\n\n\n/**\n * A debug/testing-oriented summary of all styling entries for a `DebugNode` instance.\n */\nexport interface DebugNodeStyling {\n  /** The associated debug context of the TStylingContext instance */\n  context: DebugStylingContext;\n\n  /**\n   * A summarization of each style/class property\n   * present in the context\n   */\n  summary: {[propertyName: string]: DebugNodeStylingEntry};\n\n  /**\n   * A key/value map of all styling properties and their\n   * runtime values\n   */\n  values: {[propertyName: string]: string | number | null | boolean};\n\n  /**\n   * Overrides the sanitizer used to process styles\n   */\n  overrideSanitizer(sanitizer: StyleSanitizeFn|null): void;\n}\n\n\n/**\n * A debug/testing-oriented summary of a styling entry.\n *\n * A value such as this is generated as an artifact of the `DebugStyling`\n * summary.\n */\nexport interface DebugNodeStylingEntry {\n  /** The style/class property that the summary is attached to */\n  prop: string;\n\n  /** The last applied value for the style/class property */\n  value: string|boolean|null;\n\n  /** The binding index of the last applied style/class property */\n  bindingIndex: number|null;\n}\n\n\n/**\n * Instantiates and attaches an instance of `TStylingContextDebug` to the provided context\n */\nexport function attachStylingDebugObject(\n    context: TStylingContext, tNode: TStylingNode, isClassBased: boolean) {\n  const debug = new TStylingContextDebug(context, tNode, isClassBased);\n  attachDebugObject(context, debug);\n  return debug;\n}\n\n/**\n * A human-readable debug summary of the styling data present within `TStylingContext`.\n *\n * This class is designed to be used within testing code or when an\n * application has `ngDevMode` activated.\n */\nclass TStylingContextDebug implements DebugStylingContext {\n  constructor(\n      public readonly context: TStylingContext, private _tNode: TStylingNode,\n      private _isClassBased: boolean) {}\n\n  get config(): DebugStylingConfig { return buildConfig(this._tNode, this._isClassBased); }\n\n  /**\n   * Returns a detailed summary of each styling entry in the context.\n   *\n   * See `DebugStylingContextEntry`.\n   */\n  get entries(): {[prop: string]: DebugStylingContextEntry} {\n    const context = this.context;\n    const totalColumns = getValuesCount(context);\n    const entries: {[prop: string]: DebugStylingContextEntry} = {};\n    const start = getPropValuesStartPosition(context, this._tNode, this._isClassBased);\n    let i = start;\n    while (i < context.length) {\n      const prop = getProp(context, i);\n      const templateBitMask = getGuardMask(context, i, false);\n      const hostBindingsBitMask = getGuardMask(context, i, true);\n      const defaultValue = getDefaultValue(context, i);\n      const sanitizationRequired = isSanitizationRequired(context, i);\n      const bindingsStartPosition = i + TStylingContextIndex.BindingsStartOffset;\n\n      const sources: (number | string | null)[] = [];\n\n      for (let j = 0; j < totalColumns; j++) {\n        const bindingIndex = context[bindingsStartPosition + j] as number | string | null;\n        if (bindingIndex !== 0) {\n          sources.push(bindingIndex);\n        }\n      }\n\n      entries[prop] = {\n        prop,\n        templateBitMask,\n        hostBindingsBitMask,\n        sanitizationRequired,\n        valuesCount: sources.length, defaultValue, sources,\n      };\n\n      i += TStylingContextIndex.BindingsStartOffset + totalColumns;\n    }\n    return entries;\n  }\n\n  /**\n   * Prints a detailed summary of each styling source grouped together with each binding index in\n   * the context.\n   */\n  printSources(): void {\n    let output = '\\n';\n\n    const context = this.context;\n    const prefix = this._isClassBased ? 'class' : 'style';\n    const bindingsBySource: {\n      type: string,\n      entries: {binding: string, bindingIndex: number, value: any, bitMask: number}[]\n    }[] = [];\n\n    const totalColumns = getValuesCount(context);\n    const itemsPerRow = TStylingContextIndex.BindingsStartOffset + totalColumns;\n\n    for (let i = 0; i < totalColumns; i++) {\n      const isDefaultColumn = i === totalColumns - 1;\n      const hostBindingsMode = i !== TEMPLATE_DIRECTIVE_INDEX;\n      const type = getTypeFromColumn(i, totalColumns);\n      const entries: {binding: string, value: any, bindingIndex: number, bitMask: number}[] = [];\n\n      let j = TStylingContextIndex.ValuesStartPosition;\n      while (j < context.length) {\n        const value = getBindingValue(context, j, i);\n        if (isDefaultColumn || value > 0) {\n          const bitMask = getGuardMask(context, j, hostBindingsMode);\n          const bindingIndex = isDefaultColumn ? -1 : value as number;\n          const prop = getProp(context, j);\n          const isMapBased = prop === MAP_BASED_ENTRY_PROP_NAME;\n          const binding = `${prefix}${isMapBased ? '' : '.' + prop}`;\n          entries.push({binding, value, bindingIndex, bitMask});\n        }\n        j += itemsPerRow;\n      }\n\n      bindingsBySource.push(\n          {type, entries: entries.sort((a, b) => a.bindingIndex - b.bindingIndex)});\n    }\n\n    bindingsBySource.forEach(entry => {\n      output += `[${entry.type.toUpperCase()}]\\n`;\n      output += repeat('-', entry.type.length + 2) + '\\n';\n\n      let tab = '  ';\n      entry.entries.forEach(entry => {\n        const isDefault = typeof entry.value !== 'number';\n        const value = entry.value;\n        if (!isDefault || value !== null) {\n          output += `${tab}[${entry.binding}] = \\`${value}\\``;\n          output += '\\n';\n        }\n      });\n      output += '\\n';\n    });\n\n    /* tslint:disable */\n    console.log(output);\n  }\n\n  /**\n   * Prints a detailed table of the entire styling context.\n   */\n  printTable(): void {\n    // IE (not Edge) is the only browser that doesn't support this feature. Because\n    // these debugging tools are not apart of the core of Angular (they are just\n    // extra tools) we can skip-out on older browsers.\n    if (!console.table) {\n      throw new Error('This feature is not supported in your browser');\n    }\n\n    const context = this.context;\n    const table: any[] = [];\n    const totalColumns = getValuesCount(context);\n    const itemsPerRow = TStylingContextIndex.BindingsStartOffset + totalColumns;\n    const totalProps = Math.floor(context.length / itemsPerRow);\n\n    let i = TStylingContextIndex.ValuesStartPosition;\n    while (i < context.length) {\n      const prop = getProp(context, i);\n      const isMapBased = prop === MAP_BASED_ENTRY_PROP_NAME;\n      const entry: {[key: string]: any} = {\n        prop,\n        'tpl mask': generateBitString(getGuardMask(context, i, false), isMapBased, totalProps),\n        'host mask': generateBitString(getGuardMask(context, i, true), isMapBased, totalProps),\n      };\n\n      for (let j = 0; j < totalColumns; j++) {\n        const key = getTypeFromColumn(j, totalColumns);\n        const value = getBindingValue(context, i, j);\n        entry[key] = value;\n      }\n\n      i += itemsPerRow;\n      table.push(entry);\n    }\n\n    /* tslint:disable */\n    console.table(table);\n  }\n}\n\nfunction generateBitString(value: number, isMapBased: boolean, totalProps: number) {\n  if (isMapBased || value > 1) {\n    return `0b${leftPad(value.toString(2), totalProps, '0')}`;\n  }\n  return null;\n}\n\nfunction leftPad(value: string, max: number, pad: string) {\n  return repeat(pad, max - value.length) + value;\n}\n\nfunction getTypeFromColumn(index: number, totalColumns: number) {\n  if (index === TEMPLATE_DIRECTIVE_INDEX) {\n    return 'template';\n  } else if (index === totalColumns - 1) {\n    return 'defaults';\n  } else {\n    return `dir #${index}`;\n  }\n}\n\nfunction repeat(c: string, times: number) {\n  let s = '';\n  for (let i = 0; i < times; i++) {\n    s += c;\n  }\n  return s;\n}\n\n/**\n * A human-readable debug summary of the styling data present for a `DebugNode` instance.\n *\n * This class is designed to be used within testing code or when an\n * application has `ngDevMode` activated.\n */\nexport class NodeStylingDebug implements DebugNodeStyling {\n  private _sanitizer: StyleSanitizeFn|null = null;\n  private _debugContext: DebugStylingContext;\n\n  constructor(\n      context: TStylingContext|DebugStylingContext, private _tNode: TStylingNode,\n      private _data: LStylingData, private _isClassBased: boolean) {\n    this._debugContext = isStylingContext(context) ?\n        new TStylingContextDebug(context as TStylingContext, _tNode, _isClassBased) :\n        (context as DebugStylingContext);\n  }\n\n  get context() { return this._debugContext; }\n\n  /**\n   * Overrides the sanitizer used to process styles.\n   */\n  overrideSanitizer(sanitizer: StyleSanitizeFn|null) { this._sanitizer = sanitizer; }\n\n  /**\n   * Returns a detailed summary of each styling entry in the context and\n   * what their runtime representation is.\n   *\n   * See `LStylingSummary`.\n   */\n  get summary(): {[key: string]: DebugNodeStylingEntry} {\n    const entries: {[key: string]: DebugNodeStylingEntry} = {};\n    const config = this.config;\n    const isClassBased = this._isClassBased;\n\n    let data = this._data;\n\n    // the direct pass code doesn't convert [style] or [class] values\n    // into StylingMapArray instances. For this reason, the values\n    // need to be converted ahead of time since the styling debug\n    // relies on context resolution to figure out what styling\n    // values have been added/removed on the element.\n    if (config.allowDirectStyling && config.hasMapBindings) {\n      data = data.concat([]);  // make a copy\n      this._convertMapBindingsToStylingMapArrays(data);\n    }\n\n    this._mapValues(data, (prop: string, value: any, bindingIndex: number | null) => {\n      entries[prop] = {prop, value, bindingIndex};\n    });\n\n    // because the styling algorithm runs into two different\n    // modes: direct and context-resolution, the output of the entries\n    // object is different because the removed values are not\n    // saved between updates. For this reason a proxy is created\n    // so that the behavior is the same when examining values\n    // that are no longer active on the element.\n    return createProxy({\n      get(target: {}, prop: string): DebugNodeStylingEntry{\n        let value: DebugNodeStylingEntry = entries[prop]; if (!value) {\n          value = {\n            prop,\n            value: isClassBased ? false : null,\n            bindingIndex: null,\n          };\n        } return value;\n      },\n      set(target: {}, prop: string, value: any) { return false; },\n      ownKeys() { return Object.keys(entries); },\n      getOwnPropertyDescriptor(k: any) {\n        // we use a special property descriptor here so that enumeration operations\n        // such as `Object.keys` will work on this proxy.\n        return {\n          enumerable: true,\n          configurable: true,\n        };\n      },\n    });\n  }\n\n  get config() { return buildConfig(this._tNode, this._isClassBased); }\n\n  /**\n   * Returns a key/value map of all the styles/classes that were last applied to the element.\n   */\n  get values(): {[key: string]: any} {\n    const entries: {[key: string]: any} = {};\n    const config = this.config;\n    let data = this._data;\n\n    // the direct pass code doesn't convert [style] or [class] values\n    // into StylingMapArray instances. For this reason, the values\n    // need to be converted ahead of time since the styling debug\n    // relies on context resolution to figure out what styling\n    // values have been added/removed on the element.\n    if (config.allowDirectStyling && config.hasMapBindings) {\n      data = data.concat([]);  // make a copy\n      this._convertMapBindingsToStylingMapArrays(data);\n    }\n\n    this._mapValues(data, (prop: string, value: any) => { entries[prop] = value; });\n    return entries;\n  }\n\n  private _convertMapBindingsToStylingMapArrays(data: LStylingData) {\n    const context = this.context.context;\n    const limit = getPropValuesStartPosition(context, this._tNode, this._isClassBased);\n    for (let i =\n             TStylingContextIndex.ValuesStartPosition + TStylingContextIndex.BindingsStartOffset;\n         i < limit; i++) {\n      const bindingIndex = context[i] as number;\n      const bindingValue = bindingIndex !== 0 ? getValue(data, bindingIndex) : null;\n      if (bindingValue && !Array.isArray(bindingValue)) {\n        const stylingMapArray = normalizeIntoStylingMap(null, bindingValue, !this._isClassBased);\n        setValue(data, bindingIndex, stylingMapArray);\n      }\n    }\n  }\n\n  private _mapValues(\n      data: LStylingData,\n      fn: (prop: string, value: string|null, bindingIndex: number|null) => any) {\n    // there is no need to store/track an element instance. The\n    // element is only used when the styling algorithm attempts to\n    // style the value (and we mock out the stylingApplyFn anyway).\n    const mockElement = {} as any;\n    const mapBindingsFlag =\n        this._isClassBased ? TNodeFlags.hasClassMapBindings : TNodeFlags.hasStyleMapBindings;\n    const hasMaps = hasConfig(this._tNode, mapBindingsFlag);\n    if (hasMaps) {\n      activateStylingMapFeature();\n    }\n\n    const mapFn: ApplyStylingFn =\n        (renderer: any, element: RElement, prop: string, value: string | null,\n         bindingIndex?: number | null) => fn(prop, value, bindingIndex || null);\n\n    const sanitizer = this._isClassBased ? null : (this._sanitizer || getCurrentStyleSanitizer());\n\n    // run the template bindings\n    applyStylingViaContext(\n        this.context.context, this._tNode, null, mockElement, data, true, mapFn, sanitizer, false,\n        this._isClassBased);\n\n    // and also the host bindings\n    applyStylingViaContext(\n        this.context.context, this._tNode, null, mockElement, data, true, mapFn, sanitizer, true,\n        this._isClassBased);\n  }\n}\n\nfunction buildConfig(tNode: TStylingNode, isClassBased: boolean): DebugStylingConfig {\n  const hasMapBindings = hasConfig(\n      tNode, isClassBased ? TNodeFlags.hasClassMapBindings : TNodeFlags.hasStyleMapBindings);\n  const hasPropBindings = hasConfig(\n      tNode, isClassBased ? TNodeFlags.hasClassPropBindings : TNodeFlags.hasStylePropBindings);\n  const hasCollisions = hasConfig(\n      tNode,\n      isClassBased ? TNodeFlags.hasDuplicateClassBindings : TNodeFlags.hasDuplicateStyleBindings);\n  const hasTemplateBindings = hasConfig(\n      tNode,\n      isClassBased ? TNodeFlags.hasTemplateClassBindings : TNodeFlags.hasTemplateStyleBindings);\n  const hasHostBindings = hasConfig(\n      tNode, isClassBased ? TNodeFlags.hasHostClassBindings : TNodeFlags.hasHostStyleBindings);\n\n  // `firstTemplatePass` here is false because the context has already been constructed\n  // directly within the behavior of the debugging tools (outside of style/class debugging,\n  // the context is constructed during the first template pass).\n  const allowDirectStyling = _allowDirectStyling(tNode, isClassBased, false);\n  return {\n      hasMapBindings,       //\n      hasPropBindings,      //\n      hasCollisions,        //\n      hasTemplateBindings,  //\n      hasHostBindings,      //\n      allowDirectStyling,   //\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AttributeMarker, ComponentTemplate} from '..';\nimport {SchemaMetadata} from '../../core';\nimport {assertDefined} from '../../util/assert';\nimport {createNamedArrayType} from '../../util/named_array_type';\nimport {initNgDevMode} from '../../util/ng_dev_mode';\nimport {ACTIVE_INDEX, ActiveIndexFlag, CONTAINER_HEADER_OFFSET, LContainer, MOVED_VIEWS, NATIVE} from '../interfaces/container';\nimport {DirectiveDefList, PipeDefList, ViewQueriesFunction} from '../interfaces/definition';\nimport {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, TIcu} from '../interfaces/i18n';\nimport {PropertyAliases, TConstants, TContainerNode, TElementNode, TNode as ITNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TViewNode} from '../interfaces/node';\nimport {SelectorFlags} from '../interfaces/projection';\nimport {TQueries} from '../interfaces/query';\nimport {RComment, RElement, RNode} from '../interfaces/renderer';\nimport {TStylingContext} from '../interfaces/styling';\nimport {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DECLARATION_VIEW, ExpandoInstructions, FLAGS, HEADER_OFFSET, HOST, HookData, INJECTOR, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, RENDERER_FACTORY, SANITIZER, TData, TVIEW, TView as ITView, TView, TViewType, T_HOST} from '../interfaces/view';\nimport {DebugNodeStyling, NodeStylingDebug} from '../styling/styling_debug';\nimport {attachDebugObject} from '../util/debug_utils';\nimport {isStylingContext} from '../util/styling_utils';\nimport {getLContainerActiveIndex, getTNode, unwrapRNode} from '../util/view_utils';\n\nconst NG_DEV_MODE = ((typeof ngDevMode === 'undefined' || !!ngDevMode) && initNgDevMode());\n\n/*\n * This file contains conditionally attached classes which provide human readable (debug) level\n * information for `LView`, `LContainer` and other internal data structures. These data structures\n * are stored internally as array which makes it very difficult during debugging to reason about the\n * current state of the system.\n *\n * Patching the array with extra property does change the array's hidden class' but it does not\n * change the cost of access, therefore this patching should not have significant if any impact in\n * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)\n *\n * So instead of seeing:\n * ```\n * Array(30) [Object, 659, null, â¦]\n * ```\n *\n * You get to see:\n * ```\n * LViewDebug {\n *   views: [...],\n *   flags: {attached: true, ...}\n *   nodes: [\n *     {html: '<div id=\"123\">', ..., nodes: [\n *       {html: '<span>', ..., nodes: null}\n *     ]}\n *   ]\n * }\n * ```\n */\n\nlet LVIEW_COMPONENT_CACHE !: Map<string|null, Array<any>>;\nlet LVIEW_EMBEDDED_CACHE !: Map<string|null, Array<any>>;\nlet LVIEW_ROOT !: Array<any>;\n\ninterface TViewDebug extends ITView {\n  type: TViewType;\n}\n\n/**\n * This function clones a blueprint and creates LView.\n *\n * Simple slice will keep the same type, and we need it to be LView\n */\nexport function cloneToLViewFromTViewBlueprint(tView: TView): LView {\n  const debugTView = tView as TViewDebug;\n  const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);\n  return lView.concat(tView.blueprint) as any;\n}\n\nfunction getLViewToClone(type: TViewType, name: string | null): Array<any> {\n  switch (type) {\n    case TViewType.Root:\n      if (LVIEW_ROOT === undefined) LVIEW_ROOT = new (createNamedArrayType('LRootView'))();\n      return LVIEW_ROOT;\n    case TViewType.Component:\n      if (LVIEW_COMPONENT_CACHE === undefined) LVIEW_COMPONENT_CACHE = new Map();\n      let componentArray = LVIEW_COMPONENT_CACHE.get(name);\n      if (componentArray === undefined) {\n        componentArray = new (createNamedArrayType('LComponentView' + nameSuffix(name)))();\n        LVIEW_COMPONENT_CACHE.set(name, componentArray);\n      }\n      return componentArray;\n    case TViewType.Embedded:\n      if (LVIEW_EMBEDDED_CACHE === undefined) LVIEW_EMBEDDED_CACHE = new Map();\n      let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);\n      if (embeddedArray === undefined) {\n        embeddedArray = new (createNamedArrayType('LEmbeddedView' + nameSuffix(name)))();\n        LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);\n      }\n      return embeddedArray;\n  }\n  throw new Error('unreachable code');\n}\n\nfunction nameSuffix(text: string | null | undefined): string {\n  if (text == null) return '';\n  const index = text.lastIndexOf('_Template');\n  return '_' + (index === -1 ? text : text.substr(0, index));\n}\n\n/**\n * This class is a debug version of Object literal so that we can have constructor name show up\n * in\n * debug tools in ngDevMode.\n */\nexport const TViewConstructor = class TView implements ITView {\n  constructor(\n      public type: TViewType,                                //\n      public id: number,                                     //\n      public blueprint: LView,                               //\n      public template: ComponentTemplate<{}>|null,           //\n      public queries: TQueries|null,                         //\n      public viewQuery: ViewQueriesFunction<{}>|null,        //\n      public node: TViewNode|TElementNode|null,              //\n      public data: TData,                                    //\n      public bindingStartIndex: number,                      //\n      public expandoStartIndex: number,                      //\n      public expandoInstructions: ExpandoInstructions|null,  //\n      public firstCreatePass: boolean,                       //\n      public firstUpdatePass: boolean,                       //\n      public staticViewQueries: boolean,                     //\n      public staticContentQueries: boolean,                  //\n      public preOrderHooks: HookData|null,                   //\n      public preOrderCheckHooks: HookData|null,              //\n      public contentHooks: HookData|null,                    //\n      public contentCheckHooks: HookData|null,               //\n      public viewHooks: HookData|null,                       //\n      public viewCheckHooks: HookData|null,                  //\n      public destroyHooks: HookData|null,                    //\n      public cleanup: any[]|null,                            //\n      public contentQueries: number[]|null,                  //\n      public components: number[]|null,                      //\n      public directiveRegistry: DirectiveDefList|null,       //\n      public pipeRegistry: PipeDefList|null,                 //\n      public firstChild: TNode|null,                         //\n      public schemas: SchemaMetadata[]|null,                 //\n      public consts: TConstants|null,                        //\n      ) {}\n\n  get template_(): string {\n    const buf: string[] = [];\n    processTNodeChildren(this.firstChild, buf);\n    return buf.join('');\n  }\n};\n\nexport const TNodeConstructor = class TNode implements ITNode {\n  constructor(\n      public tView_: TView,                                                    //\n      public type: TNodeType,                                                  //\n      public index: number,                                                    //\n      public injectorIndex: number,                                            //\n      public directiveStart: number,                                           //\n      public directiveEnd: number,                                             //\n      public propertyBindings: number[]|null,                                  //\n      public flags: TNodeFlags,                                                //\n      public providerIndexes: TNodeProviderIndexes,                            //\n      public tagName: string|null,                                             //\n      public attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null,  //\n      public localNames: (string|number)[]|null,                               //\n      public initialInputs: (string[]|null)[]|null|undefined,                  //\n      public inputs: PropertyAliases|null,                                     //\n      public outputs: PropertyAliases|null,                                    //\n      public tViews: ITView|ITView[]|null,                                     //\n      public next: ITNode|null,                                                //\n      public projectionNext: ITNode|null,                                      //\n      public child: ITNode|null,                                               //\n      public parent: TElementNode|TContainerNode|null,                         //\n      public projection: number|(ITNode|RNode[])[]|null,                       //\n      public styles: TStylingContext|null,                                     //\n      public classes: TStylingContext|null,                                    //\n      ) {}\n\n  get type_(): string {\n    switch (this.type) {\n      case TNodeType.Container:\n        return 'TNodeType.Container';\n      case TNodeType.Element:\n        return 'TNodeType.Element';\n      case TNodeType.ElementContainer:\n        return 'TNodeType.ElementContainer';\n      case TNodeType.IcuContainer:\n        return 'TNodeType.IcuContainer';\n      case TNodeType.Projection:\n        return 'TNodeType.Projection';\n      case TNodeType.View:\n        return 'TNodeType.View';\n      default:\n        return 'TNodeType.???';\n    }\n  }\n\n  get flags_(): string {\n    const flags: string[] = [];\n    if (this.flags & TNodeFlags.hasClassInput) flags.push('TNodeFlags.hasClassInput');\n    if (this.flags & TNodeFlags.hasContentQuery) flags.push('TNodeFlags.hasContentQuery');\n    if (this.flags & TNodeFlags.hasStyleInput) flags.push('TNodeFlags.hasStyleInput');\n    if (this.flags & TNodeFlags.hasInitialStyling) flags.push('TNodeFlags.hasInitialStyling');\n    if (this.flags & TNodeFlags.hasHostBindings) flags.push('TNodeFlags.hasHostBindings');\n    if (this.flags & TNodeFlags.isComponentHost) flags.push('TNodeFlags.isComponentHost');\n    if (this.flags & TNodeFlags.isDirectiveHost) flags.push('TNodeFlags.isDirectiveHost');\n    if (this.flags & TNodeFlags.isDetached) flags.push('TNodeFlags.isDetached');\n    if (this.flags & TNodeFlags.isProjected) flags.push('TNodeFlags.isProjected');\n    return flags.join('|');\n  }\n\n  get template_(): string {\n    const buf: string[] = [];\n    buf.push('<', this.tagName || this.type_);\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length;) {\n        const attrName = this.attrs[i++];\n        if (typeof attrName == 'number') {\n          break;\n        }\n        const attrValue = this.attrs[i++];\n        buf.push(' ', attrName as string, '=\"', attrValue as string, '\"');\n      }\n    }\n    buf.push('>');\n    processTNodeChildren(this.child, buf);\n    buf.push('</', this.tagName || this.type_, '>');\n    return buf.join('');\n  }\n};\n\nfunction processTNodeChildren(tNode: TNode | null, buf: string[]) {\n  while (tNode) {\n    buf.push((tNode as any as{template_: string}).template_);\n    tNode = tNode.next;\n  }\n}\n\nconst TViewData = NG_DEV_MODE && createNamedArrayType('TViewData') || null !as ArrayConstructor;\nlet TVIEWDATA_EMPTY:\n    unknown[];  // can't initialize here or it will not be tree shaken, because `LView`\n                // constructor could have side-effects.\n/**\n * This function clones a blueprint and creates TData.\n *\n * Simple slice will keep the same type, and we need it to be TData\n */\nexport function cloneToTViewData(list: any[]): TData {\n  if (TVIEWDATA_EMPTY === undefined) TVIEWDATA_EMPTY = new TViewData();\n  return TVIEWDATA_EMPTY.concat(list) as any;\n}\n\nexport const LViewBlueprint =\n    NG_DEV_MODE && createNamedArrayType('LViewBlueprint') || null !as ArrayConstructor;\nexport const MatchesArray =\n    NG_DEV_MODE && createNamedArrayType('MatchesArray') || null !as ArrayConstructor;\nexport const TViewComponents =\n    NG_DEV_MODE && createNamedArrayType('TViewComponents') || null !as ArrayConstructor;\nexport const TNodeLocalNames =\n    NG_DEV_MODE && createNamedArrayType('TNodeLocalNames') || null !as ArrayConstructor;\nexport const TNodeInitialInputs =\n    NG_DEV_MODE && createNamedArrayType('TNodeInitialInputs') || null !as ArrayConstructor;\nexport const TNodeInitialData =\n    NG_DEV_MODE && createNamedArrayType('TNodeInitialData') || null !as ArrayConstructor;\nexport const LCleanup =\n    NG_DEV_MODE && createNamedArrayType('LCleanup') || null !as ArrayConstructor;\nexport const TCleanup =\n    NG_DEV_MODE && createNamedArrayType('TCleanup') || null !as ArrayConstructor;\n\n\n\nexport function attachLViewDebug(lView: LView) {\n  attachDebugObject(lView, new LViewDebug(lView));\n}\n\nexport function attachLContainerDebug(lContainer: LContainer) {\n  attachDebugObject(lContainer, new LContainerDebug(lContainer));\n}\n\nexport function toDebug(obj: LView): LViewDebug;\nexport function toDebug(obj: LView | null): LViewDebug|null;\nexport function toDebug(obj: LView | LContainer | null): LViewDebug|LContainerDebug|null;\nexport function toDebug(obj: any): any {\n  if (obj) {\n    const debug = (obj as any).debug;\n    assertDefined(debug, 'Object does not have a debug representation.');\n    return debug;\n  } else {\n    return obj;\n  }\n}\n\n/**\n * Use this method to unwrap a native element in `LView` and convert it into HTML for easier\n * reading.\n *\n * @param value possibly wrapped native DOM node.\n * @param includeChildren If `true` then the serialized HTML form will include child elements\n * (same\n * as `outerHTML`). If `false` then the serialized HTML form will only contain the element\n * itself\n * (will not serialize child elements).\n */\nfunction toHtml(value: any, includeChildren: boolean = false): string|null {\n  const node: HTMLElement|null = unwrapRNode(value) as any;\n  if (node) {\n    const isTextNode = node.nodeType === Node.TEXT_NODE;\n    const outerHTML = (isTextNode ? node.textContent : node.outerHTML) || '';\n    if (includeChildren || isTextNode) {\n      return outerHTML;\n    } else {\n      const innerHTML = '>' + node.innerHTML + '<';\n      return (outerHTML.split(innerHTML)[0]) + '>';\n    }\n  } else {\n    return null;\n  }\n}\n\nexport class LViewDebug {\n  constructor(private readonly _raw_lView: LView) {}\n\n  /**\n   * Flags associated with the `LView` unpacked into a more readable state.\n   */\n  get flags() {\n    const flags = this._raw_lView[FLAGS];\n    return {\n      __raw__flags__: flags,\n      initPhaseState: flags & LViewFlags.InitPhaseStateMask,\n      creationMode: !!(flags & LViewFlags.CreationMode),\n      firstViewPass: !!(flags & LViewFlags.FirstLViewPass),\n      checkAlways: !!(flags & LViewFlags.CheckAlways),\n      dirty: !!(flags & LViewFlags.Dirty),\n      attached: !!(flags & LViewFlags.Attached),\n      destroyed: !!(flags & LViewFlags.Destroyed),\n      isRoot: !!(flags & LViewFlags.IsRoot),\n      indexWithinInitPhase: flags >> LViewFlags.IndexWithinInitPhaseShift,\n    };\n  }\n  get parent(): LViewDebug|LContainerDebug|null { return toDebug(this._raw_lView[PARENT]); }\n  get host(): string|null { return toHtml(this._raw_lView[HOST], true); }\n  get html(): string { return (this.nodes || []).map(node => toHtml(node.native, true)).join(''); }\n  get context(): {}|null { return this._raw_lView[CONTEXT]; }\n  /**\n   * The tree of nodes associated with the current `LView`. The nodes have been normalized into\n   * a\n   * tree structure with relevant details pulled out for readability.\n   */\n  get nodes(): DebugNode[]|null {\n    const lView = this._raw_lView;\n    const tNode = lView[TVIEW].firstChild;\n    return toDebugNodes(tNode, lView);\n  }\n\n  get tView() { return this._raw_lView[TVIEW]; }\n  get cleanup() { return this._raw_lView[CLEANUP]; }\n  get injector() { return this._raw_lView[INJECTOR]; }\n  get rendererFactory() { return this._raw_lView[RENDERER_FACTORY]; }\n  get renderer() { return this._raw_lView[RENDERER]; }\n  get sanitizer() { return this._raw_lView[SANITIZER]; }\n  get childHead() { return toDebug(this._raw_lView[CHILD_HEAD]); }\n  get next() { return toDebug(this._raw_lView[NEXT]); }\n  get childTail() { return toDebug(this._raw_lView[CHILD_TAIL]); }\n  get declarationView() { return toDebug(this._raw_lView[DECLARATION_VIEW]); }\n  get queries() { return this._raw_lView[QUERIES]; }\n  get tHost() { return this._raw_lView[T_HOST]; }\n\n  /**\n   * Normalized view of child views (and containers) attached at this location.\n   */\n  get childViews(): Array<LViewDebug|LContainerDebug> {\n    const childViews: Array<LViewDebug|LContainerDebug> = [];\n    let child = this.childHead;\n    while (child) {\n      childViews.push(child);\n      child = child.next;\n    }\n    return childViews;\n  }\n}\n\nexport interface DebugNode {\n  html: string|null;\n  native: Node;\n  styles: DebugNodeStyling|null;\n  classes: DebugNodeStyling|null;\n  nodes: DebugNode[]|null;\n  component: LViewDebug|null;\n}\n\n/**\n * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.\n *\n * @param tNode\n * @param lView\n */\nexport function toDebugNodes(tNode: TNode | null, lView: LView): DebugNode[]|null {\n  if (tNode) {\n    const debugNodes: DebugNode[] = [];\n    let tNodeCursor: TNode|null = tNode;\n    while (tNodeCursor) {\n      debugNodes.push(buildDebugNode(tNodeCursor, lView, tNodeCursor.index));\n      tNodeCursor = tNodeCursor.next;\n    }\n    return debugNodes;\n  } else {\n    return null;\n  }\n}\n\nexport function buildDebugNode(tNode: TNode, lView: LView, nodeIndex: number): DebugNode {\n  const rawValue = lView[nodeIndex];\n  const native = unwrapRNode(rawValue);\n  const componentLViewDebug = toDebug(readLViewValue(rawValue));\n  const styles = isStylingContext(tNode.styles) ?\n      new NodeStylingDebug(tNode.styles as any as TStylingContext, tNode, lView, false) :\n      null;\n  const classes = isStylingContext(tNode.classes) ?\n      new NodeStylingDebug(tNode.classes as any as TStylingContext, tNode, lView, true) :\n      null;\n  return {\n    html: toHtml(native),\n    native: native as any, styles, classes,\n    nodes: toDebugNodes(tNode.child, lView),\n    component: componentLViewDebug,\n  };\n}\n\nexport class LContainerDebug {\n  constructor(private readonly _raw_lContainer: LContainer) {}\n\n  get activeIndex(): number { return getLContainerActiveIndex(this._raw_lContainer); }\n  get hasTransplantedViews(): boolean {\n    return (this._raw_lContainer[ACTIVE_INDEX] & ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS) ===\n        ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS;\n  }\n  get views(): LViewDebug[] {\n    return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET)\n        .map(toDebug as(l: LView) => LViewDebug);\n  }\n  get parent(): LViewDebug|LContainerDebug|null { return toDebug(this._raw_lContainer[PARENT]); }\n  get movedViews(): LView[]|null { return this._raw_lContainer[MOVED_VIEWS]; }\n  get host(): RElement|RComment|LView { return this._raw_lContainer[HOST]; }\n  get native(): RComment { return this._raw_lContainer[NATIVE]; }\n  get next() { return toDebug(this._raw_lContainer[NEXT]); }\n}\n\n/**\n * Return an `LView` value if found.\n *\n * @param value `LView` if any\n */\nexport function readLViewValue(value: any): LView|null {\n  while (Array.isArray(value)) {\n    // This check is not quite right, as it does not take into account `StylingContext`\n    // This is why it is in debug, not in util.ts\n    if (value.length >= HEADER_OFFSET - 1) return value as LView;\n    value = value[HOST];\n  }\n  return null;\n}\n\nexport class I18NDebugItem {\n  [key: string]: any;\n\n  get tNode() { return getTNode(this.nodeIndex, this._lView); }\n\n  constructor(\n      public __raw_opCode: any, private _lView: LView, public nodeIndex: number,\n      public type: string) {}\n}\n\n/**\n * Turns a list of \"Create\" & \"Update\" OpCodes into a human-readable list of operations for\n * debugging purposes.\n * @param mutateOpCodes mutation opCodes to read\n * @param updateOpCodes update opCodes to read\n * @param icus list of ICU expressions\n * @param lView The view the opCodes are acting on\n */\nexport function attachI18nOpCodesDebug(\n    mutateOpCodes: I18nMutateOpCodes, updateOpCodes: I18nUpdateOpCodes, icus: TIcu[] | null,\n    lView: LView) {\n  attachDebugObject(mutateOpCodes, new I18nMutateOpCodesDebug(mutateOpCodes, lView));\n  attachDebugObject(updateOpCodes, new I18nUpdateOpCodesDebug(updateOpCodes, icus, lView));\n\n  if (icus) {\n    icus.forEach(icu => {\n      icu.create.forEach(\n          icuCase => { attachDebugObject(icuCase, new I18nMutateOpCodesDebug(icuCase, lView)); });\n      icu.update.forEach(icuCase => {\n        attachDebugObject(icuCase, new I18nUpdateOpCodesDebug(icuCase, icus, lView));\n      });\n    });\n  }\n}\n\nexport class I18nMutateOpCodesDebug implements I18nOpCodesDebug {\n  constructor(private readonly __raw_opCodes: I18nMutateOpCodes, private readonly __lView: LView) {}\n\n  /**\n   * A list of operation information about how the OpCodes will act on the view.\n   */\n  get operations() {\n    const {__lView, __raw_opCodes} = this;\n    const results: any[] = [];\n\n    for (let i = 0; i < __raw_opCodes.length; i++) {\n      const opCode = __raw_opCodes[i];\n      let result: any;\n      if (typeof opCode === 'string') {\n        result = {\n          __raw_opCode: opCode,\n          type: 'Create Text Node',\n          nodeIndex: __raw_opCodes[++i],\n          text: opCode,\n        };\n      }\n\n      if (typeof opCode === 'number') {\n        switch (opCode & I18nMutateOpCode.MASK_OPCODE) {\n          case I18nMutateOpCode.AppendChild:\n            const destinationNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_PARENT;\n            result = new I18NDebugItem(opCode, __lView, destinationNodeIndex, 'AppendChild');\n            break;\n          case I18nMutateOpCode.Select:\n            const nodeIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n            result = new I18NDebugItem(opCode, __lView, nodeIndex, 'Select');\n            break;\n          case I18nMutateOpCode.ElementEnd:\n            let elementIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n            result = new I18NDebugItem(opCode, __lView, elementIndex, 'ElementEnd');\n            break;\n          case I18nMutateOpCode.Attr:\n            elementIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n            result = new I18NDebugItem(opCode, __lView, elementIndex, 'Attr');\n            result['attrName'] = __raw_opCodes[++i];\n            result['attrValue'] = __raw_opCodes[++i];\n            break;\n        }\n      }\n\n      if (!result) {\n        switch (opCode) {\n          case COMMENT_MARKER:\n            result = {\n              __raw_opCode: opCode,\n              type: 'COMMENT_MARKER',\n              commentValue: __raw_opCodes[++i],\n              nodeIndex: __raw_opCodes[++i],\n            };\n            break;\n          case ELEMENT_MARKER:\n            result = {\n              __raw_opCode: opCode,\n              type: 'ELEMENT_MARKER',\n            };\n            break;\n        }\n      }\n\n      if (!result) {\n        result = {\n          __raw_opCode: opCode,\n          type: 'Unknown Op Code',\n          code: opCode,\n        };\n      }\n\n      results.push(result);\n    }\n\n    return results;\n  }\n}\n\nexport class I18nUpdateOpCodesDebug implements I18nOpCodesDebug {\n  constructor(\n      private readonly __raw_opCodes: I18nUpdateOpCodes, private readonly icus: TIcu[]|null,\n      private readonly __lView: LView) {}\n\n  /**\n   * A list of operation information about how the OpCodes will act on the view.\n   */\n  get operations() {\n    const {__lView, __raw_opCodes, icus} = this;\n    const results: any[] = [];\n\n    for (let i = 0; i < __raw_opCodes.length; i++) {\n      // bit code to check if we should apply the next update\n      const checkBit = __raw_opCodes[i] as number;\n      // Number of opCodes to skip until next set of update codes\n      const skipCodes = __raw_opCodes[++i] as number;\n      let value = '';\n      for (let j = i + 1; j <= (i + skipCodes); j++) {\n        const opCode = __raw_opCodes[j];\n        if (typeof opCode === 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // It's a binding index whose value is negative\n            // We cannot know the value of the binding so we only show the index\n            value += `ï¿½${-opCode - 1}ï¿½`;\n          } else {\n            const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n            let tIcuIndex: number;\n            let tIcu: TIcu;\n            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n              case I18nUpdateOpCode.Attr:\n                const attrName = __raw_opCodes[++j] as string;\n                const sanitizeFn = __raw_opCodes[++j];\n                results.push({\n                  __raw_opCode: opCode,\n                  checkBit,\n                  type: 'Attr',\n                  attrValue: value, attrName, sanitizeFn,\n                });\n                break;\n              case I18nUpdateOpCode.Text:\n                results.push({\n                  __raw_opCode: opCode,\n                  checkBit,\n                  type: 'Text', nodeIndex,\n                  text: value,\n                });\n                break;\n              case I18nUpdateOpCode.IcuSwitch:\n                tIcuIndex = __raw_opCodes[++j] as number;\n                tIcu = icus ![tIcuIndex];\n                let result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuSwitch');\n                result['tIcuIndex'] = tIcuIndex;\n                result['checkBit'] = checkBit;\n                result['mainBinding'] = value;\n                result['tIcu'] = tIcu;\n                results.push(result);\n                break;\n              case I18nUpdateOpCode.IcuUpdate:\n                tIcuIndex = __raw_opCodes[++j] as number;\n                tIcu = icus ![tIcuIndex];\n                result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuUpdate');\n                result['tIcuIndex'] = tIcuIndex;\n                result['checkBit'] = checkBit;\n                result['tIcu'] = tIcu;\n                results.push(result);\n                break;\n            }\n          }\n        }\n      }\n      i += skipCodes;\n    }\n    return results;\n  }\n}\n\nexport interface I18nOpCodesDebug { operations: any[]; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Injector} from '../../di';\nimport {ErrorHandler} from '../../error_handler';\nimport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from '../../metadata/schema';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {validateAgainstEventAttributes, validateAgainstEventProperties} from '../../sanitization/sanitization';\nimport {Sanitizer} from '../../sanitization/sanitizer';\nimport {assertDataInRange, assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertNotEqual, assertNotSame} from '../../util/assert';\nimport {createNamedArrayType} from '../../util/named_array_type';\nimport {initNgDevMode} from '../../util/ng_dev_mode';\nimport {normalizeDebugBindingName, normalizeDebugBindingValue} from '../../util/ng_reflect';\nimport {assertFirstCreatePass, assertLContainer, assertLView} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {getFactoryDef} from '../definition';\nimport {diPublicInInjector, getNodeInjectable, getOrCreateNodeInjectorForNode} from '../di';\nimport {throwMultipleComponentError} from '../errors';\nimport {executeCheckHooks, executeInitAndCheckHooks, incrementInitPhaseFlags, registerPreOrderHooks} from '../hooks';\nimport {ACTIVE_INDEX, ActiveIndexFlag, CONTAINER_HEADER_OFFSET, LContainer, MOVED_VIEWS} from '../interfaces/container';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, PipeDefListOrFactory, RenderFlags, ViewQueriesFunction} from '../interfaces/definition';\nimport {INJECTOR_BLOOM_PARENT_SIZE, NodeInjectorFactory} from '../interfaces/injector';\nimport {AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliasValue, PropertyAliases, TAttributes, TConstants, TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TProjectionNode, TViewNode} from '../interfaces/node';\nimport {RComment, RElement, RNode, RText, Renderer3, RendererFactory3, isProceduralRenderer} from '../interfaces/renderer';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {isComponentDef, isComponentHost, isContentQueryHost, isLContainer, isRootView} from '../interfaces/type_checks';\nimport {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, ExpandoInstructions, FLAGS, HEADER_OFFSET, HOST, INJECTOR, InitPhaseState, LView, LViewFlags, NEXT, PARENT, RENDERER, RENDERER_FACTORY, RootContext, RootContextFlags, SANITIZER, TData, TVIEW, TView, TViewType, T_HOST} from '../interfaces/view';\nimport {assertNodeOfPossibleTypes} from '../node_assert';\nimport {isNodeMatchingSelectorList} from '../node_selector_matcher';\nimport {ActiveElementFlags, enterView, executeElementExitFn, getBindingsEnabled, getCheckNoChangesMode, getIsParent, getPreviousOrParentTNode, getSelectedIndex, hasActiveElementFlag, incrementActiveDirectiveId, leaveView, leaveViewProcessExit, setActiveHostElement, setBindingIndex, setBindingRoot, setCheckNoChangesMode, setCurrentDirectiveDef, setCurrentQueryIndex, setPreviousOrParentTNode, setSelectedIndex} from '../state';\nimport {renderStylingMap, writeStylingValueDirectly} from '../styling/bindings';\nimport {NO_CHANGE} from '../tokens';\nimport {isAnimationProp} from '../util/attrs_utils';\nimport {INTERPOLATION_DELIMITER, renderStringify, stringifyForError} from '../util/misc_utils';\nimport {getInitialStylingValue} from '../util/styling_utils';\nimport {getLViewParent} from '../util/view_traversal_utils';\nimport {getComponentLViewByIndex, getNativeByIndex, getNativeByTNode, getTNode, isCreationMode, readPatchedLView, resetPreOrderHookFlags, unwrapRNode, viewAttachedToChangeDetector} from '../util/view_utils';\n\nimport {selectIndexInternal} from './advance';\nimport {LCleanup, LViewBlueprint, MatchesArray, TCleanup, TNodeConstructor, TNodeInitialInputs, TNodeLocalNames, TViewComponents, TViewConstructor, attachLContainerDebug, attachLViewDebug, cloneToLViewFromTViewBlueprint, cloneToTViewData} from './lview_debug';\n\n\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = (() => Promise.resolve(null))();\n\n/** Sets the host bindings for the current view. */\nexport function setHostBindings(tView: TView, lView: LView): void {\n  const selectedIndex = getSelectedIndex();\n  try {\n    if (tView.expandoInstructions !== null) {\n      let bindingRootIndex = setBindingIndex(tView.expandoStartIndex);\n      setBindingRoot(bindingRootIndex);\n      let currentDirectiveIndex = -1;\n      let currentElementIndex = -1;\n      for (let i = 0; i < tView.expandoInstructions.length; i++) {\n        const instruction = tView.expandoInstructions[i];\n        if (typeof instruction === 'number') {\n          if (instruction <= 0) {\n            // Negative numbers mean that we are starting new EXPANDO block and need to update\n            // the current element and directive index.\n            currentElementIndex = -instruction;\n            setActiveHostElement(currentElementIndex);\n\n            // Injector block and providers are taken into account.\n            const providerCount = (tView.expandoInstructions[++i] as number);\n            bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;\n\n            currentDirectiveIndex = bindingRootIndex;\n          } else {\n            // This is either the injector size (so the binding root can skip over directives\n            // and get to the first set of host bindings on this node) or the host var count\n            // (to get to the next set of host bindings on this node).\n            bindingRootIndex += instruction;\n          }\n          setBindingRoot(bindingRootIndex);\n        } else {\n          // If it's not a number, it's a host binding function that needs to be executed.\n          if (instruction !== null) {\n            // Each directive gets a uniqueId value that is the same for both\n            // create and update calls when the hostBindings function is called. The\n            // directive uniqueId is not set anywhere--it is just incremented between\n            // each hostBindings call and is useful for helping instruction code\n            // uniquely determine which directive is currently active when executed.\n            // It is important that this be called first before the actual instructions\n            // are run because this way the first directive ID value is not zero.\n            incrementActiveDirectiveId();\n\n            setBindingIndex(bindingRootIndex);\n            const hostCtx = unwrapRNode(lView[currentDirectiveIndex]);\n            instruction(RenderFlags.Update, hostCtx, currentElementIndex);\n          }\n          currentDirectiveIndex++;\n        }\n      }\n    }\n  } finally {\n    setActiveHostElement(selectedIndex);\n  }\n}\n\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView: TView, lView: LView): void {\n  const contentQueries = tView.contentQueries;\n  if (contentQueries !== null) {\n    for (let i = 0; i < contentQueries.length; i += 2) {\n      const queryStartIdx = contentQueries[i];\n      const directiveDefIdx = contentQueries[i + 1];\n      if (directiveDefIdx !== -1) {\n        const directiveDef = tView.data[directiveDefIdx] as DirectiveDef<any>;\n        ngDevMode &&\n            assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n        setCurrentQueryIndex(queryStartIdx);\n        directiveDef.contentQueries !(RenderFlags.Update, lView[directiveDefIdx], directiveDefIdx);\n      }\n    }\n  }\n}\n\n/** Refreshes child components in the current view (update mode). */\nfunction refreshChildComponents(hostLView: LView, components: number[]): void {\n  for (let i = 0; i < components.length; i++) {\n    refreshComponent(hostLView, components[i]);\n  }\n}\n\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView: LView, components: number[]): void {\n  for (let i = 0; i < components.length; i++) {\n    renderComponent(hostLView, components[i]);\n  }\n}\n\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param name the tag name\n * @param renderer A renderer to use\n * @returns the element created\n */\nexport function elementCreate(\n    name: string, renderer: Renderer3, namespace: string | null): RElement {\n  if (isProceduralRenderer(renderer)) {\n    return renderer.createElement(name, namespace);\n  } else {\n    return namespace === null ? renderer.createElement(name) :\n                                renderer.createElementNS(namespace, name);\n  }\n}\n\nexport function createLView<T>(\n    parentLView: LView | null, tView: TView, context: T | null, flags: LViewFlags,\n    host: RElement | null, tHostNode: TViewNode | TElementNode | null,\n    rendererFactory?: RendererFactory3 | null, renderer?: Renderer3 | null,\n    sanitizer?: Sanitizer | null, injector?: Injector | null): LView {\n  const lView =\n      ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice() as LView;\n  lView[HOST] = host;\n  lView[FLAGS] = flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.FirstLViewPass;\n  resetPreOrderHookFlags(lView);\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context;\n  lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY]) !;\n  ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\n  lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER]) !;\n  ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n  lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null !;\n  lView[INJECTOR as any] = injector || parentLView && parentLView[INJECTOR] || null;\n  lView[T_HOST] = tHostNode;\n  ngDevMode && assertEqual(\n                   tView.type == TViewType.Embedded ? parentLView !== null : true, true,\n                   'Embedded views must have parentLView');\n  lView[DECLARATION_COMPONENT_VIEW] =\n      tView.type == TViewType.Embedded ? parentLView ![DECLARATION_COMPONENT_VIEW] : lView;\n  ngDevMode && attachLViewDebug(lView);\n  return lView;\n}\n\n/**\n * Create and stores the TNode, and hooks it up to the tree.\n *\n * @param tView The current `TView`.\n * @param tHostNode This is a hack and we should not have to pass this value in. It is only used to\n * determine if the parent belongs to a different tView. Instead we should not have parentTView\n * point to TView other the current one.\n * @param index The index at which the TNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of TNode to create\n * @param native The native element for this node, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n */\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.Element,\n    name: string | null, attrs: TAttributes | null): TElementNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.Container,\n    name: string | null, attrs: TAttributes | null): TContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.Projection, name: null,\n    attrs: TAttributes | null): TProjectionNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.ElementContainer,\n    name: string | null, attrs: TAttributes | null): TElementContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.IcuContainer, name: null,\n    attrs: TAttributes | null): TElementContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType, name: string | null,\n    attrs: TAttributes | null): TElementNode&TContainerNode&TElementContainerNode&TProjectionNode&\n    TIcuContainerNode {\n  // Keep this function short, so that the VM will inline it.\n  const adjustedIndex = index + HEADER_OFFSET;\n  const tNode = tView.data[adjustedIndex] as TNode ||\n      createTNodeAtIndex(tView, tHostNode, adjustedIndex, type, name, attrs);\n  setPreviousOrParentTNode(tNode, true);\n  return tNode as TElementNode & TViewNode & TContainerNode & TElementContainerNode &\n      TProjectionNode & TIcuContainerNode;\n}\n\nfunction createTNodeAtIndex(\n    tView: TView, tHostNode: TNode | null, adjustedIndex: number, type: TNodeType,\n    name: string | null, attrs: TAttributes | null) {\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  const isParent = getIsParent();\n  const parent =\n      isParent ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\n  // Parents cannot cross component boundaries because components will be used in multiple places,\n  // so it's only set if the view is the same.\n  const parentInSameView = parent && parent !== tHostNode;\n  const tParentNode = parentInSameView ? parent as TElementNode | TContainerNode : null;\n  const tNode = tView.data[adjustedIndex] =\n      createTNode(tView, tParentNode, type, adjustedIndex, name, attrs);\n  // Assign a pointer to the first child node of a given view. The first node is not always the one\n  // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n  // the index 1 or more, so we can't just check node index.\n  if (tView.firstChild === null) {\n    tView.firstChild = tNode;\n  }\n  if (previousOrParentTNode) {\n    if (isParent && previousOrParentTNode.child == null &&\n        (tNode.parent !== null || previousOrParentTNode.type === TNodeType.View)) {\n      // We are in the same view, which means we are adding content node to the parent view.\n      previousOrParentTNode.child = tNode;\n    } else if (!isParent) {\n      previousOrParentTNode.next = tNode;\n    }\n  }\n  return tNode;\n}\n\nexport function assignTViewNodeToLView(\n    tView: TView, tParentNode: TNode | null, index: number, lView: LView): TViewNode {\n  // View nodes are not stored in data because they can be added / removed at runtime (which\n  // would cause indices to change). Their TNodes are instead stored in tView.node.\n  let tNode = tView.node;\n  if (tNode == null) {\n    ngDevMode && tParentNode &&\n        assertNodeOfPossibleTypes(tParentNode, TNodeType.Element, TNodeType.Container);\n    tView.node = tNode = createTNode(\n        tView,\n        tParentNode as TElementNode | TContainerNode | null,  //\n        TNodeType.View, index, null, null) as TViewNode;\n  }\n\n  return lView[T_HOST] = tNode as TViewNode;\n}\n\n\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\n * template passes.\n *\n * @param view The LView containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n */\nexport function allocExpando(view: LView, numSlotsToAlloc: number) {\n  ngDevMode && assertGreaterThan(\n                   numSlotsToAlloc, 0, 'The number of slots to alloc should be greater than 0');\n  if (numSlotsToAlloc > 0) {\n    const tView = view[TVIEW];\n    if (tView.firstCreatePass) {\n      for (let i = 0; i < numSlotsToAlloc; i++) {\n        tView.blueprint.push(null);\n        tView.data.push(null);\n        view.push(null);\n      }\n\n      // We should only increment the expando start index if there aren't already directives\n      // and injectors saved in the \"expando\" section\n      if (!tView.expandoInstructions) {\n        tView.expandoStartIndex += numSlotsToAlloc;\n      } else {\n        // Since we're adding the dynamic nodes into the expando section, we need to let the host\n        // bindings know that they should skip x slots\n        tView.expandoInstructions.push(numSlotsToAlloc);\n      }\n    }\n  }\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nexport function renderView<T>(lView: LView, tView: TView, context: T): void {\n  ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n  enterView(lView, lView[T_HOST]);\n  try {\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(RenderFlags.Create, viewQuery, context);\n    }\n\n    // Execute a template associated with this view, if it exists. A template function might not be\n    // defined for the root component views.\n    const templateFn = tView.template;\n    if (templateFn !== null) {\n      executeTemplate(lView, templateFn, RenderFlags.Create, context);\n    }\n\n    // This needs to be set before children are processed to support recursive components.\n    // This must be set to false immediately after the first creation run because in an\n    // ngFor loop, all the views will be created together before update mode runs and turns\n    // off firstCreatePass. If we don't set it here, instances will perform directive\n    // matching, etc again and again.\n    if (tView.firstCreatePass) {\n      tView.firstCreatePass = false;\n    }\n\n    // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n    // content queries are resolved during change detection (i.e. update mode), after embedded\n    // views are refreshed (see block above).\n    if (tView.staticContentQueries) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // We must materialize query results before child components are processed\n    // in case a child component has projected a container. The LContainer needs\n    // to exist so the embedded views are properly attached by the container.\n    if (tView.staticViewQueries) {\n      executeViewQueryFn(RenderFlags.Update, tView.viewQuery !, context);\n    }\n\n    // Render child component views.\n    const components = tView.components;\n    if (components !== null) {\n      renderChildComponents(lView, components);\n    }\n\n  } finally {\n    lView[FLAGS] &= ~LViewFlags.CreationMode;\n    leaveView();\n  }\n}\n\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\nexport function refreshView<T>(\n    lView: LView, tView: TView, templateFn: ComponentTemplate<{}>| null, context: T) {\n  ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n  enterView(lView, lView[T_HOST]);\n  const flags = lView[FLAGS];\n  try {\n    resetPreOrderHookFlags(lView);\n\n    setBindingIndex(tView.bindingStartIndex);\n    if (templateFn !== null) {\n      executeTemplate(lView, templateFn, RenderFlags.Update, context);\n    }\n\n    const checkNoChangesMode = getCheckNoChangesMode();\n    const hooksInitPhaseCompleted =\n        (flags & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n\n    // execute pre-order hooks (OnInit, OnChanges, DoChanges)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!checkNoChangesMode) {\n      if (hooksInitPhaseCompleted) {\n        const preOrderCheckHooks = tView.preOrderCheckHooks;\n        if (preOrderCheckHooks !== null) {\n          executeCheckHooks(lView, preOrderCheckHooks, null);\n        }\n      } else {\n        const preOrderHooks = tView.preOrderHooks;\n        if (preOrderHooks !== null) {\n          executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, null);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.OnInitHooksToBeRun);\n      }\n    }\n\n    refreshDynamicEmbeddedViews(lView);\n\n    // Content query results must be refreshed before content hooks are called.\n    if (tView.contentQueries !== null) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // execute content hooks (AfterContentInit, AfterContentChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!checkNoChangesMode) {\n      if (hooksInitPhaseCompleted) {\n        const contentCheckHooks = tView.contentCheckHooks;\n        if (contentCheckHooks !== null) {\n          executeCheckHooks(lView, contentCheckHooks);\n        }\n      } else {\n        const contentHooks = tView.contentHooks;\n        if (contentHooks !== null) {\n          executeInitAndCheckHooks(\n              lView, contentHooks, InitPhaseState.AfterContentInitHooksToBeRun);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterContentInitHooksToBeRun);\n      }\n    }\n\n    setHostBindings(tView, lView);\n\n    // Refresh child component views.\n    const components = tView.components;\n    if (components !== null) {\n      refreshChildComponents(lView, components);\n    }\n\n    // View queries must execute after refreshing child components because a template in this view\n    // could be inserted in a child component. If the view query executes before child component\n    // refresh, the template might not yet be inserted.\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(RenderFlags.Update, viewQuery, context);\n    }\n\n    // execute view hooks (AfterViewInit, AfterViewChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!checkNoChangesMode) {\n      if (hooksInitPhaseCompleted) {\n        const viewCheckHooks = tView.viewCheckHooks;\n        if (viewCheckHooks !== null) {\n          executeCheckHooks(lView, viewCheckHooks);\n        }\n      } else {\n        const viewHooks = tView.viewHooks;\n        if (viewHooks !== null) {\n          executeInitAndCheckHooks(lView, viewHooks, InitPhaseState.AfterViewInitHooksToBeRun);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterViewInitHooksToBeRun);\n      }\n    }\n\n  } finally {\n    if (tView.firstUpdatePass === true) {\n      tView.firstUpdatePass = false;\n    }\n    lView[FLAGS] &= ~(LViewFlags.Dirty | LViewFlags.FirstLViewPass);\n    leaveViewProcessExit();\n  }\n}\n\nexport function renderComponentOrTemplate<T>(\n    hostView: LView, templateFn: ComponentTemplate<{}>| null, context: T) {\n  const rendererFactory = hostView[RENDERER_FACTORY];\n  const normalExecutionPath = !getCheckNoChangesMode();\n  const creationModeIsActive = isCreationMode(hostView);\n  try {\n    if (normalExecutionPath && !creationModeIsActive && rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    const tView = hostView[TVIEW];\n    if (creationModeIsActive) {\n      renderView(hostView, tView, context);\n    }\n    refreshView(hostView, tView, templateFn, context);\n  } finally {\n    if (normalExecutionPath && !creationModeIsActive && rendererFactory.end) {\n      rendererFactory.end();\n    }\n  }\n}\n\nfunction executeTemplate<T>(\n    lView: LView, templateFn: ComponentTemplate<T>, rf: RenderFlags, context: T) {\n  const prevSelectedIndex = getSelectedIndex();\n  try {\n    setActiveHostElement(null);\n    if (rf & RenderFlags.Update && lView.length > HEADER_OFFSET) {\n      // When we're updating, inherently select 0 so we don't\n      // have to generate that instruction for most update blocks.\n      selectIndexInternal(lView, 0, getCheckNoChangesMode());\n    }\n    templateFn(rf, context);\n  } finally {\n    if (hasActiveElementFlag(ActiveElementFlags.RunExitFn)) {\n      executeElementExitFn();\n    }\n    setSelectedIndex(prevSelectedIndex);\n  }\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\nexport function executeContentQueries(tView: TView, tNode: TNode, lView: LView) {\n  if (isContentQueryHost(tNode)) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n      const def = tView.data[directiveIndex] as DirectiveDef<any>;\n      if (def.contentQueries) {\n        def.contentQueries(RenderFlags.Create, lView[directiveIndex], directiveIndex);\n      }\n    }\n  }\n}\n\n\n/**\n * Creates directive instances.\n */\nexport function createDirectivesInstances(tView: TView, lView: LView, tNode: TDirectiveHostNode) {\n  if (!getBindingsEnabled()) return;\n  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n  if ((tNode.flags & TNodeFlags.hasHostBindings) === TNodeFlags.hasHostBindings) {\n    invokeDirectivesHostBindings(tView, lView, tNode);\n  }\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nexport function saveResolvedLocalsInData(\n    viewData: LView, tNode: TDirectiveHostNode,\n    localRefExtractor: LocalRefExtractor = getNativeByTNode): void {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ?\n          localRefExtractor(\n              tNode as TElementNode | TContainerNode | TElementContainerNode, viewData) :\n          viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\nexport function getOrCreateTComponentView(def: ComponentDef<any>): TView {\n  return def.tView ||\n      (def.tView = createTView(\n           TViewType.Component, -1, def.template, def.decls, def.vars, def.directiveDefs,\n           def.pipeDefs, def.viewQuery, def.schemas, def.consts));\n}\n\n\n/**\n * Creates a TView instance\n *\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\nexport function createTView(\n    type: TViewType, viewIndex: number, templateFn: ComponentTemplate<any>| null, decls: number,\n    vars: number, directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ViewQueriesFunction<any>| null, schemas: SchemaMetadata[] | null,\n    consts: TConstants | null): TView {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + decls;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  return blueprint[TVIEW as any] = ngDevMode ?\n      new TViewConstructor(\n             type,\n             viewIndex,   // id: number,\n             blueprint,   // blueprint: LView,\n             templateFn,  // template: ComponentTemplate<{}>|null,\n             null,        // queries: TQueries|null\n             viewQuery,   // viewQuery: ViewQueriesFunction<{}>|null,\n             null !,      // node: TViewNode|TElementNode|null,\n             cloneToTViewData(blueprint).fill(null, bindingStartIndex),  // data: TData,\n             bindingStartIndex,  // bindingStartIndex: number,\n             initialViewLength,  // expandoStartIndex: number,\n             null,               // expandoInstructions: ExpandoInstructions|null,\n             true,               // firstCreatePass: boolean,\n             true,               // firstUpdatePass: boolean,\n             false,              // staticViewQueries: boolean,\n             false,              // staticContentQueries: boolean,\n             null,               // preOrderHooks: HookData|null,\n             null,               // preOrderCheckHooks: HookData|null,\n             null,               // contentHooks: HookData|null,\n             null,               // contentCheckHooks: HookData|null,\n             null,               // viewHooks: HookData|null,\n             null,               // viewCheckHooks: HookData|null,\n             null,               // destroyHooks: HookData|null,\n             null,               // cleanup: any[]|null,\n             null,               // contentQueries: number[]|null,\n             null,               // components: number[]|null,\n             typeof directives === 'function' ?\n                 directives() :\n                 directives,  // directiveRegistry: DirectiveDefList|null,\n             typeof pipes === 'function' ? pipes() : pipes,  // pipeRegistry: PipeDefList|null,\n             null,                                           // firstChild: TNode|null,\n             schemas,                                        // schemas: SchemaMetadata[]|null,\n             consts) :                                       // consts: TConstants|null\n      {\n        type: type,\n        id: viewIndex,\n        blueprint: blueprint,\n        template: templateFn,\n        queries: null,\n        viewQuery: viewQuery,\n        node: null !,\n        data: blueprint.slice().fill(null, bindingStartIndex),\n        bindingStartIndex: bindingStartIndex,\n        expandoStartIndex: initialViewLength,\n        expandoInstructions: null,\n        firstCreatePass: true,\n        firstUpdatePass: true,\n        staticViewQueries: false,\n        staticContentQueries: false,\n        preOrderHooks: null,\n        preOrderCheckHooks: null,\n        contentHooks: null,\n        contentCheckHooks: null,\n        viewHooks: null,\n        viewCheckHooks: null,\n        destroyHooks: null,\n        cleanup: null,\n        contentQueries: null,\n        components: null,\n        directiveRegistry: typeof directives === 'function' ? directives() : directives,\n        pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n        firstChild: null,\n        schemas: schemas,\n        consts: consts,\n      };\n}\n\nfunction createViewBlueprint(bindingStartIndex: number, initialViewLength: number): LView {\n  const blueprint = ngDevMode ? new LViewBlueprint() : [];\n\n  for (let i = 0; i < initialViewLength; i++) {\n    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n  }\n\n  return blueprint as LView;\n}\n\nfunction createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);\n}\n\nfunction assertHostNodeExists(rElement: RElement, elementOrSelector: RElement | string) {\n  if (!rElement) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n}\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param rendererFactory Factory function to create renderer instance.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n */\nexport function locateHostElement(\n    rendererFactory: RendererFactory3, elementOrSelector: RElement | string,\n    encapsulation: ViewEncapsulation): RElement {\n  const renderer = rendererFactory.createRenderer(null, null);\n\n  if (isProceduralRenderer(renderer)) {\n    // When using native Shadow DOM, do not clear host element to allow native slot projection\n    const preserveContent = encapsulation === ViewEncapsulation.ShadowDom;\n    return renderer.selectRootElement(elementOrSelector, preserveContent);\n  }\n\n  let rElement = typeof elementOrSelector === 'string' ?\n      renderer.querySelector(elementOrSelector) ! :\n      elementOrSelector;\n  ngDevMode && assertHostNodeExists(rElement, elementOrSelector);\n\n  // Always clear host element's content when Renderer3 is in use. For procedural renderer case we\n  // make it depend on whether ShadowDom encapsulation is used (in which case the content should be\n  // preserved to allow native slot projection). ShadowDom encapsulation requires procedural\n  // renderer, and procedural renderer case is handled above.\n  rElement.textContent = '';\n\n  return rElement;\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport function storeCleanupWithContext(lView: LView, context: any, cleanupFn: Function): void {\n  const lCleanup = getCleanup(lView);\n  lCleanup.push(context);\n\n  if (lView[TVIEW].firstCreatePass) {\n    getTViewCleanup(lView).push(cleanupFn, lCleanup.length - 1);\n  }\n}\n\n/**\n * Saves the cleanup function itself in LView.cleanupInstances.\n *\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\n * listeners.\n *\n * On the first template pass, the index of the cleanup function is saved in TView.\n */\nexport function storeCleanupFn(view: LView, cleanupFn: Function): void {\n  getCleanup(view).push(cleanupFn);\n\n  if (view[TVIEW].firstCreatePass) {\n    getTViewCleanup(view).push(view[CLEANUP] !.length - 1, null);\n  }\n}\n\n// TODO: Remove this when the issue is resolved.\n/**\n * Tsickle has a bug where it creates an infinite loop for a function returning itself.\n * This is a temporary type that will be removed when the issue is resolved.\n * https://github.com/angular/tsickle/issues/1009)\n */\nexport type TsickleIssue1009 = any;\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param tView `TView` to which this `TNode` belongs (used only in `ngDevMode`)\n * @param type The type of the node\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    tView: TView, tParent: TElementNode | TContainerNode | null, type: TNodeType,\n    adjustedIndex: number, tagName: string | null, attrs: TAttributes | null): TNode {\n  ngDevMode && ngDevMode.tNode++;\n  let injectorIndex = tParent ? tParent.injectorIndex : -1;\n  return ngDevMode ? new TNodeConstructor(\n                         tView,          // tView_: TView\n                         type,           // type: TNodeType\n                         adjustedIndex,  // index: number\n                         injectorIndex,  // injectorIndex: number\n                         -1,             // directiveStart: number\n                         -1,             // directiveEnd: number\n                         null,           // propertyBindings: number[]|null\n                         0,              // flags: TNodeFlags\n                         0,              // providerIndexes: TNodeProviderIndexes\n                         tagName,        // tagName: string|null\n                         attrs,  // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null\n                         null,   // localNames: (string|number)[]|null\n                         undefined,  // initialInputs: (string[]|null)[]|null|undefined\n                         null,       // inputs: PropertyAliases|null\n                         null,       // outputs: PropertyAliases|null\n                         null,       // tViews: ITView|ITView[]|null\n                         null,       // next: ITNode|null\n                         null,       // projectionNext: ITNode|null\n                         null,       // child: ITNode|null\n                         tParent,    // parent: TElementNode|TContainerNode|null\n                         null,       // projection: number|(ITNode|RNode[])[]|null\n                         null,       // styles: TStylingContext|null\n                         null,       // classes: TStylingContext|null\n                         ) :\n                     {\n                       type: type,\n                       index: adjustedIndex,\n                       injectorIndex: injectorIndex,\n                       directiveStart: -1,\n                       directiveEnd: -1,\n                       propertyBindings: null,\n                       flags: 0,\n                       providerIndexes: 0,\n                       tagName: tagName,\n                       attrs: attrs,\n                       localNames: null,\n                       initialInputs: undefined,\n                       inputs: null,\n                       outputs: null,\n                       tViews: null,\n                       next: null,\n                       projectionNext: null,\n                       child: null,\n                       parent: tParent,\n                       projection: null,\n                       styles: null,\n                       classes: null,\n                     };\n}\n\n\nfunction generatePropertyAliases(\n    inputAliasMap: {[publicName: string]: string}, directiveDefIdx: number,\n    propStore: PropertyAliases | null): PropertyAliases|null {\n  for (let publicName in inputAliasMap) {\n    if (inputAliasMap.hasOwnProperty(publicName)) {\n      propStore = propStore === null ? {} : propStore;\n      const internalName = inputAliasMap[publicName];\n\n      if (propStore.hasOwnProperty(publicName)) {\n        propStore[publicName].push(directiveDefIdx, internalName);\n      } else {\n        (propStore[publicName] = [directiveDefIdx, internalName]);\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Initializes data structures required to work with directive outputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\nfunction initializeInputAndOutputAliases(tView: TView, tNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const defs = tView.data;\n\n  const tNodeAttrs = tNode.attrs;\n  const inputsFromAttrs: InitialInputData = ngDevMode ? new TNodeInitialInputs() : [];\n  let inputsStore: PropertyAliases|null = null;\n  let outputsStore: PropertyAliases|null = null;\n  for (let i = start; i < end; i++) {\n    const directiveDef = defs[i] as DirectiveDef<any>;\n    const directiveInputs = directiveDef.inputs;\n    inputsFromAttrs.push(\n        tNodeAttrs !== null ? generateInitialInputs(directiveInputs, tNodeAttrs) : null);\n    inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);\n    outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);\n  }\n\n  if (inputsStore !== null) {\n    if (inputsStore.hasOwnProperty('class') || inputsStore.hasOwnProperty('className')) {\n      tNode.flags |= TNodeFlags.hasClassInput;\n    }\n    if (inputsStore.hasOwnProperty('style')) {\n      tNode.flags |= TNodeFlags.hasStyleInput;\n    }\n  }\n\n  tNode.initialInputs = inputsFromAttrs;\n  tNode.inputs = inputsStore;\n  tNode.outputs = outputsStore;\n}\n\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\nfunction mapPropName(name: string): string {\n  if (name === 'class') return 'className';\n  if (name === 'for') return 'htmlFor';\n  if (name === 'formaction') return 'formAction';\n  if (name === 'innerHtml') return 'innerHTML';\n  if (name === 'readonly') return 'readOnly';\n  if (name === 'tabindex') return 'tabIndex';\n  return name;\n}\n\nexport function elementPropertyInternal<T>(\n    lView: LView, index: number, propName: string, value: T, sanitizer?: SanitizerFn | null,\n    nativeOnly?: boolean,\n    loadRendererFn?: ((tNode: TNode, lView: LView) => Renderer3) | null): void {\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n  const element = getNativeByIndex(index, lView) as RElement | RComment;\n  const tNode = getTNode(index, lView);\n  let inputData = tNode.inputs;\n  let dataValue: PropertyAliasValue|undefined;\n  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n    setInputsForProperty(lView, dataValue, propName, value);\n    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, index + HEADER_OFFSET);\n    if (ngDevMode) {\n      setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n    }\n  } else if (tNode.type === TNodeType.Element) {\n    propName = mapPropName(propName);\n\n    if (ngDevMode) {\n      validateAgainstEventProperties(propName);\n      if (!validateProperty(lView, element, propName, tNode)) {\n        // Return here since we only log warnings for unknown properties.\n        warnAboutUnknownProperty(propName, tNode);\n        return;\n      }\n      ngDevMode.rendererSetProperty++;\n    }\n\n    const renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];\n    // It is assumed that the sanitizer is only added when the compiler determines that the\n    // property is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value, tNode.tagName || '', propName) as any) : value;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setProperty(element as RElement, propName, value);\n    } else if (!isAnimationProp(propName)) {\n      (element as RElement).setProperty ? (element as any).setProperty(propName, value) :\n                                          (element as any)[propName] = value;\n    }\n  } else if (tNode.type === TNodeType.Container) {\n    // If the node is a container and the property didn't\n    // match any of the inputs or schemas we should throw.\n    if (ngDevMode && !matchingSchemas(lView, tNode.tagName)) {\n      warnAboutUnknownProperty(propName, tNode);\n    }\n  }\n}\n\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView: LView, viewIndex: number): void {\n  ngDevMode && assertLView(lView);\n  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & LViewFlags.CheckAlways)) {\n    childComponentLView[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\nfunction setNgReflectProperty(\n    lView: LView, element: RElement | RComment, type: TNodeType, attrName: string, value: any) {\n  const renderer = lView[RENDERER];\n  attrName = normalizeDebugBindingName(attrName);\n  const debugValue = normalizeDebugBindingValue(value);\n  if (type === TNodeType.Element) {\n    if (value == null) {\n      isProceduralRenderer(renderer) ? renderer.removeAttribute((element as RElement), attrName) :\n                                       (element as RElement).removeAttribute(attrName);\n    } else {\n      isProceduralRenderer(renderer) ?\n          renderer.setAttribute((element as RElement), attrName, debugValue) :\n          (element as RElement).setAttribute(attrName, debugValue);\n    }\n  } else {\n    const textContent = `bindings=${JSON.stringify({[attrName]: debugValue}, null, 2)}`;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setValue((element as RComment), textContent);\n    } else {\n      (element as RComment).textContent = textContent;\n    }\n  }\n}\n\nexport function setNgReflectProperties(\n    lView: LView, element: RElement | RComment, type: TNodeType, dataValue: PropertyAliasValue,\n    value: any) {\n  if (type === TNodeType.Element || type === TNodeType.Container) {\n    /**\n     * dataValue is an array containing runtime input or output names for the directives:\n     * i+0: directive instance index\n     * i+1: privateName\n     *\n     * e.g. [0, 'change', 'change-minified']\n     * we want to set the reflected property with the privateName: dataValue[i+1]\n     */\n    for (let i = 0; i < dataValue.length; i += 2) {\n      setNgReflectProperty(lView, element, type, dataValue[i + 1] as string, value);\n    }\n  }\n}\n\nfunction validateProperty(\n    hostView: LView, element: RElement | RComment, propName: string, tNode: TNode): boolean {\n  // The property is considered valid if the element matches the schema, it exists on the element\n  // or it is synthetic, and we are in a browser context (web worker nodes should be skipped).\n  return matchingSchemas(hostView, tNode.tagName) || propName in element ||\n      isAnimationProp(propName) || typeof Node !== 'function' || !(element instanceof Node);\n}\n\nexport function matchingSchemas(hostView: LView, tagName: string | null): boolean {\n  const schemas = hostView[TVIEW].schemas;\n\n  if (schemas !== null) {\n    for (let i = 0; i < schemas.length; i++) {\n      const schema = schemas[i];\n      if (schema === NO_ERRORS_SCHEMA ||\n          schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Logs a warning that a property is not supported on an element.\n * @param propName Name of the invalid property.\n * @param tNode Node on which we encountered the property.\n */\nfunction warnAboutUnknownProperty(propName: string, tNode: TNode): void {\n  console.warn(\n      `Can't bind to '${propName}' since it isn't a known property of '${tNode.tagName}'.`);\n}\n\n/**\n * Instantiate a root component.\n */\nexport function instantiateRootComponent<T>(tView: TView, lView: LView, def: ComponentDef<T>): T {\n  const rootTNode = getPreviousOrParentTNode();\n  if (tView.firstCreatePass) {\n    if (def.providersResolver) def.providersResolver(def);\n    generateExpandoInstructionBlock(tView, rootTNode, 1);\n    baseResolveDirective(tView, lView, def);\n  }\n  const directive = getNodeInjectable(lView, tView, lView.length - 1, rootTNode as TElementNode);\n  attachPatchData(directive, lView);\n  const native = getNativeByTNode(rootTNode, lView);\n  if (native) {\n    attachPatchData(native, lView);\n  }\n  return directive;\n}\n\n/**\n * Resolve the matched directives on a node.\n */\nexport function resolveDirectives(\n    tView: TView, lView: LView, tNode: TElementNode | TContainerNode | TElementContainerNode,\n    localRefs: string[] | null): boolean {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n  // tsickle.\n  ngDevMode && assertFirstCreatePass(tView);\n\n  if (!getBindingsEnabled()) return false;\n\n  const directives: DirectiveDef<any>[]|null = findDirectiveMatches(tView, lView, tNode);\n  const exportsMap: ({[key: string]: number} | null) = localRefs === null ? null : {'': -1};\n  let hasDirectives = false;\n\n  if (directives !== null) {\n    hasDirectives = true;\n    initNodeFlags(tNode, tView.data.length, directives.length);\n    // When the same token is provided by several directives on the same node, some rules apply in\n    // the viewEngine:\n    // - viewProviders have priority over providers\n    // - the last directive in NgModule.declarations has priority over the previous one\n    // So to match these rules, the order in which providers are added in the arrays is very\n    // important.\n    for (let i = 0; i < directives.length; i++) {\n      const def = directives[i] as DirectiveDef<any>;\n      if (def.providersResolver) def.providersResolver(def);\n    }\n    generateExpandoInstructionBlock(tView, tNode, directives.length);\n    let preOrderHooksFound = false;\n    let preOrderCheckHooksFound = false;\n    for (let i = 0; i < directives.length; i++) {\n      const def = directives[i] as DirectiveDef<any>;\n\n      baseResolveDirective(tView, lView, def);\n\n      saveNameToExportMap(tView.data !.length - 1, def, exportsMap);\n\n      if (def.contentQueries !== null) tNode.flags |= TNodeFlags.hasContentQuery;\n      if (def.hostBindings !== null) tNode.flags |= TNodeFlags.hasHostBindings;\n\n      // Only push a node index into the preOrderHooks array if this is the first\n      // pre-order hook found on this node.\n      if (!preOrderHooksFound && (def.onChanges || def.onInit || def.doCheck)) {\n        // We will push the actual hook function into this array later during dir instantiation.\n        // We cannot do it now because we must ensure hooks are registered in the same\n        // order that directives are created (i.e. injection order).\n        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index - HEADER_OFFSET);\n        preOrderHooksFound = true;\n      }\n\n      if (!preOrderCheckHooksFound && (def.onChanges || def.doCheck)) {\n        (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [\n         ])).push(tNode.index - HEADER_OFFSET);\n        preOrderCheckHooksFound = true;\n      }\n    }\n\n    initializeInputAndOutputAliases(tView, tNode);\n  }\n  if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  return hasDirectives;\n}\n\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(\n    tView: TView, lView: LView, tNode: TDirectiveHostNode, native: RNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  if (!tView.firstCreatePass) {\n    getOrCreateNodeInjectorForNode(tNode, lView);\n  }\n\n  attachPatchData(native, lView);\n\n  const initialInputs = tNode.initialInputs;\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    const isComponent = isComponentDef(def);\n\n    if (isComponent) {\n      ngDevMode && assertNodeOfPossibleTypes(tNode, TNodeType.Element);\n      addComponentLogic(lView, tNode as TElementNode, def as ComponentDef<any>);\n    }\n\n    const directive = getNodeInjectable(lView, tView, i, tNode);\n    attachPatchData(directive, lView);\n\n    if (initialInputs !== null) {\n      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs !);\n    }\n\n    if (isComponent) {\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      componentView[CONTEXT] = directive;\n    }\n  }\n}\n\nfunction invokeDirectivesHostBindings(tView: TView, viewData: LView, tNode: TNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const expando = tView.expandoInstructions !;\n  const firstCreatePass = tView.firstCreatePass;\n  const elementIndex = tNode.index - HEADER_OFFSET;\n  try {\n    setActiveHostElement(elementIndex);\n\n    for (let i = start; i < end; i++) {\n      const def = tView.data[i] as DirectiveDef<any>;\n      const directive = viewData[i];\n      if (def.hostBindings) {\n        // It is important that this be called first before the actual instructions\n        // are run because this way the first directive ID value is not zero.\n        incrementActiveDirectiveId();\n        invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstCreatePass);\n      } else if (firstCreatePass) {\n        expando.push(null);\n      }\n    }\n  } finally {\n    setActiveHostElement(null);\n  }\n}\n\nexport function invokeHostBindingsInCreationMode(\n    def: DirectiveDef<any>, expando: ExpandoInstructions, directive: any, tNode: TNode,\n    firstCreatePass: boolean) {\n  const previousExpandoLength = expando.length;\n  setCurrentDirectiveDef(def);\n  const elementIndex = tNode.index - HEADER_OFFSET;\n  def.hostBindings !(RenderFlags.Create, directive, elementIndex);\n  setCurrentDirectiveDef(null);\n  // `hostBindings` function may or may not contain `allocHostVars` call\n  // (e.g. it may not if it only contains host listeners), so we need to check whether\n  // `expandoInstructions` has changed and if not - we still push `hostBindings` to\n  // expando block, to make sure we execute it for DI cycle\n  if (previousExpandoLength === expando.length && firstCreatePass) {\n    expando.push(def.hostBindings);\n  }\n}\n\n/**\n* Generates a new block in TView.expandoInstructions for this node.\n*\n* Each expando block starts with the element index (turned negative so we can distinguish\n* it from the hostVar count) and the directive count. See more in VIEW_DATA.md.\n*/\nexport function generateExpandoInstructionBlock(\n    tView: TView, tNode: TNode, directiveCount: number): void {\n  ngDevMode && assertEqual(\n                   tView.firstCreatePass, true,\n                   'Expando block should only be generated on first create pass.');\n\n  const elementIndex = -(tNode.index - HEADER_OFFSET);\n  const providerStartIndex = tNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const providerCount = tView.data.length - providerStartIndex;\n  (tView.expandoInstructions || (tView.expandoInstructions = [\n   ])).push(elementIndex, providerCount, directiveCount);\n}\n\n/**\n* Matches the current node against all available selectors.\n* If a component is matched (at most one), it is returned in first position in the array.\n*/\nfunction findDirectiveMatches(\n    tView: TView, viewData: LView,\n    tNode: TElementNode | TContainerNode | TElementContainerNode): DirectiveDef<any>[]|null {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Element, TNodeType.ElementContainer, TNodeType.Container);\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i] as ComponentDef<any>| DirectiveDef<any>;\n      if (isNodeMatchingSelectorList(tNode, def.selectors !, /* isProjectionMode */ false)) {\n        matches || (matches = ngDevMode ? new MatchesArray() : []);\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);\n\n        if (isComponentDef(def)) {\n          if (tNode.flags & TNodeFlags.isComponentHost) throwMultipleComponentError(tNode);\n          markAsComponentHost(tView, tNode);\n          // The component is always stored first with directives after.\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches;\n}\n\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting appropriate TNode flags;\n * - storing index of component's host element so it will be queued for view refresh during CD.\n*/\nexport function markAsComponentHost(tView: TView, hostTNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  hostTNode.flags |= TNodeFlags.isComponentHost;\n  (tView.components || (tView.components = ngDevMode ? new TViewComponents() : [\n   ])).push(hostTNode.index);\n}\n\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[] | null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string | number)[] = tNode.localNames =\n        ngDevMode ? new TNodeLocalNames() : [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n* Builds up an export map as directives are created, so local refs can be quickly mapped\n* to their directive instances.\n*/\nfunction saveNameToExportMap(\n    index: number, def: DirectiveDef<any>| ComponentDef<any>,\n    exportsMap: {[key: string]: number} | null) {\n  if (exportsMap) {\n    if (def.exportAs) {\n      for (let i = 0; i < def.exportAs.length; i++) {\n        exportsMap[def.exportAs[i]] = index;\n      }\n    }\n    if ((def as ComponentDef<any>).template) exportsMap[''] = index;\n  }\n}\n\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nexport function initNodeFlags(tNode: TNode, index: number, numberOfDirectives: number) {\n  ngDevMode && assertNotEqual(\n                   numberOfDirectives, tNode.directiveEnd - tNode.directiveStart,\n                   'Reached the max number of directives');\n  tNode.flags |= TNodeFlags.isDirectiveHost;\n  // When the first directive is created on a node, save the index\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n\nfunction baseResolveDirective<T>(tView: TView, viewData: LView, def: DirectiveDef<T>) {\n  tView.data.push(def);\n  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);\n  tView.blueprint.push(nodeInjectorFactory);\n  viewData.push(nodeInjectorFactory);\n}\n\nfunction addComponentLogic<T>(lView: LView, hostTNode: TElementNode, def: ComponentDef<T>): void {\n  const native = getNativeByTNode(hostTNode, lView) as RElement;\n  const tView = getOrCreateTComponentView(def);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const rendererFactory = lView[RENDERER_FACTORY];\n  const componentView = addToViewTree(\n      lView,\n      createLView(\n          lView, tView, null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, native,\n          hostTNode as TElementNode, rendererFactory, rendererFactory.createRenderer(native, def)));\n\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  lView[hostTNode.index] = componentView;\n}\n\nexport function elementAttributeInternal(\n    index: number, name: string, value: any, lView: LView, sanitizer?: SanitizerFn | null,\n    namespace?: string) {\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode && validateAgainstEventAttributes(name);\n  const element = getNativeByIndex(index, lView) as RElement;\n  const renderer = lView[RENDERER];\n  if (value == null) {\n    ngDevMode && ngDevMode.rendererRemoveAttribute++;\n    isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) :\n                                     element.removeAttribute(name);\n  } else {\n    ngDevMode && ngDevMode.rendererSetAttribute++;\n    const tNode = getTNode(index, lView);\n    const strValue =\n        sanitizer == null ? renderStringify(value) : sanitizer(value, tNode.tagName || '', name);\n\n\n    if (isProceduralRenderer(renderer)) {\n      renderer.setAttribute(element, name, strValue, namespace);\n    } else {\n      namespace ? element.setAttributeNS(namespace, name, strValue) :\n                  element.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    lView: LView, directiveIndex: number, instance: T, def: DirectiveDef<T>, tNode: TNode,\n    initialInputData: InitialInputData): void {\n  const initialInputs: InitialInputs|null = initialInputData ![directiveIndex];\n  if (initialInputs !== null) {\n    const setInput = def.setInput;\n    for (let i = 0; i < initialInputs.length;) {\n      const publicName = initialInputs[i++];\n      const privateName = initialInputs[i++];\n      const value = initialInputs[i++];\n      if (setInput !== null) {\n        def.setInput !(instance, value, publicName, privateName);\n      } else {\n        (instance as any)[privateName] = value;\n      }\n      if (ngDevMode) {\n        const nativeElement = getNativeByTNode(tNode, lView) as RElement;\n        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n      }\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs The list of inputs from the directive def\n * @param attrs The static attrs on this node\n */\nfunction generateInitialInputs(inputs: {[key: string]: string}, attrs: TAttributes): InitialInputs|\n    null {\n  let inputsToStore: InitialInputs|null = null;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    } else if (attrName === AttributeMarker.ProjectAs) {\n      // Skip over the `ngProjectAs` value.\n      i += 2;\n      continue;\n    }\n\n    // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n    if (typeof attrName === 'number') break;\n\n    if (inputs.hasOwnProperty(attrName as string)) {\n      if (inputsToStore === null) inputsToStore = [];\n      inputsToStore.push(attrName as string, inputs[attrName as string], attrs[i + 1] as string);\n    }\n\n    i += 2;\n  }\n  return inputsToStore;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n// Not sure why I need to do `any` here but TS complains later.\nconst LContainerArray: any = ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) &&\n    createNamedArrayType('LContainer');\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    hostNative: RElement | RComment | LView, currentView: LView, native: RComment,\n    tNode: TNode): LContainer {\n  ngDevMode && assertLView(currentView);\n  ngDevMode && !isProceduralRenderer(currentView[RENDERER]) && assertDomNode(native);\n  // https://jsperf.com/array-literal-vs-new-array-really\n  const lContainer: LContainer = new (ngDevMode ? LContainerArray : Array)(\n      hostNative,  // host native\n      true,        // Boolean `true` in this position signifies that this is an `LContainer`\n      ActiveIndexFlag.DYNAMIC_EMBEDDED_VIEWS_ONLY << ActiveIndexFlag.SHIFT,  // active index\n      currentView,                                                           // parent\n      null,                                                                  // next\n      null,                                                                  // queries\n      tNode,                                                                 // t_host\n      native,                                                                // native,\n      null,                                                                  // view refs\n      );\n  ngDevMode && attachLContainerDebug(lContainer);\n  return lContainer;\n}\n\n\n/**\n * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction refreshDynamicEmbeddedViews(lView: LView) {\n  let viewOrContainer = lView[CHILD_HEAD];\n  while (viewOrContainer !== null) {\n    // Note: viewOrContainer can be an LView or an LContainer instance, but here we are only\n    // interested in LContainer\n    let activeIndexFlag: ActiveIndexFlag;\n    if (isLContainer(viewOrContainer) &&\n        (activeIndexFlag = viewOrContainer[ACTIVE_INDEX]) >> ActiveIndexFlag.SHIFT ===\n            ActiveIndexFlag.DYNAMIC_EMBEDDED_VIEWS_ONLY) {\n      for (let i = CONTAINER_HEADER_OFFSET; i < viewOrContainer.length; i++) {\n        const embeddedLView = viewOrContainer[i];\n        const embeddedTView = embeddedLView[TVIEW];\n        ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n        refreshView(embeddedLView, embeddedTView, embeddedTView.template, embeddedLView[CONTEXT] !);\n      }\n      if ((activeIndexFlag & ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS) !== 0) {\n        // We should only CD moved views if the component where they were inserted does not match\n        // the component where they were declared and insertion is on-push. Moved views also\n        // contains intra component moves, or check-always which need to be skipped.\n        refreshTransplantedViews(viewOrContainer, lView[DECLARATION_COMPONENT_VIEW] !);\n      }\n    }\n    viewOrContainer = viewOrContainer[NEXT];\n  }\n}\n\n\n/**\n * Refresh transplanted LViews.\n *\n * See: `ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS` and `LView[DECLARATION_COMPONENT_VIEW]` for\n * explanation of transplanted views.\n *\n * @param lContainer The `LContainer` which has transplanted views.\n * @param declaredComponentLView The `lContainer` parent component `LView`.\n */\nfunction refreshTransplantedViews(lContainer: LContainer, declaredComponentLView: LView) {\n  const movedViews = lContainer[MOVED_VIEWS] !;\n  ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n  for (let i = 0; i < movedViews.length; i++) {\n    const movedLView = movedViews[i] !;\n    const insertionLContainer = movedLView[PARENT] as LContainer;\n    ngDevMode && assertLContainer(insertionLContainer);\n    const insertedComponentLView = insertionLContainer[PARENT][DECLARATION_COMPONENT_VIEW] !;\n    ngDevMode && assertDefined(insertedComponentLView, 'Missing LView');\n    // Check if we have a transplanted view by compering declaration and insertion location.\n    if (insertedComponentLView !== declaredComponentLView) {\n      // Yes the `LView` is transplanted.\n      // Here we would like to know if the component is `OnPush`. We don't have\n      // explicit `OnPush` flag instead we set `CheckAlways` to false (which is `OnPush`)\n      // Not to be confused with `ManualOnPush` which is used with wether a DOM event\n      // should automatically mark a view as dirty.\n      const insertionComponentIsOnPush =\n          (insertedComponentLView[FLAGS] & LViewFlags.CheckAlways) === 0;\n      if (insertionComponentIsOnPush) {\n        // Here we know that the template has been transplanted across components and is\n        // on-push (not just moved within a component). If the insertion is marked dirty, then\n        // there is no need to CD here as we will do it again later when we get to insertion\n        // point.\n        const movedTView = movedLView[TVIEW];\n        ngDevMode && assertDefined(movedTView, 'TView must be allocated');\n        refreshView(movedLView, movedTView, movedTView.template, movedLView[CONTEXT] !);\n      }\n    }\n  }\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction refreshComponent(hostLView: LView, componentHostIdx: number): void {\n  ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n  if (viewAttachedToChangeDetector(componentView) &&\n      componentView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    const tView = componentView[TVIEW];\n    refreshView(componentView, tView, tView.template, componentView[CONTEXT]);\n  }\n}\n\nfunction renderComponent(hostLView: LView, componentHostIdx: number) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  syncViewWithBlueprint(componentView);\n  renderView(componentView, componentView[TVIEW], componentView[CONTEXT]);\n}\n\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param componentView The view to sync\n */\nfunction syncViewWithBlueprint(componentView: LView) {\n  const componentTView = componentView[TVIEW];\n  for (let i = componentView.length; i < componentTView.blueprint.length; i++) {\n    componentView.push(componentTView.blueprint[i]);\n  }\n}\n\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LView|LContainer>(lView: LView, lViewOrLContainer: T): T {\n  // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n  // to\n  // the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n  // of\n  // order, the change detection will run out of order, as the act of retrieving the the\n  // LContainer\n  // from the RNode is what adds it to the queue.\n  if (lView[CHILD_HEAD]) {\n    lView[CHILD_TAIL] ![NEXT] = lViewOrLContainer;\n  } else {\n    lView[CHILD_HEAD] = lViewOrLContainer;\n  }\n  lView[CHILD_TAIL] = lViewOrLContainer;\n  return lViewOrLContainer;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nexport function markViewDirty(lView: LView): LView|null {\n  while (lView) {\n    lView[FLAGS] |= LViewFlags.Dirty;\n    const parent = getLViewParent(lView);\n    // Stop traversing up as soon as you find a root view that wasn't attached to any container\n    if (isRootView(lView) && !parent) {\n      return lView;\n    }\n    // continue otherwise\n    lView = parent !;\n  }\n  return null;\n}\n\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick(rootContext: RootContext, flags: RootContextFlags) {\n  const nothingScheduled = rootContext.flags === RootContextFlags.Empty;\n  rootContext.flags |= flags;\n\n  if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      if (rootContext.flags & RootContextFlags.DetectChanges) {\n        rootContext.flags &= ~RootContextFlags.DetectChanges;\n        tickRootContext(rootContext);\n      }\n\n      if (rootContext.flags & RootContextFlags.FlushPlayers) {\n        rootContext.flags &= ~RootContextFlags.FlushPlayers;\n        const playerHandler = rootContext.playerHandler;\n        if (playerHandler) {\n          playerHandler.flushPlayers();\n        }\n      }\n\n      rootContext.clean = _CLEAN_PROMISE;\n      res !(null);\n    });\n  }\n}\n\nexport function tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    const lView = readPatchedLView(rootComponent) !;\n    const tView = lView[TVIEW];\n    renderComponentOrTemplate(lView, tView.template, rootComponent);\n  }\n}\n\nexport function detectChangesInternal<T>(view: LView, context: T) {\n  const rendererFactory = view[RENDERER_FACTORY];\n  if (rendererFactory.begin) rendererFactory.begin();\n  try {\n    const tView = view[TVIEW];\n    refreshView(view, tView, tView.template, context);\n  } catch (error) {\n    handleError(view, error);\n    throw error;\n  } finally {\n    if (rendererFactory.end) rendererFactory.end();\n  }\n}\n\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lView The view which the change detection should be performed on.\n */\nexport function detectChangesInRootView(lView: LView): void {\n  tickRootContext(lView[CONTEXT] as RootContext);\n}\n\nexport function checkNoChangesInternal<T>(view: LView, context: T) {\n  setCheckNoChangesMode(true);\n  try {\n    detectChangesInternal(view, context);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lView The view which the change detection should be checked on.\n */\nexport function checkNoChangesInRootView(lView: LView): void {\n  setCheckNoChangesMode(true);\n  try {\n    detectChangesInRootView(lView);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\nfunction executeViewQueryFn<T>(\n    flags: RenderFlags, viewQueryFn: ViewQueriesFunction<{}>, component: T): void {\n  ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n  setCurrentQueryIndex(0);\n  viewQueryFn(flags, component);\n}\n\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyNameï¿½prefixï¿½interpolation_static_part1ï¿½..interpolation_static_partNï¿½suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param nodeIndex index of a `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nexport function storePropertyBindingMetadata(\n    tData: TData, nodeIndex: number, propertyName: string, bindingIndex: number,\n    ...interpolationParts: string[]) {\n  // Binding meta-data are stored only the first time a given property instruction is processed.\n  // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n  // binding meta-data to decide if one should be stored (or if was stored already).\n  if (tData[bindingIndex] === null) {\n    const tNode = tData[nodeIndex + HEADER_OFFSET] as TNode;\n    if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n      propBindingIdxs.push(bindingIndex);\n      let bindingMetadata = propertyName;\n      if (interpolationParts.length > 0) {\n        bindingMetadata +=\n            INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n      }\n      tData[bindingIndex] = bindingMetadata;\n    }\n  }\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n\nexport function getCleanup(view: LView): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);\n}\n\nfunction getTViewCleanup(view: LView): any[] {\n  return view[TVIEW].cleanup || (view[TVIEW].cleanup = ngDevMode ? new TCleanup() : []);\n}\n\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nexport function loadComponentRenderer(tNode: TNode, lView: LView): Renderer3 {\n  const componentLView = lView[tNode.index] as LView;\n  return componentLView[RENDERER];\n}\n\n/** Handles an error thrown in an LView. */\nexport function handleError(lView: LView, error: any): void {\n  const injector = lView[INJECTOR];\n  const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n  errorHandler && errorHandler.handleError(error);\n}\n\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n * possibly minified, property names to write to.\n * @param value Value to set.\n */\nexport function setInputsForProperty(\n    lView: LView, inputs: PropertyAliasValue, publicName: string, value: any): void {\n  const tView = lView[TVIEW];\n  for (let i = 0; i < inputs.length;) {\n    const index = inputs[i++] as number;\n    const privateName = inputs[i++] as string;\n    const instance = lView[index];\n    ngDevMode && assertDataInRange(lView, index);\n    const def = tView.data[index] as DirectiveDef<any>;\n    if (def.setInput !== null) {\n      def.setInput !(instance, value, publicName, privateName);\n    } else {\n      instance[privateName] = value;\n    }\n  }\n}\n\n/**\n * Updates a text binding at a given index in a given LView.\n */\nexport function textBindingInternal(lView: LView, index: number, value: string): void {\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'value should not be NO_CHANGE');\n  ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\n  const element = getNativeByIndex(index, lView) as any as RText;\n  ngDevMode && assertDefined(element, 'native element should exist');\n  ngDevMode && ngDevMode.rendererSetText++;\n  const renderer = lView[RENDERER];\n  isProceduralRenderer(renderer) ? renderer.setValue(element, value) : element.textContent = value;\n}\n\n/**\n * Renders all initial styling (class and style values) on to the element from the tNode.\n *\n * All initial styling data (i.e. any values extracted from the `style` or `class` attributes\n * on an element) are collected into the `tNode.styles` and `tNode.classes` data structures.\n * These values are populated during the creation phase of an element and are then later\n * applied once the element is instantiated. This function applies each of the static\n * style and class entries to the element.\n */\nexport function renderInitialStyling(\n    renderer: Renderer3, native: RElement, tNode: TNode, append: boolean) {\n  if (tNode.classes !== null) {\n    if (append) {\n      renderStylingMap(renderer, native, tNode.classes, true);\n    } else {\n      const classes = getInitialStylingValue(tNode.classes);\n      writeStylingValueDirectly(renderer, native, classes, true, null);\n    }\n  }\n  if (tNode.styles !== null) {\n    if (append) {\n      renderStylingMap(renderer, native, tNode.styles, false);\n    } else {\n      const styles = getInitialStylingValue(tNode.styles);\n      writeStylingValueDirectly(renderer, native, styles, false, null);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewEncapsulation} from '../metadata/view';\nimport {addToArray, removeFromArray} from '../util/array_utils';\nimport {assertDefined, assertDomNode, assertEqual} from '../util/assert';\nimport {assertLContainer, assertLView, assertTNodeForLView} from './assert';\nimport {attachPatchData} from './context_discovery';\nimport {ACTIVE_INDEX, ActiveIndexFlag, CONTAINER_HEADER_OFFSET, LContainer, MOVED_VIEWS, NATIVE, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {ComponentDef} from './interfaces/definition';\nimport {NodeInjectorFactory} from './interfaces/injector';\nimport {TElementNode, TNode, TNodeFlags, TNodeType, TProjectionNode, TViewNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {ProceduralRenderer3, RElement, RNode, RText, Renderer3, isProceduralRenderer, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {CHILD_HEAD, CLEANUP, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, FLAGS, HOST, HookData, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, TVIEW, T_HOST, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {getLViewParent} from './util/view_traversal_utils';\nimport {getNativeByTNode, unwrapRNode} from './util/view_utils';\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\nexport function getLContainer(tNode: TViewNode, embeddedView: LView): LContainer|null {\n  ngDevMode && assertLView(embeddedView);\n  const container = embeddedView[PARENT] as LContainer;\n  if (tNode.index === -1) {\n    // This is a dynamically created view inside a dynamic container.\n    // The parent isn't an LContainer if the embedded view hasn't been attached yet.\n    return isLContainer(container) ? container : null;\n  } else {\n    ngDevMode && assertLContainer(container);\n    // This is a inline view node (e.g. embeddedViewStart)\n    return container;\n  }\n}\n\n\n/**\n * Retrieves render parent for a given view.\n * Might be null if a view is not yet attached to any container.\n */\nexport function getContainerRenderParent(tViewNode: TViewNode, view: LView): RElement|null {\n  const container = getLContainer(tViewNode, view);\n  return container ? nativeParentNode(view[RENDERER], container[NATIVE]) : null;\n}\n\nconst enum WalkTNodeTreeAction {\n  /** node create in the native environment. Run on initial creation. */\n  Create = 0,\n\n  /**\n   * node insert in the native environment.\n   * Run when existing node has been detached and needs to be re-attached.\n   */\n  Insert = 1,\n\n  /** node detach from the native environment */\n  Detach = 2,\n\n  /** node destruction using the renderer's API */\n  Destroy = 3,\n}\n\n\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(\n    action: WalkTNodeTreeAction, renderer: Renderer3, parent: RElement | null,\n    lNodeToHandle: RNode | LContainer | LView, beforeNode?: RNode | null) {\n  // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n  // won't be created until i18nApply() in the update block, so this node should be skipped.\n  // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n  // in `i18n_spec.ts`.\n  if (lNodeToHandle != null) {\n    let lContainer: LContainer|undefined;\n    let isComponent = false;\n    // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n    // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n    // it has LContainer so that we can process all of those cases appropriately.\n    if (isLContainer(lNodeToHandle)) {\n      lContainer = lNodeToHandle;\n    } else if (isLView(lNodeToHandle)) {\n      isComponent = true;\n      ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n      lNodeToHandle = lNodeToHandle[HOST] !;\n    }\n    const rNode: RNode = unwrapRNode(lNodeToHandle);\n    ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode);\n\n    if (action === WalkTNodeTreeAction.Create && parent !== null) {\n      if (beforeNode == null) {\n        nativeAppendChild(renderer, parent, rNode);\n      } else {\n        nativeInsertBefore(renderer, parent, rNode, beforeNode || null);\n      }\n    } else if (action === WalkTNodeTreeAction.Insert && parent !== null) {\n      nativeInsertBefore(renderer, parent, rNode, beforeNode || null);\n    } else if (action === WalkTNodeTreeAction.Detach) {\n      nativeRemoveNode(renderer, rNode, isComponent);\n    } else if (action === WalkTNodeTreeAction.Destroy) {\n      ngDevMode && ngDevMode.rendererDestroyNode++;\n      (renderer as ProceduralRenderer3).destroyNode !(rNode);\n    }\n    if (lContainer != null) {\n      applyContainer(renderer, action, lContainer, parent, beforeNode);\n    }\n  }\n}\n\nexport function createTextNode(value: string, renderer: Renderer3): RText {\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  ngDevMode && ngDevMode.rendererSetText++;\n  return isProceduralRenderer(renderer) ? renderer.createText(value) :\n                                          renderer.createTextNode(value);\n}\n\n/**\n * Adds or removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param lView The view from which elements should be added or removed\n * @param insertMode Whether or not elements should be added (if false, removing)\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addRemoveViewFromContainer(\n    lView: LView, insertMode: true, beforeNode: RNode | null): void;\nexport function addRemoveViewFromContainer(lView: LView, insertMode: false, beforeNode: null): void;\nexport function addRemoveViewFromContainer(\n    lView: LView, insertMode: boolean, beforeNode: RNode | null): void {\n  const renderParent = getContainerRenderParent(lView[TVIEW].node as TViewNode, lView);\n  ngDevMode && assertNodeType(lView[TVIEW].node as TNode, TNodeType.View);\n  if (renderParent) {\n    const renderer = lView[RENDERER];\n    const action = insertMode ? WalkTNodeTreeAction.Insert : WalkTNodeTreeAction.Detach;\n    applyView(renderer, action, lView, renderParent, beforeNode);\n  }\n}\n\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param lView the `LView` to be detached.\n */\nexport function renderDetachView(lView: LView) {\n  applyView(lView[RENDERER], WalkTNodeTreeAction.Detach, lView, null, null);\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LView): void {\n  // If the view has no children, we can clean it up and return early.\n  let lViewOrLContainer = rootView[CHILD_HEAD];\n  if (!lViewOrLContainer) {\n    return cleanUpView(rootView);\n  }\n\n  while (lViewOrLContainer) {\n    let next: LView|LContainer|null = null;\n\n    if (isLView(lViewOrLContainer)) {\n      // If LView, traverse down to child.\n      next = lViewOrLContainer[CHILD_HEAD];\n    } else {\n      ngDevMode && assertLContainer(lViewOrLContainer);\n      // If container, traverse down to its first LView.\n      const firstView: LView|undefined = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n      if (firstView) next = firstView;\n    }\n\n    if (!next) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (lViewOrLContainer && !lViewOrLContainer ![NEXT] && lViewOrLContainer !== rootView) {\n        cleanUpView(lViewOrLContainer);\n        lViewOrLContainer = getParentState(lViewOrLContainer, rootView);\n      }\n      cleanUpView(lViewOrLContainer || rootView);\n      next = lViewOrLContainer && lViewOrLContainer ![NEXT];\n    }\n    lViewOrLContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\nexport function insertView(lView: LView, lContainer: LContainer, index: number) {\n  ngDevMode && assertLView(lView);\n  ngDevMode && assertLContainer(lContainer);\n  const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n  const containerLength = lContainer.length;\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    lContainer[indexInContainer - 1][NEXT] = lView;\n  }\n  if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n    lView[NEXT] = lContainer[indexInContainer];\n    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n  } else {\n    lContainer.push(lView);\n    lView[NEXT] = null;\n  }\n\n  lView[PARENT] = lContainer;\n\n  // track views where declaration and insertion points are different\n  const declarationLContainer = lView[DECLARATION_LCONTAINER];\n  if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n    trackMovedView(declarationLContainer, lView);\n  }\n\n  // notify query that a new view has been added\n  const lQueries = lView[QUERIES];\n  if (lQueries !== null) {\n    lQueries.insertView(lView[TVIEW]);\n  }\n\n  // Sets the attached flag\n  lView[FLAGS] |= LViewFlags.Attached;\n}\n\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\nfunction trackMovedView(declarationContainer: LContainer, lView: LView) {\n  ngDevMode && assertDefined(lView, 'LView required');\n  ngDevMode && assertLContainer(declarationContainer);\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const insertedLContainer = lView[PARENT] as LContainer;\n  ngDevMode && assertLContainer(insertedLContainer);\n  const insertedComponentLView = insertedLContainer[PARENT] ![DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n  const insertedComponentIsOnPush =\n      (insertedComponentLView[FLAGS] & LViewFlags.CheckAlways) !== LViewFlags.CheckAlways;\n  if (insertedComponentIsOnPush) {\n    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n    if (declaredComponentLView !== insertedComponentLView) {\n      // At this point the declaration-component is not same as insertion-component and we are in\n      // on-push mode, this means that this is a transplanted view. Mark the declared lView as\n      // having\n      // transplanted views so that those views can participate in CD.\n      declarationContainer[ACTIVE_INDEX] |= ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS;\n    }\n  }\n  if (movedViews === null) {\n    declarationContainer[MOVED_VIEWS] = [lView];\n  } else {\n    movedViews.push(lView);\n  }\n}\n\nfunction detachMovedView(declarationContainer: LContainer, lView: LView) {\n  ngDevMode && assertLContainer(declarationContainer);\n  ngDevMode && assertDefined(\n                   declarationContainer[MOVED_VIEWS],\n                   'A projected view should belong to a non-empty projected views collection');\n  const movedViews = declarationContainer[MOVED_VIEWS] !;\n  const declaredViewIndex = movedViews.indexOf(lView);\n  movedViews.splice(declaredViewIndex, 1);\n}\n\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\nexport function detachView(lContainer: LContainer, removeIndex: number): LView|undefined {\n  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;\n\n  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n  const viewToDetach = lContainer[indexInContainer];\n\n  if (viewToDetach) {\n    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n      detachMovedView(declarationLContainer, viewToDetach);\n    }\n\n\n    if (removeIndex > 0) {\n      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT] as LView;\n    }\n    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n    addRemoveViewFromContainer(viewToDetach, false, null);\n\n    // notify query that a view has been removed\n    const lQueries = removedLView[QUERIES];\n    if (lQueries !== null) {\n      lQueries.detachView(removedLView[TVIEW]);\n    }\n\n    viewToDetach[PARENT] = null;\n    viewToDetach[NEXT] = null;\n    // Unsets the attached flag\n    viewToDetach[FLAGS] &= ~LViewFlags.Attached;\n  }\n  return viewToDetach;\n}\n\n/**\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\n *\n * @param lContainer The container from which to remove a view\n * @param removeIndex The index of the view to remove\n */\nexport function removeView(lContainer: LContainer, removeIndex: number) {\n  const detachedView = detachView(lContainer, removeIndex);\n  detachedView && destroyLView(detachedView);\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting cleanup (e.g. removing listeners, calling onDestroys).\n *\n * @param lView The view to be destroyed.\n */\nexport function destroyLView(lView: LView) {\n  if (!(lView[FLAGS] & LViewFlags.Destroyed)) {\n    const renderer = lView[RENDERER];\n    if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n      applyView(renderer, WalkTNodeTreeAction.Destroy, lView, null, null);\n    }\n\n    destroyViewTree(lView);\n  }\n}\n\n/**\n * Determines which LViewOrLContainer to jump to when traversing back up the\n * tree in destroyViewTree.\n *\n * Normally, the view's parent LView should be checked, but in the case of\n * embedded views, the container (which is the view node's parent, but not the\n * LView's parent) needs to be checked for a possible next property.\n *\n * @param lViewOrLContainer The LViewOrLContainer for which we need a parent state\n * @param rootView The rootView, so we don't propagate too far up the view tree\n * @returns The correct parent LViewOrLContainer\n */\nexport function getParentState(lViewOrLContainer: LView | LContainer, rootView: LView): LView|\n    LContainer|null {\n  let tNode;\n  if (isLView(lViewOrLContainer) && (tNode = lViewOrLContainer[T_HOST]) &&\n      tNode.type === TNodeType.View) {\n    // if it's an embedded view, the state needs to go up to the container, in case the\n    // container has a next\n    return getLContainer(tNode as TViewNode, lViewOrLContainer);\n  } else {\n    // otherwise, use parent view for containers or component views\n    return lViewOrLContainer[PARENT] === rootView ? null : lViewOrLContainer[PARENT];\n  }\n}\n\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param view The LView to clean up\n */\nfunction cleanUpView(view: LView | LContainer): void {\n  if (isLView(view) && !(view[FLAGS] & LViewFlags.Destroyed)) {\n    // Usually the Attached flag is removed when the view is detached from its parent, however\n    // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n    view[FLAGS] &= ~LViewFlags.Attached;\n\n    // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n    // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n    // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n    // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n    // really more of an \"afterDestroy\" hook if you think about it.\n    view[FLAGS] |= LViewFlags.Destroyed;\n\n    executeOnDestroys(view);\n    removeListeners(view);\n    const hostTNode = view[T_HOST];\n    // For component views only, the local renderer is destroyed as clean up time.\n    if (hostTNode && hostTNode.type === TNodeType.Element && isProceduralRenderer(view[RENDERER])) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      (view[RENDERER] as ProceduralRenderer3).destroy();\n    }\n\n    const declarationContainer = view[DECLARATION_LCONTAINER];\n    // we are dealing with an embedded view that is still inserted into a container\n    if (declarationContainer !== null && isLContainer(view[PARENT])) {\n      // and this is a projected view\n      if (declarationContainer !== view[PARENT]) {\n        detachMovedView(declarationContainer, view);\n      }\n\n      // For embedded views still attached to a container: remove query result from this view.\n      const lQueries = view[QUERIES];\n      if (lQueries !== null) {\n        lQueries.detachView(view[TVIEW]);\n      }\n    }\n  }\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction removeListeners(lView: LView): void {\n  const tCleanup = lView[TVIEW].cleanup;\n  if (tCleanup !== null) {\n    const lCleanup = lView[CLEANUP] !;\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a native DOM listener\n        const idxOrTargetGetter = tCleanup[i + 1];\n        const target = typeof idxOrTargetGetter === 'function' ?\n            idxOrTargetGetter(lView) :\n            unwrapRNode(lView[idxOrTargetGetter]);\n        const listener = lCleanup[tCleanup[i + 2]];\n        const useCaptureOrSubIdx = tCleanup[i + 3];\n        if (typeof useCaptureOrSubIdx === 'boolean') {\n          // native DOM listener registered with Renderer3\n          target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\n        } else {\n          if (useCaptureOrSubIdx >= 0) {\n            // unregister\n            lCleanup[useCaptureOrSubIdx]();\n          } else {\n            // Subscription\n            lCleanup[-useCaptureOrSubIdx].unsubscribe();\n          }\n        }\n        i += 2;\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n    lView[CLEANUP] = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(view: LView): void {\n  const tView = view[TVIEW];\n  let destroyHooks: HookData|null;\n\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    for (let i = 0; i < destroyHooks.length; i += 2) {\n      const context = view[destroyHooks[i] as number];\n\n      // Only call the destroy hook if the context has been requested.\n      if (!(context instanceof NodeInjectorFactory)) {\n        (destroyHooks[i + 1] as() => void).call(context);\n      }\n    }\n  }\n}\n\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n */\nfunction getRenderParent(tNode: TNode, currentView: LView): RElement|null {\n  // Skip over element and ICU containers as those are represented by a comment node and\n  // can't be used as a render parent.\n  let parentTNode = tNode.parent;\n  while (parentTNode != null && (parentTNode.type === TNodeType.ElementContainer ||\n                                 parentTNode.type === TNodeType.IcuContainer)) {\n    tNode = parentTNode;\n    parentTNode = tNode.parent;\n  }\n\n  // If the parent tNode is null, then we are inserting across views: either into an embedded view\n  // or a component view.\n  if (parentTNode == null) {\n    const hostTNode = currentView[T_HOST] !;\n    if (hostTNode.type === TNodeType.View) {\n      // We are inserting a root element of an embedded view We might delay insertion of children\n      // for a given view if it is disconnected. This might happen for 2 main reasons:\n      // - view is not inserted into any container(view was created but not inserted yet)\n      // - view is inserted into a container but the container itself is not inserted into the DOM\n      // (container might be part of projection or child of a view that is not inserted yet).\n      // In other words we can insert children of a given view if this view was inserted into a\n      // container and the container itself has its render parent determined.\n      return getContainerRenderParent(hostTNode as TViewNode, currentView);\n    } else {\n      // We are inserting a root element of the component view into the component host element and\n      // it should always be eager.\n      ngDevMode && assertNodeOfPossibleTypes(hostTNode, TNodeType.Element);\n      return currentView[HOST];\n    }\n  } else {\n    const isIcuCase = tNode && tNode.type === TNodeType.IcuContainer;\n    // If the parent of this node is an ICU container, then it is represented by comment node and we\n    // need to use it as an anchor. If it is projected then it's direct parent node is the renderer.\n    if (isIcuCase && tNode.flags & TNodeFlags.isProjected) {\n      return getNativeByTNode(tNode, currentView).parentNode as RElement;\n    }\n\n    ngDevMode && assertNodeType(parentTNode, TNodeType.Element);\n    if (parentTNode.flags & TNodeFlags.isComponentHost) {\n      const tData = currentView[TVIEW].data;\n      const tNode = tData[parentTNode.index] as TNode;\n      const encapsulation = (tData[tNode.directiveStart] as ComponentDef<any>).encapsulation;\n\n      // We've got a parent which is an element in the current view. We just need to verify if the\n      // parent element is not a component. Component's content nodes are not inserted immediately\n      // because they will be projected, and so doing insert at this point would be wasteful.\n      // Since the projection would then move it to its final destination. Note that we can't\n      // make this assumption when using the Shadow DOM, because the native projection placeholders\n      // (<content> or <slot>) have to be in place as elements are being inserted.\n      if (encapsulation !== ViewEncapsulation.ShadowDom &&\n          encapsulation !== ViewEncapsulation.Native) {\n        return null;\n      }\n    }\n\n    return getNativeByTNode(parentTNode, currentView) as RElement;\n  }\n}\n\n/**\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\n * This is a utility function that can be used when native nodes were determined - it abstracts an\n * actual renderer being used.\n */\nexport function nativeInsertBefore(\n    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode | null): void {\n  ngDevMode && ngDevMode.rendererInsertBefore++;\n  if (isProceduralRenderer(renderer)) {\n    renderer.insertBefore(parent, child, beforeNode);\n  } else {\n    parent.insertBefore(child, beforeNode, true);\n  }\n}\n\nfunction nativeAppendChild(renderer: Renderer3, parent: RElement, child: RNode): void {\n  ngDevMode && ngDevMode.rendererAppendChild++;\n  ngDevMode && assertDefined(parent, 'parent node must be defined');\n  if (isProceduralRenderer(renderer)) {\n    renderer.appendChild(parent, child);\n  } else {\n    parent.appendChild(child);\n  }\n}\n\nfunction nativeAppendOrInsertBefore(\n    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode | null) {\n  if (beforeNode !== null) {\n    nativeInsertBefore(renderer, parent, child, beforeNode);\n  } else {\n    nativeAppendChild(renderer, parent, child);\n  }\n}\n\n/** Removes a node from the DOM given its native parent. */\nfunction nativeRemoveChild(\n    renderer: Renderer3, parent: RElement, child: RNode, isHostElement?: boolean): void {\n  if (isProceduralRenderer(renderer)) {\n    renderer.removeChild(parent, child, isHostElement);\n  } else {\n    parent.removeChild(child);\n  }\n}\n\n/**\n * Returns a native parent of a given native node.\n */\nexport function nativeParentNode(renderer: Renderer3, node: RNode): RElement|null {\n  return (isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode) as RElement;\n}\n\n/**\n * Returns a native sibling of a given native node.\n */\nexport function nativeNextSibling(renderer: Renderer3, node: RNode): RNode|null {\n  return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;\n}\n\n/**\n * Finds a native \"anchor\" node for cases where we can't append a native child directly\n * (`appendChild`) and need to use a reference (anchor) node for the `insertBefore` operation.\n * @param parentTNode\n * @param lView\n */\nfunction getNativeAnchorNode(parentTNode: TNode, lView: LView): RNode|null {\n  if (parentTNode.type === TNodeType.View) {\n    const lContainer = getLContainer(parentTNode as TViewNode, lView);\n    if (lContainer === null) return null;\n    const index = lContainer.indexOf(lView, CONTAINER_HEADER_OFFSET) - CONTAINER_HEADER_OFFSET;\n    return getBeforeNodeForView(index, lContainer);\n  } else if (\n      parentTNode.type === TNodeType.ElementContainer ||\n      parentTNode.type === TNodeType.IcuContainer) {\n    return getNativeByTNode(parentTNode, lView);\n  }\n  return null;\n}\n\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * The element insertion might be delayed {@link canInsertNativeNode}.\n *\n * @param childEl The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n * @param currentView The current LView\n * @returns Whether or not the child was appended\n */\nexport function appendChild(childEl: RNode | RNode[], childTNode: TNode, currentView: LView): void {\n  const renderParent = getRenderParent(childTNode, currentView);\n  if (renderParent != null) {\n    const renderer = currentView[RENDERER];\n    const parentTNode: TNode = childTNode.parent || currentView[T_HOST] !;\n    const anchorNode = getNativeAnchorNode(parentTNode, currentView);\n    if (Array.isArray(childEl)) {\n      for (let i = 0; i < childEl.length; i++) {\n        nativeAppendOrInsertBefore(renderer, renderParent, childEl[i], anchorNode);\n      }\n    } else {\n      nativeAppendOrInsertBefore(renderer, renderParent, childEl, anchorNode);\n    }\n  }\n}\n\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\nfunction getFirstNativeNode(lView: LView, tNode: TNode | null): RNode|null {\n  if (tNode !== null) {\n    ngDevMode && assertNodeOfPossibleTypes(\n                     tNode, TNodeType.Element, TNodeType.Container, TNodeType.ElementContainer,\n                     TNodeType.IcuContainer, TNodeType.Projection);\n\n    const tNodeType = tNode.type;\n    if (tNodeType === TNodeType.Element) {\n      return getNativeByTNode(tNode, lView);\n    } else if (tNodeType === TNodeType.Container) {\n      return getBeforeNodeForView(-1, lView[tNode.index]);\n    } else if (tNodeType === TNodeType.ElementContainer || tNodeType === TNodeType.IcuContainer) {\n      const elIcuContainerChild = tNode.child;\n      if (elIcuContainerChild !== null) {\n        return getFirstNativeNode(lView, elIcuContainerChild);\n      } else {\n        const rNodeOrLContainer = lView[tNode.index];\n        if (isLContainer(rNodeOrLContainer)) {\n          return getBeforeNodeForView(-1, rNodeOrLContainer);\n        } else {\n          return unwrapRNode(rNodeOrLContainer);\n        }\n      }\n    } else {\n      const componentView = lView[DECLARATION_COMPONENT_VIEW];\n      const componentHost = componentView[T_HOST] as TElementNode;\n      const parentView = getLViewParent(componentView);\n      const firstProjectedTNode: TNode|null =\n          (componentHost.projection as(TNode | null)[])[tNode.projection as number];\n\n      if (firstProjectedTNode != null) {\n        return getFirstNativeNode(parentView !, firstProjectedTNode);\n      } else {\n        return getFirstNativeNode(lView, tNode.next);\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function getBeforeNodeForView(viewIndexInContainer: number, lContainer: LContainer): RNode|\n    null {\n  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n  if (nextViewIndex < lContainer.length) {\n    const lView = lContainer[nextViewIndex] as LView;\n    const firstTNodeOfView = lView[TVIEW].firstChild;\n    if (firstTNodeOfView !== null) {\n      return getFirstNativeNode(lView, firstTNodeOfView);\n    }\n  }\n\n  return lContainer[NATIVE];\n}\n\n/**\n * Removes a native node itself using a given renderer. To remove the node we are looking up its\n * parent from the native tree as not all platforms / browsers support the equivalent of\n * node.remove().\n *\n * @param renderer A renderer to be used\n * @param rNode The native node that should be removed\n * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n */\nexport function nativeRemoveNode(renderer: Renderer3, rNode: RNode, isHostElement?: boolean): void {\n  const nativeParent = nativeParentNode(renderer, rNode);\n  if (nativeParent) {\n    nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n  }\n}\n\n\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\nfunction applyNodes(\n    renderer: Renderer3, action: WalkTNodeTreeAction, tNode: TNode | null, lView: LView,\n    renderParent: RElement | null, beforeNode: RNode | null, isProjection: boolean) {\n  while (tNode != null) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode && assertNodeOfPossibleTypes(\n                     tNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer,\n                     TNodeType.Projection, TNodeType.Projection, TNodeType.IcuContainer);\n    const rawSlotValue = lView[tNode.index];\n    const tNodeType = tNode.type;\n    if (isProjection) {\n      if (action === WalkTNodeTreeAction.Create) {\n        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n        tNode.flags |= TNodeFlags.isProjected;\n      }\n    }\n    if ((tNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n      if (tNodeType === TNodeType.ElementContainer || tNodeType === TNodeType.IcuContainer) {\n        applyNodes(renderer, action, tNode.child, lView, renderParent, beforeNode, false);\n        applyToElementOrContainer(action, renderer, renderParent, rawSlotValue, beforeNode);\n      } else if (tNodeType === TNodeType.Projection) {\n        applyProjectionRecursive(\n            renderer, action, lView, tNode as TProjectionNode, renderParent, beforeNode);\n      } else {\n        ngDevMode && assertNodeOfPossibleTypes(tNode, TNodeType.Element, TNodeType.Container);\n        applyToElementOrContainer(action, renderer, renderParent, rawSlotValue, beforeNode);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n}\n\n\n/**\n * `applyView` performs operation on the view as specified in `action` (insert, detach, destroy)\n *\n * Inserting a view without projection or containers at top level is simple. Just iterate over the\n * root nodes of the View, and for each node perform the `action`.\n *\n * Things get more complicated with containers and projections. That is because coming across:\n * - Container: implies that we have to insert/remove/destroy the views of that container as well\n *              which in turn can have their own Containers at the View roots.\n * - Projection: implies that we have to insert/remove/destroy the nodes of the projection. The\n *               complication is that the nodes we are projecting can themselves have Containers\n *               or other Projections.\n *\n * As you can see this is a very recursive problem. Yes recursion is not most efficient but the\n * code is complicated enough that trying to implemented with recursion becomes unmaintainable.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param renderParent parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyView(\n    renderer: Renderer3, action: WalkTNodeTreeAction, lView: LView, renderParent: RElement | null,\n    beforeNode: RNode | null) {\n  const tView = lView[TVIEW];\n  ngDevMode && assertNodeType(tView.node !, TNodeType.View);\n  const viewRootTNode: TNode|null = tView.node !.child;\n  applyNodes(renderer, action, viewRootTNode, lView, renderParent, beforeNode, false);\n}\n\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\nexport function applyProjection(lView: LView, tProjectionNode: TProjectionNode) {\n  const renderer = lView[RENDERER];\n  const renderParent = getRenderParent(tProjectionNode, lView);\n  const parentTNode = tProjectionNode.parent || lView[T_HOST] !;\n  let beforeNode = getNativeAnchorNode(parentTNode, lView);\n  applyProjectionRecursive(\n      renderer, WalkTNodeTreeAction.Create, lView, tProjectionNode, renderParent, beforeNode);\n}\n\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param renderParent parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyProjectionRecursive(\n    renderer: Renderer3, action: WalkTNodeTreeAction, lView: LView,\n    tProjectionNode: TProjectionNode, renderParent: RElement | null, beforeNode: RNode | null) {\n  const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n  const componentNode = componentLView[T_HOST] as TElementNode;\n  ngDevMode &&\n      assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n  const nodeToProjectOrRNodes = componentNode.projection ![tProjectionNode.projection] !;\n  if (Array.isArray(nodeToProjectOrRNodes)) {\n    // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n    // need to support passing projectable nodes, so we cheat and put them in the TNode\n    // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n    // because we know that that TView is not shared and therefore it will not be a problem.\n    // This should be refactored and cleaned up.\n    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n      const rNode = nodeToProjectOrRNodes[i];\n      applyToElementOrContainer(action, renderer, renderParent, rNode, beforeNode);\n    }\n  } else {\n    let nodeToProject: TNode|null = nodeToProjectOrRNodes;\n    const projectedComponentLView = componentLView[PARENT] as LView;\n    applyNodes(\n        renderer, action, nodeToProject, projectedComponentLView, renderParent, beforeNode, true);\n  }\n}\n\n\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param renderParent parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyContainer(\n    renderer: Renderer3, action: WalkTNodeTreeAction, lContainer: LContainer,\n    renderParent: RElement | null, beforeNode: RNode | null | undefined) {\n  ngDevMode && assertLContainer(lContainer);\n  const anchor = lContainer[NATIVE];  // LContainer has its own before node.\n  const native = unwrapRNode(lContainer);\n  // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n  // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor node\n  // (comment in the DOM) that will be different from the LContainer's host node. In this particular\n  // case we need to execute action on 2 nodes:\n  // - container's host node (this is done in the executeActionOnElementOrContainer)\n  // - container's host node (this is done here)\n  if (anchor !== native) {\n    // This is very strange to me (Misko). I would expect that the native is same as anchor. I don't\n    // see a reason why they should be different, but they are.\n    //\n    // If they are we need to process the second anchor as well.\n    applyToElementOrContainer(action, renderer, renderParent, anchor, beforeNode);\n  }\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lView = lContainer[i] as LView;\n    applyView(renderer, action, lView, renderParent, anchor);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RelativeInjectorLocation} from './interfaces/injector';\nimport {TContainerNode, TElementNode, TNode} from './interfaces/node';\nimport {DECLARATION_VIEW, LView, T_HOST} from './interfaces/view';\nimport {getParentInjectorViewOffset} from './util/injector_utils';\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the TNode of the parent injector is found.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @param startTNode The TNode instance of the starting element\n * @returns The TNode of the parent injector\n */\nexport function getParentInjectorTNode(\n    location: RelativeInjectorLocation, startView: LView, startTNode: TNode): TElementNode|\n    TContainerNode|null {\n  if (startTNode.parent && startTNode.parent.injectorIndex !== -1) {\n    // view offset is 0\n    const injectorIndex = startTNode.parent.injectorIndex;\n    let parentTNode = startTNode.parent;\n    while (parentTNode.parent != null && injectorIndex == parentTNode.injectorIndex) {\n      parentTNode = parentTNode.parent;\n    }\n    return parentTNode;\n  }\n  let viewOffset = getParentInjectorViewOffset(location);\n  // view offset is 1\n  let parentView = startView;\n  let parentTNode = startView[T_HOST] as TElementNode;\n  // view offset is superior to 1\n  while (viewOffset > 1) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    parentTNode = parentView[T_HOST] as TElementNode;\n    viewOffset--;\n  }\n  return parentTNode;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef} from '../application_ref';\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef} from '../linker/view_ref';\n\nimport {checkNoChangesInRootView, checkNoChangesInternal, detectChangesInRootView, detectChangesInternal, markViewDirty, storeCleanupFn} from './instructions/shared';\nimport {CONTAINER_HEADER_OFFSET} from './interfaces/container';\nimport {TElementNode, TNode, TNodeType, TViewNode} from './interfaces/node';\nimport {isLContainer} from './interfaces/type_checks';\nimport {CONTEXT, DECLARATION_COMPONENT_VIEW, FLAGS, HOST, LView, LViewFlags, TVIEW, T_HOST} from './interfaces/view';\nimport {assertNodeOfPossibleTypes} from './node_assert';\nimport {destroyLView, renderDetachView} from './node_manipulation';\nimport {getLViewParent} from './util/view_traversal_utils';\nimport {unwrapRNode} from './util/view_utils';\n\n\n\n// Needed due to tsickle downleveling where multiple `implements` with classes creates\n// multiple @extends in Closure annotations, which is illegal. This workaround fixes\n// the multiple @extends by making the annotation @implements instead\nexport interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {}\n\nexport class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef,\n    viewEngine_ChangeDetectorRef_interface {\n  private _appRef: ApplicationRef|null = null;\n  private _viewContainerRef: viewEngine_ViewContainerRef|null = null;\n\n  /**\n   * @internal\n   */\n  public _tViewNode: TViewNode|null = null;\n\n  get rootNodes(): any[] {\n    if (this._lView[HOST] == null) {\n      const tView = this._lView[T_HOST] as TViewNode;\n      return collectNativeNodes(this._lView, tView.child, []);\n    }\n    return [];\n  }\n\n  constructor(\n      /**\n       * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n       *\n       * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n       * component.\n       *\n       * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n       * view.\n       *\n       * @internal\n       */\n      public _lView: LView,\n\n      /**\n       * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n       * requested.\n       *\n       * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n       */\n      private _cdRefInjectingView?: LView) {}\n\n  get context(): T { return this._lView[CONTEXT] as T; }\n\n  get destroyed(): boolean {\n    return (this._lView[FLAGS] & LViewFlags.Destroyed) === LViewFlags.Destroyed;\n  }\n\n  destroy(): void {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._viewContainerRef) {\n      const index = this._viewContainerRef.indexOf(this);\n\n      if (index > -1) {\n        this._viewContainerRef.detach(index);\n      }\n\n      this._viewContainerRef = null;\n    }\n    destroyLView(this._lView);\n  }\n\n  onDestroy(callback: Function) { storeCleanupFn(this._lView, callback); }\n\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * It also triggers change detection by calling `scheduleTick` internally, which coalesces\n   * multiple `markForCheck` calls to into one change detection run.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'my-app',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck(): void { markViewDirty(this._cdRefInjectingView || this._lView); }\n\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach(): void { this._lView[FLAGS] &= ~LViewFlags.Attached; }\n\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'my-app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach(): void { this._lView[FLAGS] |= LViewFlags.Attached; }\n\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach detach} for more information.\n   */\n  detectChanges(): void { detectChangesInternal(this._lView, this.context); }\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges(): void { checkNoChangesInternal(this._lView, this.context); }\n\n  attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef) {\n    if (this._appRef) {\n      throw new Error('This view is already attached directly to the ApplicationRef!');\n    }\n    this._viewContainerRef = vcRef;\n  }\n\n  detachFromAppRef() {\n    this._appRef = null;\n    renderDetachView(this._lView);\n  }\n\n  attachToAppRef(appRef: ApplicationRef) {\n    if (this._viewContainerRef) {\n      throw new Error('This view is already attached to a ViewContainer!');\n    }\n    this._appRef = appRef;\n  }\n}\n\n/** @internal */\nexport class RootViewRef<T> extends ViewRef<T> {\n  constructor(public _view: LView) { super(_view); }\n\n  detectChanges(): void { detectChangesInRootView(this._view); }\n\n  checkNoChanges(): void { checkNoChangesInRootView(this._view); }\n\n  get context(): T { return null !; }\n}\n\nfunction collectNativeNodes(\n    lView: LView, tNode: TNode | null, result: any[], isProjection: boolean = false): any[] {\n  while (tNode !== null) {\n    ngDevMode && assertNodeOfPossibleTypes(\n                     tNode, TNodeType.Element, TNodeType.Container, TNodeType.Projection,\n                     TNodeType.ElementContainer, TNodeType.IcuContainer);\n\n    const lNode = lView[tNode.index];\n    if (lNode !== null) {\n      result.push(unwrapRNode(lNode));\n    }\n\n    // A given lNode can represent either a native node or a LContainer (when it is a host of a\n    // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes\n    // from the views in this container.\n    if (isLContainer(lNode)) {\n      for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {\n        const lViewInAContainer = lNode[i];\n        const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n        if (lViewFirstChildTNode !== null) {\n          collectNativeNodes(lViewInAContainer, lViewFirstChildTNode, result);\n        }\n      }\n    }\n\n    const tNodeType = tNode.type;\n    if (tNodeType === TNodeType.ElementContainer || tNodeType === TNodeType.IcuContainer) {\n      collectNativeNodes(lView, tNode.child, result);\n    } else if (tNodeType === TNodeType.Projection) {\n      const componentView = lView[DECLARATION_COMPONENT_VIEW];\n      const componentHost = componentView[T_HOST] as TElementNode;\n      const parentView = getLViewParent(componentView);\n      let firstProjectedNode: TNode|null =\n          (componentHost.projection as(TNode | null)[])[tNode.projection as number];\n      if (firstProjectedNode !== null && parentView !== null) {\n        collectNativeNodes(parentView, firstProjectedNode, result, true);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef as ViewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {Injector} from '../di/injector';\nimport {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef} from '../linker/component_factory';\nimport {ElementRef as ViewEngine_ElementRef} from '../linker/element_ref';\nimport {NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {TemplateRef as ViewEngine_TemplateRef} from '../linker/template_ref';\nimport {ViewContainerRef as ViewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, ViewRef as viewEngine_ViewRef} from '../linker/view_ref';\nimport {Renderer2} from '../render/api';\nimport {addToArray, removeFromArray} from '../util/array_utils';\nimport {assertDefined, assertEqual, assertGreaterThan, assertLessThan} from '../util/assert';\n\nimport {assertLContainer} from './assert';\nimport {NodeInjector, getParentInjectorLocation} from './di';\nimport {addToViewTree, createLContainer, createLView, renderView} from './instructions/shared';\nimport {ActiveIndexFlag, CONTAINER_HEADER_OFFSET, LContainer, VIEW_REFS} from './interfaces/container';\nimport {TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TNode, TNodeType, TViewNode} from './interfaces/node';\nimport {RComment, RElement, isProceduralRenderer} from './interfaces/renderer';\nimport {isComponentHost, isLContainer, isLView, isRootView} from './interfaces/type_checks';\nimport {DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, LView, LViewFlags, PARENT, QUERIES, RENDERER, TView, T_HOST} from './interfaces/view';\nimport {assertNodeOfPossibleTypes} from './node_assert';\nimport {addRemoveViewFromContainer, appendChild, detachView, getBeforeNodeForView, insertView, nativeInsertBefore, nativeNextSibling, nativeParentNode, removeView} from './node_manipulation';\nimport {getParentInjectorTNode} from './node_util';\nimport {getLView, getPreviousOrParentTNode} from './state';\nimport {getParentInjectorView, hasParentInjector} from './util/injector_utils';\nimport {getComponentLViewByIndex, getNativeByTNode, setLContainerActiveIndex, unwrapRNode, viewAttachedToContainer} from './util/view_utils';\nimport {ViewRef} from './view_ref';\n\n\n\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nexport function injectElementRef(ElementRefToken: typeof ViewEngine_ElementRef):\n    ViewEngine_ElementRef {\n  return createElementRef(ElementRefToken, getPreviousOrParentTNode(), getLView());\n}\n\nlet R3ElementRef: {new (native: RElement | RComment): ViewEngine_ElementRef};\n\n/**\n * Creates an ElementRef given a node.\n *\n * @param ElementRefToken The ElementRef type\n * @param tNode The node for which you'd like an ElementRef\n * @param view The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nexport function createElementRef(\n    ElementRefToken: typeof ViewEngine_ElementRef, tNode: TNode,\n    view: LView): ViewEngine_ElementRef {\n  if (!R3ElementRef) {\n    // TODO: Fix class name, should be ElementRef, but there appears to be a rollup bug\n    R3ElementRef = class ElementRef_ extends ElementRefToken {};\n  }\n  return new R3ElementRef(getNativeByTNode(tNode, view) as RElement);\n}\n\nlet R3TemplateRef: {\n  new (_declarationParentView: LView, hostTNode: TContainerNode, elementRef: ViewEngine_ElementRef):\n      ViewEngine_TemplateRef<any>\n};\n\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\nexport function injectTemplateRef<T>(\n    TemplateRefToken: typeof ViewEngine_TemplateRef,\n    ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_TemplateRef<T>|null {\n  return createTemplateRef<T>(\n      TemplateRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param TemplateRefToken The TemplateRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node on which a TemplateRef is requested\n * @param hostView The view to which the node belongs\n * @returns The TemplateRef instance or null if we can't create a TemplateRef on a given node type\n */\nexport function createTemplateRef<T>(\n    TemplateRefToken: typeof ViewEngine_TemplateRef, ElementRefToken: typeof ViewEngine_ElementRef,\n    hostTNode: TNode, hostView: LView): ViewEngine_TemplateRef<T>|null {\n  if (!R3TemplateRef) {\n    // TODO: Fix class name, should be TemplateRef, but there appears to be a rollup bug\n    R3TemplateRef = class TemplateRef_<T> extends TemplateRefToken<T> {\n      constructor(\n          private _declarationView: LView, private _declarationTContainer: TContainerNode,\n          readonly elementRef: ViewEngine_ElementRef) {\n        super();\n      }\n\n      createEmbeddedView(context: T): viewEngine_EmbeddedViewRef<T> {\n        const embeddedTView = this._declarationTContainer.tViews as TView;\n        const lView = createLView(\n            this._declarationView, embeddedTView, context, LViewFlags.CheckAlways, null,\n            embeddedTView.node);\n\n        const declarationLContainer = this._declarationView[this._declarationTContainer.index];\n        ngDevMode && assertLContainer(declarationLContainer);\n        lView[DECLARATION_LCONTAINER] = declarationLContainer;\n\n        const declarationViewLQueries = this._declarationView[QUERIES];\n        if (declarationViewLQueries !== null) {\n          lView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n        }\n\n        renderView(lView, embeddedTView, context);\n\n        const viewRef = new ViewRef<T>(lView);\n        viewRef._tViewNode = lView[T_HOST] as TViewNode;\n        return viewRef;\n      }\n    };\n  }\n\n  if (hostTNode.type === TNodeType.Container) {\n    ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\n    return new R3TemplateRef(\n        hostView, hostTNode as TContainerNode,\n        createElementRef(ElementRefToken, hostTNode, hostView));\n  } else {\n    return null;\n  }\n}\n\nlet R3ViewContainerRef: {\n  new (\n      lContainer: LContainer, hostTNode: TElementNode | TContainerNode | TElementContainerNode,\n      hostView: LView): ViewEngine_ViewContainerRef\n};\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function injectViewContainerRef(\n    ViewContainerRefToken: typeof ViewEngine_ViewContainerRef,\n    ElementRefToken: typeof ViewEngine_ElementRef): ViewEngine_ViewContainerRef {\n  const previousTNode =\n      getPreviousOrParentTNode() as TElementNode | TElementContainerNode | TContainerNode;\n  return createContainerRef(ViewContainerRefToken, ElementRefToken, previousTNode, getLView());\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param ViewContainerRefToken The ViewContainerRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\nexport function createContainerRef(\n    ViewContainerRefToken: typeof ViewEngine_ViewContainerRef,\n    ElementRefToken: typeof ViewEngine_ElementRef,\n    hostTNode: TElementNode|TContainerNode|TElementContainerNode,\n    hostView: LView): ViewEngine_ViewContainerRef {\n  if (!R3ViewContainerRef) {\n    // TODO: Fix class name, should be ViewContainerRef, but there appears to be a rollup bug\n    R3ViewContainerRef = class ViewContainerRef_ extends ViewContainerRefToken {\n      constructor(\n          private _lContainer: LContainer,\n          private _hostTNode: TElementNode|TContainerNode|TElementContainerNode,\n          private _hostView: LView) {\n        super();\n      }\n\n      get element(): ViewEngine_ElementRef {\n        return createElementRef(ElementRefToken, this._hostTNode, this._hostView);\n      }\n\n      get injector(): Injector { return new NodeInjector(this._hostTNode, this._hostView); }\n\n      /** @deprecated No replacement */\n      get parentInjector(): Injector {\n        const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostView);\n        const parentView = getParentInjectorView(parentLocation, this._hostView);\n        const parentTNode = getParentInjectorTNode(parentLocation, this._hostView, this._hostTNode);\n\n        return !hasParentInjector(parentLocation) || parentTNode == null ?\n            new NodeInjector(null, this._hostView) :\n            new NodeInjector(parentTNode, parentView);\n      }\n\n      clear(): void {\n        while (this.length > 0) {\n          this.remove(this.length - 1);\n        }\n      }\n\n      get(index: number): viewEngine_ViewRef|null {\n        return this._lContainer[VIEW_REFS] !== null && this._lContainer[VIEW_REFS] ![index] || null;\n      }\n\n      get length(): number { return this._lContainer.length - CONTAINER_HEADER_OFFSET; }\n\n      createEmbeddedView<C>(templateRef: ViewEngine_TemplateRef<C>, context?: C, index?: number):\n          viewEngine_EmbeddedViewRef<C> {\n        const viewRef = templateRef.createEmbeddedView(context || <any>{});\n        this.insert(viewRef, index);\n        return viewRef;\n      }\n\n      createComponent<C>(\n          componentFactory: viewEngine_ComponentFactory<C>, index?: number|undefined,\n          injector?: Injector|undefined, projectableNodes?: any[][]|undefined,\n          ngModuleRef?: viewEngine_NgModuleRef<any>|undefined): viewEngine_ComponentRef<C> {\n        const contextInjector = injector || this.parentInjector;\n        if (!ngModuleRef && (componentFactory as any).ngModule == null && contextInjector) {\n          // DO NOT REFACTOR. The code here used to have a `value || undefined` expression\n          // which seems to cause internal google apps to fail. This is documented in the\n          // following internal bug issue: go/b/142967802\n          const result = contextInjector.get(viewEngine_NgModuleRef, null);\n          if (result) {\n            ngModuleRef = result;\n          }\n        }\n\n        const componentRef =\n            componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\n        this.insert(componentRef.hostView, index);\n        return componentRef;\n      }\n\n      insert(viewRef: viewEngine_ViewRef, index?: number): viewEngine_ViewRef {\n        const lView = (viewRef as ViewRef<any>)._lView !;\n\n        if (viewRef.destroyed) {\n          throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n        }\n\n        this.allocateContainerIfNeeded();\n\n        if (viewAttachedToContainer(lView)) {\n          // If view is already attached, detach it first so we clean up references appropriately.\n\n          const prevIdx = this.indexOf(viewRef);\n\n          // A view might be attached either to this or a different container. The `prevIdx` for\n          // those cases will be:\n          // equal to -1 for views attached to this ViewContainerRef\n          // >= 0 for views attached to a different ViewContainerRef\n          if (prevIdx !== -1) {\n            this.detach(prevIdx);\n          } else {\n            const prevLContainer = lView[PARENT] as LContainer;\n            ngDevMode && assertEqual(\n                             isLContainer(prevLContainer), true,\n                             'An attached view should have its PARENT point to a container.');\n\n\n            // We need to re-create a R3ViewContainerRef instance since those are not stored on\n            // LView (nor anywhere else).\n            const prevVCRef = new R3ViewContainerRef(\n                prevLContainer, prevLContainer[T_HOST] as TDirectiveHostNode,\n                prevLContainer[PARENT]);\n\n            prevVCRef.detach(prevVCRef.indexOf(viewRef));\n          }\n        }\n\n        const adjustedIdx = this._adjustIndex(index);\n        insertView(lView, this._lContainer, adjustedIdx);\n\n        const beforeNode = getBeforeNodeForView(adjustedIdx, this._lContainer);\n        addRemoveViewFromContainer(lView, true, beforeNode);\n\n        (viewRef as ViewRef<any>).attachToViewContainerRef(this);\n        addToArray(this._lContainer[VIEW_REFS] !, adjustedIdx, viewRef);\n\n        return viewRef;\n      }\n\n      move(viewRef: viewEngine_ViewRef, newIndex: number): viewEngine_ViewRef {\n        if (viewRef.destroyed) {\n          throw new Error('Cannot move a destroyed View in a ViewContainer!');\n        }\n        return this.insert(viewRef, newIndex);\n      }\n\n      indexOf(viewRef: viewEngine_ViewRef): number {\n        const viewRefsArr = this._lContainer[VIEW_REFS];\n        return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;\n      }\n\n      remove(index?: number): void {\n        this.allocateContainerIfNeeded();\n        const adjustedIdx = this._adjustIndex(index, -1);\n        removeView(this._lContainer, adjustedIdx);\n        removeFromArray(this._lContainer[VIEW_REFS] !, adjustedIdx);\n      }\n\n      detach(index?: number): viewEngine_ViewRef|null {\n        this.allocateContainerIfNeeded();\n        const adjustedIdx = this._adjustIndex(index, -1);\n        const view = detachView(this._lContainer, adjustedIdx);\n\n        const wasDetached =\n            view && removeFromArray(this._lContainer[VIEW_REFS] !, adjustedIdx) != null;\n        return wasDetached ? new ViewRef(view !) : null;\n      }\n\n      private _adjustIndex(index?: number, shift: number = 0) {\n        if (index == null) {\n          return this.length + shift;\n        }\n        if (ngDevMode) {\n          assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);\n          // +1 because it's legal to insert at the end.\n          assertLessThan(index, this.length + 1 + shift, 'index');\n        }\n        return index;\n      }\n\n      private allocateContainerIfNeeded(): void {\n        if (this._lContainer[VIEW_REFS] === null) {\n          this._lContainer[VIEW_REFS] = [];\n        }\n      }\n    };\n  }\n\n  ngDevMode && assertNodeOfPossibleTypes(\n                   hostTNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n\n  let lContainer: LContainer;\n  const slotValue = hostView[hostTNode.index];\n  if (isLContainer(slotValue)) {\n    // If the host is a container, we don't need to create a new LContainer\n    lContainer = slotValue;\n    setLContainerActiveIndex(lContainer, ActiveIndexFlag.DYNAMIC_EMBEDDED_VIEWS_ONLY);\n  } else {\n    let commentNode: RComment;\n    // If the host is an element container, the native host element is guaranteed to be a\n    // comment and we can reuse that comment as anchor element for the new LContainer.\n    // The comment node in question is already part of the DOM structure so we don't need to append\n    // it again.\n    if (hostTNode.type === TNodeType.ElementContainer) {\n      commentNode = unwrapRNode(slotValue) as RComment;\n    } else {\n      ngDevMode && ngDevMode.rendererCreateComment++;\n      commentNode = hostView[RENDERER].createComment(ngDevMode ? 'container' : '');\n\n      // A `ViewContainerRef` can be injected by the root (topmost / bootstrapped) component. In\n      // this case we can't use TView / TNode data structures to insert container's marker node\n      // (both a parent of a comment node and the comment node itself are not part of any view). In\n      // this specific case we use low-level DOM manipulation to insert container's marker (comment)\n      // node.\n      if (isRootView(hostView)) {\n        const renderer = hostView[RENDERER];\n        const hostNative = getNativeByTNode(hostTNode, hostView) !;\n        const parentOfHostNative = nativeParentNode(renderer, hostNative);\n        nativeInsertBefore(\n            renderer, parentOfHostNative !, commentNode, nativeNextSibling(renderer, hostNative));\n      } else {\n        appendChild(commentNode, hostTNode, hostView);\n      }\n    }\n\n    hostView[hostTNode.index] = lContainer =\n        createLContainer(slotValue, hostView, commentNode, hostTNode);\n\n    addToViewTree(hostView, lContainer);\n  }\n\n  return new R3ViewContainerRef(lContainer, hostTNode, hostView);\n}\n\n\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\nexport function injectChangeDetectorRef(isPipe = false): ViewEngine_ChangeDetectorRef {\n  return createViewRef(getPreviousOrParentTNode(), getLView(), isPipe);\n}\n\n/**\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\n *\n * @param tNode The node that is requesting a ChangeDetectorRef\n * @param lView The view to which the node belongs\n * @param isPipe Whether the view is being injected into a pipe.\n * @returns The ChangeDetectorRef to use\n */\nfunction createViewRef(tNode: TNode, lView: LView, isPipe: boolean): ViewEngine_ChangeDetectorRef {\n  // `isComponentView` will be true for Component and Directives (but not for Pipes).\n  // See https://github.com/angular/angular/pull/33072 for proper fix\n  const isComponentView = !isPipe && isComponentHost(tNode);\n  if (isComponentView) {\n    // The LView represents the location where the component is declared.\n    // Instead we want the LView for the component View and so we need to look it up.\n    const componentView = getComponentLViewByIndex(tNode.index, lView);  // look down\n    return new ViewRef(componentView, componentView);\n  } else if (\n      tNode.type === TNodeType.Element || tNode.type === TNodeType.Container ||\n      tNode.type === TNodeType.ElementContainer || tNode.type === TNodeType.IcuContainer) {\n    // The LView represents the location where the injection is requested from.\n    // We need to locate the containing LView (in case where the `lView` is an embedded view)\n    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];  // look up\n    return new ViewRef(hostComponentView, lView);\n  }\n  return null !;\n}\n\n/** Returns a Renderer2 (or throws when application was bootstrapped with Renderer3) */\nfunction getOrCreateRenderer2(view: LView): Renderer2 {\n  const renderer = view[RENDERER];\n  if (isProceduralRenderer(renderer)) {\n    return renderer as Renderer2;\n  } else {\n    throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');\n  }\n}\n\n/** Injects a Renderer2 for the current component. */\nexport function injectRenderer2(): Renderer2 {\n  // We need the Renderer to be based on the component that it's being injected into, however since\n  // DI happens before we've entered its view, `getLView` will return the parent view instead.\n  const lView = getLView();\n  const tNode = getPreviousOrParentTNode();\n  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);\n  return getOrCreateRenderer2(isLView(nodeAtIndex) ? nodeAtIndex : lView);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectChangeDetectorRef as render3InjectChangeDetectorRef} from '../render3/view_engine_compatibility';\n\n/**\n * Base class for Angular Views, provides change detection functionality.\n * A change-detection tree collects all views that are to be checked for changes.\n * Use the methods to add and remove views from the tree, initiate change-detection,\n * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.\n *\n * @usageNotes\n *\n * The following examples demonstrate how to modify default change-detection behavior\n * to perform explicit detection when needed.\n *\n * ### Use `markForCheck()` with `CheckOnce` strategy\n *\n * The following example sets the `OnPush` change-detection strategy for a component\n * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\n * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\"\n * region=\"mark-for-check\"></code-example>\n *\n * ### Detach change detector to limit how often check occurs\n *\n * The following example defines a component with a large list of read-only data\n * that is expected to change constantly, many times per second.\n * To improve performance, we want to check and update the list\n * less often than the changes actually occur. To do that, we detach\n * the component's change detector and perform an explicit local check every five seconds.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"detach\"></code-example>\n *\n *\n * ### Reattaching a detached component\n *\n * The following example creates a component displaying live data.\n * The component detaches its change detector from the main change detector tree\n * when the `live` property is set to false, and reattaches it when the property\n * becomes true.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"reattach\"></code-example>\n *\n * @publicApi\n */\nexport abstract class ChangeDetectorRef {\n  /**\n   * When a view uses the {@link ChangeDetectionStrategy#OnPush OnPush} (checkOnce)\n   * change detection strategy, explicitly marks the view as changed so that\n   * it can be checked again.\n   *\n   * Components are normally marked as dirty (in need of rerendering) when inputs\n   * have changed or events have fired in the view. Call this method to ensure that\n   * a component is checked even if these triggers have not occured.\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   */\n  abstract markForCheck(): void;\n\n  /**\n   * Detaches this view from the change-detection tree.\n   * A detached view is  not checked until it is reattached.\n   * Use in combination with `detectChanges()` to implement local change detection checks.\n   *\n   * Detached views are not checked during change detection runs until they are\n   * re-attached, even if they are marked as dirty.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   */\n  abstract detach(): void;\n\n  /**\n   * Checks this view and its children. Use in combination with {@link ChangeDetectorRef#detach\n   * detach}\n   * to implement local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   */\n  abstract detectChanges(): void;\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * Use in development mode to verify that running change detection doesn't introduce\n   * other changes.\n   */\n  abstract checkNoChanges(): void;\n\n  /**\n   * Re-attaches the previously detached view to the change detection tree.\n   * Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   */\n  abstract reattach(): void;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => ChangeDetectorRef = () => SWITCH_CHANGE_DETECTOR_REF_FACTORY();\n}\n\n\n\nexport const SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__ = render3InjectChangeDetectorRef;\nconst SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__ = (...args: any[]): any => {};\nconst SWITCH_CHANGE_DETECTOR_REF_FACTORY: typeof render3InjectChangeDetectorRef =\n    SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nexport const Type = Function;\n\nexport function isType(v: any): v is Type<any> {\n  return typeof v === 'function';\n}\n\n/**\n * @description\n *\n * Represents an abstract class `T`, if applied to a concrete class it would stop being\n * instantiatable.\n *\n * @publicApi\n */\nexport interface AbstractType<T> extends Function { prototype: T; }\n\nexport interface Type<T> extends Function { new (...args: any[]): T; }\n\nexport type Mutable<T extends{[x: string]: any}, K extends string> = {\n  [P in K]: T[P];\n};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type, isType} from '../interface/type';\nimport {newArray} from '../util/array_utils';\nimport {ANNOTATIONS, PARAMETERS, PROP_METADATA} from '../util/decorators';\nimport {global} from '../util/global';\nimport {stringify} from '../util/stringify';\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n\n\n\n/**\n * Attention: These regex has to hold even if the code is minified!\n */\nexport const DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*arguments\\)/;\nexport const INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\nexport const INHERITED_CLASS_WITH_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\nexport const INHERITED_CLASS_WITH_DELEGATE_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{\\s+super\\(\\.\\.\\.arguments\\)/;\n\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nexport function isDelegateCtor(typeStr: string): boolean {\n  return DELEGATE_CTOR.test(typeStr) || INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n      (INHERITED_CLASS.test(typeStr) && !INHERITED_CLASS_WITH_CTOR.test(typeStr));\n}\n\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\n  private _reflect: any;\n\n  constructor(reflect?: any) { this._reflect = reflect || global['Reflect']; }\n\n  isReflectionEnabled(): boolean { return true; }\n\n  factory<T>(t: Type<T>): (args: any[]) => T { return (...args: any[]) => new t(...args); }\n\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n\n  private _ownParameters(type: Type<any>, parentCtor: any): any[][]|null {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if ((<any>type).parameters && (<any>type).parameters !== parentCtor.parameters) {\n      return (<any>type).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = (<any>type).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && (type as any)[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n        this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return newArray<any[]>(type.length);\n  }\n\n  parameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n\n  private _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[]|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).annotations && (<any>typeOrFunc).annotations !== parentCtor.annotations) {\n      let annotations = (<any>typeOrFunc).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).decorators && (<any>typeOrFunc).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata((<any>typeOrFunc).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return (typeOrFunc as any)[ANNOTATIONS];\n    }\n    return null;\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  private _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]}|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).propMetadata &&\n        (<any>typeOrFunc).propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = (<any>typeOrFunc).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).propDecorators &&\n        (<any>typeOrFunc).propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = (<any>typeOrFunc).propDecorators;\n      const propMetadata = <{[key: string]: any[]}>{};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return (typeOrFunc as any)[PROP_METADATA];\n    }\n    return null;\n  }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n\n  ownPropMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n\n  guards(type: any): {[key: string]: any} { return {}; }\n\n  getter(name: string): GetterFn { return <GetterFn>new Function('o', 'return o.' + name + ';'); }\n\n  setter(name: string): SetterFn {\n    return <SetterFn>new Function('o', 'v', 'return o.' + name + ' = v;');\n  }\n\n  method(name: string): MethodFn {\n    const functionBody = `if (!o.${name}) throw new Error('\"${name}\" is undefined');\n        return o.${name}.apply(o, args);`;\n    return <MethodFn>new Function('o', 'args', functionBody);\n  }\n\n  // There is not a concept of import uri in Js, but this is useful in developing Dart applications.\n  importUri(type: any): string {\n    // StaticSymbol\n    if (typeof type === 'object' && type['filePath']) {\n      return type['filePath'];\n    }\n    // Runtime type\n    return `./${stringify(type)}`;\n  }\n\n  resourceUri(type: any): string { return `./${stringify(type)}`; }\n\n  resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return runtime;\n  }\n  resolveEnum(enumIdentifier: any, name: string): any { return enumIdentifier[name]; }\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor: Function): Type<any> {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef} from '../../change_detection/change_detector_ref';\nimport {CompilerFacade, R3DependencyMetadataFacade, getCompilerFacade} from '../../compiler/compiler_facade';\nimport {Type} from '../../interface/type';\nimport {ReflectionCapabilities} from '../../reflection/reflection_capabilities';\nimport {Attribute, Host, Inject, Optional, Self, SkipSelf} from '../metadata';\n\nlet _reflect: ReflectionCapabilities|null = null;\n\nexport function getReflect(): ReflectionCapabilities {\n  return (_reflect = _reflect || new ReflectionCapabilities());\n}\n\nexport function reflectDependencies(type: Type<any>): R3DependencyMetadataFacade[] {\n  return convertDependencies(getReflect().parameters(type));\n}\n\nexport function convertDependencies(deps: any[]): R3DependencyMetadataFacade[] {\n  const compiler = getCompilerFacade();\n  return deps.map(dep => reflectDependency(compiler, dep));\n}\n\nfunction reflectDependency(compiler: CompilerFacade, dep: any | any[]): R3DependencyMetadataFacade {\n  const meta: R3DependencyMetadataFacade = {\n    token: null,\n    host: false,\n    optional: false,\n    resolved: compiler.R3ResolvedDependencyType.Token,\n    self: false,\n    skipSelf: false,\n  };\n\n  function setTokenAndResolvedType(token: any): void {\n    meta.resolved = compiler.R3ResolvedDependencyType.Token;\n    meta.token = token;\n  }\n\n  if (Array.isArray(dep)) {\n    if (dep.length === 0) {\n      throw new Error('Dependency array must have arguments.');\n    }\n    for (let j = 0; j < dep.length; j++) {\n      const param = dep[j];\n      if (param === undefined) {\n        // param may be undefined if type of dep is not set by ngtsc\n        continue;\n      } else if (param instanceof Optional || param.__proto__.ngMetadataName === 'Optional') {\n        meta.optional = true;\n      } else if (param instanceof SkipSelf || param.__proto__.ngMetadataName === 'SkipSelf') {\n        meta.skipSelf = true;\n      } else if (param instanceof Self || param.__proto__.ngMetadataName === 'Self') {\n        meta.self = true;\n      } else if (param instanceof Host || param.__proto__.ngMetadataName === 'Host') {\n        meta.host = true;\n      } else if (param instanceof Inject) {\n        meta.token = param.token;\n      } else if (param instanceof Attribute) {\n        if (param.attributeName === undefined) {\n          throw new Error(`Attribute name must be defined.`);\n        }\n        meta.token = param.attributeName;\n        meta.resolved = compiler.R3ResolvedDependencyType.Attribute;\n      } else if (param === ChangeDetectorRef) {\n        meta.token = param;\n        meta.resolved = compiler.R3ResolvedDependencyType.ChangeDetectorRef;\n      } else {\n        setTokenAndResolvedType(param);\n      }\n    }\n  } else {\n    setTokenAndResolvedType(dep);\n  }\n  return meta;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3InjectableMetadataFacade, getCompilerFacade} from '../../compiler/compiler_facade';\nimport {Type} from '../../interface/type';\nimport {NG_FACTORY_DEF} from '../../render3/fields';\nimport {getClosureSafeProperty} from '../../util/property';\nimport {resolveForwardRef} from '../forward_ref';\nimport {Injectable} from '../injectable';\nimport {NG_PROV_DEF} from '../interface/defs';\nimport {ClassSansProvider, ExistingSansProvider, FactorySansProvider, ValueProvider, ValueSansProvider} from '../interface/provider';\n\nimport {angularCoreDiEnv} from './environment';\nimport {convertDependencies, reflectDependencies} from './util';\n\n\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * injectable def (`Éµprov`) onto the injectable type.\n */\nexport function compileInjectable(type: Type<any>, srcMeta?: Injectable): void {\n  let ngInjectableDef: any = null;\n  let ngFactoryDef: any = null;\n\n  // if NG_PROV_DEF is already defined on this class then don't overwrite it\n  if (!type.hasOwnProperty(NG_PROV_DEF)) {\n    Object.defineProperty(type, NG_PROV_DEF, {\n      get: () => {\n        if (ngInjectableDef === null) {\n          ngInjectableDef = getCompilerFacade().compileInjectable(\n              angularCoreDiEnv, `ng:///${type.name}/Éµprov.js`,\n              getInjectableMetadata(type, srcMeta));\n        }\n        return ngInjectableDef;\n      },\n    });\n  }\n\n  // if NG_FACTORY_DEF is already defined on this class then don't overwrite it\n  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n    Object.defineProperty(type, NG_FACTORY_DEF, {\n      get: () => {\n        if (ngFactoryDef === null) {\n          const metadata = getInjectableMetadata(type, srcMeta);\n          const compiler = getCompilerFacade();\n          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/Éµfac.js`, {\n            name: metadata.name,\n            type: metadata.type,\n            typeArgumentCount: metadata.typeArgumentCount,\n            deps: reflectDependencies(type),\n            injectFn: 'inject',\n            target: compiler.R3FactoryTarget.Pipe\n          });\n        }\n        return ngFactoryDef;\n      },\n      // Leave this configurable so that the factories from directives or pipes can take precedence.\n      configurable: true\n    });\n  }\n}\n\ntype UseClassProvider = Injectable & ClassSansProvider & {deps?: any[]};\n\nconst USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\n\nfunction isUseClassProvider(meta: Injectable): meta is UseClassProvider {\n  return (meta as UseClassProvider).useClass !== undefined;\n}\n\nfunction isUseValueProvider(meta: Injectable): meta is Injectable&ValueSansProvider {\n  return USE_VALUE in meta;\n}\n\nfunction isUseFactoryProvider(meta: Injectable): meta is Injectable&FactorySansProvider {\n  return (meta as FactorySansProvider).useFactory !== undefined;\n}\n\nfunction isUseExistingProvider(meta: Injectable): meta is Injectable&ExistingSansProvider {\n  return (meta as ExistingSansProvider).useExisting !== undefined;\n}\n\nfunction getInjectableMetadata(type: Type<any>, srcMeta?: Injectable): R3InjectableMetadataFacade {\n  // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n  const meta: Injectable = srcMeta || {providedIn: null};\n  const compilerMeta: R3InjectableMetadataFacade = {\n    name: type.name,\n    type: type,\n    typeArgumentCount: 0,\n    providedIn: meta.providedIn,\n    userDeps: undefined,\n  };\n  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n    compilerMeta.userDeps = convertDependencies(meta.deps);\n  }\n  if (isUseClassProvider(meta)) {\n    // The user explicitly specified useClass, and may or may not have provided deps.\n    compilerMeta.useClass = resolveForwardRef(meta.useClass);\n  } else if (isUseValueProvider(meta)) {\n    // The user explicitly specified useValue.\n    compilerMeta.useValue = resolveForwardRef(meta.useValue);\n  } else if (isUseFactoryProvider(meta)) {\n    // The user explicitly specified useFactory.\n    compilerMeta.useFactory = meta.useFactory;\n  } else if (isUseExistingProvider(meta)) {\n    // The user explicitly specified useExisting.\n    compilerMeta.useExisting = resolveForwardRef(meta.useExisting);\n  }\n  return compilerMeta;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {ReflectionCapabilities} from '../reflection/reflection_capabilities';\nimport {getClosureSafeProperty} from '../util/property';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {injectArgs, ÉµÉµinject} from './injector_compatibility';\nimport {ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from './interface/provider';\n\nconst USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\nconst EMPTY_ARRAY: any[] = [];\n\nexport function convertInjectableProviderToFactory(\n    type: Type<any>, provider?: ValueSansProvider | ExistingSansProvider | StaticClassSansProvider |\n        ConstructorSansProvider | FactorySansProvider | ClassSansProvider): () => any {\n  if (!provider) {\n    const reflectionCapabilities = new ReflectionCapabilities();\n    const deps = reflectionCapabilities.parameters(type);\n    // TODO - convert to flags.\n    return () => new type(...injectArgs(deps as any[]));\n  }\n\n  if (USE_VALUE in provider) {\n    const valueProvider = (provider as ValueSansProvider);\n    return () => valueProvider.useValue;\n  } else if ((provider as ExistingSansProvider).useExisting) {\n    const existingProvider = (provider as ExistingSansProvider);\n    return () => ÉµÉµinject(resolveForwardRef(existingProvider.useExisting));\n  } else if ((provider as FactorySansProvider).useFactory) {\n    const factoryProvider = (provider as FactorySansProvider);\n    return () => factoryProvider.useFactory(...injectArgs(factoryProvider.deps || EMPTY_ARRAY));\n  } else if ((provider as StaticClassSansProvider | ClassSansProvider).useClass) {\n    const classProvider = (provider as StaticClassSansProvider | ClassSansProvider);\n    let deps = (provider as StaticClassSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new (resolveForwardRef(classProvider.useClass))(...injectArgs(deps));\n  } else {\n    let deps = (provider as ConstructorSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new type(...injectArgs(deps !));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {TypeDecorator, makeDecorator} from '../util/decorators';\n\nimport {InjectableType, getInjectableDef, ÉµÉµInjectableDef, ÉµÉµdefineInjectable} from './interface/defs';\nimport {ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueSansProvider} from './interface/provider';\nimport {compileInjectable as render3CompileInjectable} from './jit/injectable';\nimport {convertInjectableProviderToFactory} from './util';\n\n\n\n/**\n * Injectable providers used in `@Injectable` decorator.\n *\n * @publicApi\n */\nexport type InjectableProvider = ValueSansProvider | ExistingSansProvider |\n    StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;\n\n/**\n * Type of the Injectable decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectableDecorator {\n  /**\n   * Decorator that marks a class as available to be\n   * provided and injected as a dependency.\n   *\n   * @see [Introduction to Services and DI](guide/architecture-services)\n   * @see [Dependency Injection Guide](guide/dependency-injection)\n   *\n   * @usageNotes\n   *\n   * Marking a class with `@Injectable` ensures that the compiler\n   * will generate the necessary metadata to create the class's\n   * dependencies when the class is injected.\n   *\n   * The following example shows how a service class is properly\n   *  marked so that a supporting service can be injected upon creation.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Injectable\"></code-example>\n   *\n   */\n  (): TypeDecorator;\n  (options?: {providedIn: Type<any>| 'root' | 'platform' | 'any' | null}&\n   InjectableProvider): TypeDecorator;\n  new (): Injectable;\n  new (options?: {providedIn: Type<any>| 'root' | 'platform' | 'any' | null}&\n       InjectableProvider): Injectable;\n}\n\n/**\n * Type of the Injectable metadata.\n *\n * @publicApi\n */\nexport interface Injectable {\n  /**\n   * Determines which injectors will provide the injectable,\n   * by either associating it with an @NgModule or other `InjectorType`,\n   * or by specifying that this injectable should be provided in the:\n   * - 'root' injector, which will be the application-level injector in most apps.\n   * - 'platform' injector, which would be the special singleton platform injector shared by all\n   * applications on the page.\n   * - 'any' injector, which would be the injector which receives the resolution. (Note this only\n   * works on NgModule Injectors and not on Element Injector)\n   */\n  providedIn?: Type<any>|'root'|'platform'|'any'|null;\n}\n\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Injectable: InjectableDecorator = makeDecorator(\n    'Injectable', undefined, undefined, undefined,\n    (type: Type<any>, meta: Injectable) => SWITCH_COMPILE_INJECTABLE(type as any, meta));\n\n/**\n * Type representing injectable service.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> { Éµprov: ÉµÉµInjectableDef<T>; }\n\n/**\n * Supports @Injectable() in JIT mode for Render2.\n */\nfunction render2CompileInjectable(injectableType: Type<any>, options?: {\n  providedIn?: Type<any>| 'root' | 'platform' | 'any' | null\n} & InjectableProvider): void {\n  if (options && options.providedIn !== undefined && !getInjectableDef(injectableType)) {\n    (injectableType as InjectableType<any>).Éµprov = ÉµÉµdefineInjectable({\n      token: injectableType,\n      providedIn: options.providedIn,\n      factory: convertInjectableProviderToFactory(injectableType, options),\n    });\n  }\n}\n\nexport const SWITCH_COMPILE_INJECTABLE__POST_R3__ = render3CompileInjectable;\nconst SWITCH_COMPILE_INJECTABLE__PRE_R3__ = render2CompileInjectable;\nconst SWITCH_COMPILE_INJECTABLE: typeof render3CompileInjectable =\n    SWITCH_COMPILE_INJECTABLE__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from './injection_token';\n\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nexport const INJECTOR_SCOPE = new InjectionToken<'root'|'platform'|null>('Set Injector scope.');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {OnDestroy} from '../interface/lifecycle_hooks';\nimport {Type} from '../interface/type';\nimport {getFactoryDef} from '../render3/definition';\nimport {throwCyclicDependencyError, throwInvalidProviderError, throwMixedMultiProviderError} from '../render3/errors';\nimport {deepForEach, newArray} from '../util/array_utils';\nimport {stringify} from '../util/stringify';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {INJECTOR, NG_TEMP_TOKEN_PATH, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE, catchInjectorError, injectArgs, setCurrentInjector, ÉµÉµinject} from './injector_compatibility';\nimport {InjectorType, InjectorTypeWithProviders, getInheritedInjectableDef, getInjectableDef, getInjectorDef, ÉµÉµInjectableDef} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, TypeProvider, ValueProvider} from './interface/provider';\nimport {INJECTOR_SCOPE} from './scope';\n\n\n\n/**\n * Internal type for a single provider in a deep provider array.\n */\ntype SingleProvider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider |\n    ExistingProvider | FactoryProvider | StaticClassProvider;\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n\nconst EMPTY_ARRAY = [] as any[];\n\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR: Injector|undefined = undefined;\n\nfunction getNullInjector(): Injector {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n\n/**\n * An entry in the injector which tracks information about the given token, including a possible\n * current value.\n */\ninterface Record<T> {\n  factory: (() => T)|undefined;\n  value: T|{};\n  multi: any[]|undefined;\n}\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\nexport function createInjector(\n    defType: /* InjectorType<any> */ any, parent: Injector | null = null,\n    additionalProviders: StaticProvider[] | null = null, name?: string): Injector {\n  parent = parent || getNullInjector();\n  return new R3Injector(defType, additionalProviders, parent, name);\n}\n\nexport class R3Injector {\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n   * to prevent further searches.\n   */\n  private records = new Map<Type<any>|InjectionToken<any>, Record<any>|null>();\n\n  /**\n   * The transitive set of `InjectorType`s which define this injector.\n   */\n  private injectorDefTypes = new Set<InjectorType<any>>();\n\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  private onDestroy = new Set<OnDestroy>();\n\n  /**\n   * Flag indicating this injector provides the APP_ROOT_SCOPE token, and thus counts as the\n   * root scope.\n   */\n  private readonly scope: 'root'|'platform'|null;\n\n  readonly source: string|null;\n\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  get destroyed(): boolean { return this._destroyed; }\n  private _destroyed = false;\n\n  constructor(\n      def: InjectorType<any>, additionalProviders: StaticProvider[]|null, readonly parent: Injector,\n      source: string|null = null) {\n    const dedupStack: InjectorType<any>[] = [];\n\n    // Start off by creating Records for every provider declared in every InjectorType\n    // included transitively in additional providers then do the same for `def`. This order is\n    // important because `def` may include providers that override ones in additionalProviders.\n    additionalProviders && deepForEach(\n                               additionalProviders, provider => this.processProvider(\n                                                        provider, def, additionalProviders));\n\n    deepForEach([def], injectorDef => this.processInjectorType(injectorDef, [], dedupStack));\n\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    const record = this.records.get(INJECTOR_SCOPE);\n    this.scope = record != null ? record.value : null;\n\n    // Eagerly instantiate the InjectorType classes themselves.\n    this.injectorDefTypes.forEach(defType => this.get(defType));\n\n    // Source name, used for debugging\n    this.source = source || (typeof def === 'object' ? null : stringify(def));\n  }\n\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy(): void {\n    this.assertNotDestroyed();\n\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this._destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      this.onDestroy.forEach(service => service.ngOnDestroy());\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this.onDestroy.clear();\n      this.injectorDefTypes.clear();\n    }\n  }\n\n  get<T>(\n      token: Type<T>|InjectionToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n      flags = InjectFlags.Default): T {\n    this.assertNotDestroyed();\n    // Set the injection context.\n    const previousInjector = setCurrentInjector(this);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record: Record<T>|undefined|null = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an injectable\n          // def with a scope matching this injector.\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n          this.records.set(token, record);\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record != null /* NOT null || undefined */) {\n          return this.hydrate(token, record);\n        }\n      }\n\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n      // is undefined, the value is null, otherwise it's the notFoundValue.\n      notFoundValue = (flags & InjectFlags.Optional) && notFoundValue === THROW_IF_NOT_FOUND ?\n          null :\n          notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (e) {\n      if (e.name === 'NullInjectorError') {\n        const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n        path.unshift(stringify(token));\n        if (previousInjector) {\n          // We still have a parent injector, keep throwing\n          throw e;\n        } else {\n          // Format & throw the final error message when we don't have any previous injector\n          return catchInjectorError(e, token, 'R3InjectorError', this.source);\n        }\n      } else {\n        throw e;\n      }\n    } finally {\n      // Lastly, clean up the state by restoring the previous injector.\n      setCurrentInjector(previousInjector);\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this.records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `R3Injector[${tokens.join(', ')}]`;\n  }\n\n  private assertNotDestroyed(): void {\n    if (this._destroyed) {\n      throw new Error('Injector has already been destroyed.');\n    }\n  }\n\n  /**\n   * Add an `InjectorType` or `InjectorTypeWithProviders` and all of its transitive providers\n   * to this injector.\n   *\n   * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n   * the function will return \"true\" to indicate that the providers of the type definition need\n   * to be processed. This allows us to process providers of injector types after all imports of\n   * an injector definition are processed. (following View Engine semantics: see FW-1349)\n   */\n  private processInjectorType(\n      defOrWrappedDef: InjectorType<any>|InjectorTypeWithProviders<any>,\n      parents: InjectorType<any>[],\n      dedupStack: InjectorType<any>[]): defOrWrappedDef is InjectorTypeWithProviders<any> {\n    defOrWrappedDef = resolveForwardRef(defOrWrappedDef);\n    if (!defOrWrappedDef) return false;\n\n    // Either the defOrWrappedDef is an InjectorType (with injector def) or an\n    // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic\n    // read, so care is taken to only do the read once.\n\n    // First attempt to read the injector def (`Éµinj`).\n    let def = getInjectorDef(defOrWrappedDef);\n\n    // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.\n    const ngModule =\n        (def == null) && (defOrWrappedDef as InjectorTypeWithProviders<any>).ngModule || undefined;\n\n    // Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,\n    // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type\n    // is the `ngModule`.\n    const defType: InjectorType<any> =\n        (ngModule === undefined) ? (defOrWrappedDef as InjectorType<any>) : ngModule;\n\n    // Check for circular dependencies.\n    if (ngDevMode && parents.indexOf(defType) !== -1) {\n      const defName = stringify(defType);\n      throw new Error(\n          `Circular dependency in DI detected for type ${defName}. Dependency path: ${parents.map(defType => stringify(defType)).join(' > ')} > ${defName}.`);\n    }\n\n    // Check for multiple imports of the same module\n    const isDuplicate = dedupStack.indexOf(defType) !== -1;\n\n    // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual\n    // `InjectorDef` is on its `ngModule`.\n    if (ngModule !== undefined) {\n      def = getInjectorDef(ngModule);\n    }\n\n    // If no definition was found, it might be from exports. Remove it.\n    if (def == null) {\n      return false;\n    }\n\n    // Track the InjectorType and add a provider for it.\n    this.injectorDefTypes.add(defType);\n    this.records.set(defType, makeRecord(def.factory, NOT_YET));\n\n    // Add providers in the same way that @NgModule resolution did:\n\n    // First, include providers from any imports.\n    if (def.imports != null && !isDuplicate) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      ngDevMode && parents.push(defType);\n      // Add it to the set of dedups. This way we can detect multiple imports of the same module\n      dedupStack.push(defType);\n\n      let importTypesWithProviders: (InjectorTypeWithProviders<any>[])|undefined;\n      try {\n        deepForEach(def.imports, imported => {\n          if (this.processInjectorType(imported, parents, dedupStack)) {\n            if (importTypesWithProviders === undefined) importTypesWithProviders = [];\n            // If the processed import is an injector type with providers, we store it in the\n            // list of import types with providers, so that we can process those afterwards.\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        // Remove it from the parents set when finished.\n        ngDevMode && parents.pop();\n      }\n\n      // Imports which are declared with providers (TypeWithProviders) need to be processed\n      // after all imported modules are processed. This is similar to how View Engine\n      // processes/merges module imports in the metadata resolver. See: FW-1349.\n      if (importTypesWithProviders !== undefined) {\n        for (let i = 0; i < importTypesWithProviders.length; i++) {\n          const {ngModule, providers} = importTypesWithProviders[i];\n          deepForEach(\n              providers !,\n              provider => this.processProvider(provider, ngModule, providers || EMPTY_ARRAY));\n        }\n      }\n    }\n\n    // Next, include providers listed on the definition itself.\n    const defProviders = def.providers;\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = defOrWrappedDef as InjectorType<any>;\n      deepForEach(\n          defProviders, provider => this.processProvider(provider, injectorType, defProviders));\n    }\n\n    return (\n        ngModule !== undefined &&\n        (defOrWrappedDef as InjectorTypeWithProviders<any>).providers !== undefined);\n  }\n\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  private processProvider(\n      provider: SingleProvider, ngModuleType: InjectorType<any>, providers: any[]): void {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token: any =\n        isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider, ngModuleType, providers);\n\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (multiRecord.multi === undefined) {\n          throwMixedMultiProviderError();\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord !.multi !);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi !.push(provider);\n    } else {\n      const existing = this.records.get(token);\n      if (existing && existing.multi !== undefined) {\n        throwMixedMultiProviderError();\n      }\n    }\n    this.records.set(token, record);\n  }\n\n  private hydrate<T>(token: Type<T>|InjectionToken<T>, record: Record<T>): T {\n    if (record.value === CIRCULAR) {\n      throwCyclicDependencyError(stringify(token));\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      record.value = record.factory !();\n    }\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this.onDestroy.add(record.value);\n    }\n    return record.value as T;\n  }\n\n  private injectableDefInScope(def: ÉµÉµInjectableDef<any>): boolean {\n    if (!def.providedIn) {\n      return false;\n    } else if (typeof def.providedIn === 'string') {\n      return def.providedIn === 'any' || (def.providedIn === this.scope);\n    } else {\n      return this.injectorDefTypes.has(def.providedIn);\n    }\n  }\n}\n\nfunction injectableDefOrInjectorDefFactory(token: Type<any>| InjectionToken<any>): () => any {\n  // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n  const injectableDef = getInjectableDef(token);\n  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n\n  if (factory !== null) {\n    return factory;\n  }\n\n  // If the token is an NgModule, it's also injectable but the factory is on its injector def\n  // (`Éµinj`)\n  const injectorDef = getInjectorDef(token);\n  if (injectorDef !== null) {\n    return injectorDef.factory;\n  }\n\n  // InjectionTokens should have an injectable def (Éµprov) and thus should be handled above.\n  // If it's missing that, it's an error.\n  if (token instanceof InjectionToken) {\n    throw new Error(`Token ${stringify(token)} is missing a Éµprov definition.`);\n  }\n\n  // Undecorated types can sometimes be created if they have no constructor arguments.\n  if (token instanceof Function) {\n    return getUndecoratedInjectableFactory(token);\n  }\n\n  // There was no way to resolve a factory for this token.\n  throw new Error('unreachable');\n}\n\nfunction getUndecoratedInjectableFactory(token: Function) {\n  // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n  const paramLength = token.length;\n  if (paramLength > 0) {\n    const args: string[] = newArray(paramLength, '?');\n    throw new Error(`Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);\n  }\n\n  // The constructor function appears to have no parameters.\n  // This might be because it inherits from a super-class. In which case, use an injectable\n  // def from an ancestor if there is one.\n  // Otherwise this really is a simple class with no dependencies, so return a factory that\n  // just instantiates the zero-arg constructor.\n  const inheritedInjectableDef = getInheritedInjectableDef(token);\n  if (inheritedInjectableDef !== null) {\n    return () => inheritedInjectableDef.factory(token as Type<any>);\n  } else {\n    return () => new (token as Type<any>)();\n  }\n}\n\nfunction providerToRecord(\n    provider: SingleProvider, ngModuleType: InjectorType<any>, providers: any[]): Record<any> {\n  if (isValueProvider(provider)) {\n    return makeRecord(undefined, provider.useValue);\n  } else {\n    const factory: (() => any)|undefined = providerToFactory(provider, ngModuleType, providers);\n    return makeRecord(factory, NOT_YET);\n  }\n}\n\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nexport function providerToFactory(\n    provider: SingleProvider, ngModuleType?: InjectorType<any>, providers?: any[]): () => any {\n  let factory: (() => any)|undefined = undefined;\n  if (isTypeProvider(provider)) {\n    return injectableDefOrInjectorDefFactory(resolveForwardRef(provider));\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isExistingProvider(provider)) {\n      factory = () => ÉµÉµinject(resolveForwardRef(provider.useExisting));\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else {\n      const classRef = resolveForwardRef(\n          provider &&\n          ((provider as StaticClassProvider | ClassProvider).useClass || provider.provide));\n      if (!classRef) {\n        throwInvalidProviderError(ngModuleType, providers, provider);\n      }\n      if (hasDeps(provider)) {\n        factory = () => new (classRef)(...injectArgs(provider.deps));\n      } else {\n        return injectableDefOrInjectorDefFactory(classRef);\n      }\n    }\n  }\n  return factory;\n}\n\nfunction makeRecord<T>(\n    factory: (() => T) | undefined, value: T | {}, multi: boolean = false): Record<T> {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined,\n  };\n}\n\nfunction isValueProvider(value: SingleProvider): value is ValueProvider {\n  return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\n\nfunction isExistingProvider(value: SingleProvider): value is ExistingProvider {\n  return !!(value && (value as ExistingProvider).useExisting);\n}\n\nfunction isFactoryProvider(value: SingleProvider): value is FactoryProvider {\n  return !!(value && (value as FactoryProvider).useFactory);\n}\n\nexport function isTypeProvider(value: SingleProvider): value is TypeProvider {\n  return typeof value === 'function';\n}\n\nexport function isClassProvider(value: SingleProvider): value is ClassProvider {\n  return !!(value as StaticClassProvider | ClassProvider).useClass;\n}\n\nfunction hasDeps(value: ClassProvider | ConstructorProvider | StaticClassProvider):\n    value is ClassProvider&{deps: any[]} {\n  return !!(value as any).deps;\n}\n\nfunction hasOnDestroy(value: any): value is OnDestroy {\n  return value !== null && typeof value === 'object' &&\n      typeof(value as OnDestroy).ngOnDestroy === 'function';\n}\n\nfunction couldBeInjectableType(value: any): value is Type<any>|InjectionToken<any> {\n  return (typeof value === 'function') ||\n      (typeof value === 'object' && value instanceof InjectionToken);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractType, Type} from '../interface/type';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {INJECTOR, NG_TEMP_TOKEN_PATH, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE, catchInjectorError, formatError, setCurrentInjector, ÉµÉµinject} from './injector_compatibility';\nimport {getInjectableDef, ÉµÉµdefineInjectable} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './interface/provider';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {createInjector} from './r3_injector';\nimport {INJECTOR_SCOPE} from './scope';\n\nexport function INJECTOR_IMPL__PRE_R3__(\n    providers: StaticProvider[], parent: Injector | undefined, name: string) {\n  return new StaticInjector(providers, parent, name);\n}\n\nexport function INJECTOR_IMPL__POST_R3__(\n    providers: StaticProvider[], parent: Injector | undefined, name: string) {\n  return createInjector({name: name}, parent, providers, name);\n}\n\nexport const INJECTOR_IMPL = INJECTOR_IMPL__PRE_R3__;\n\n/**\n * Concrete injectors implement this interface.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n  static NULL: Injector = new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n  /**\n   * Create a new Injector which is configure using `StaticProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n   */\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return INJECTOR_IMPL(options, parent, '');\n    } else {\n      return INJECTOR_IMPL(options.providers, options.parent, options.name || '');\n    }\n  }\n\n  /** @nocollapse */\n  static Éµprov = ÉµÉµdefineInjectable({\n    token: Injector,\n    providedIn: 'any' as any,\n    factory: () => ÉµÉµinject(INJECTOR),\n  });\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = -1;\n}\n\n\n\nconst IDENT = function<T>(value: T): T {\n  return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\n\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst NO_NEW_LINE = 'Éµ';\n\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\n  readonly source: string|null;\n  readonly scope: string|null;\n\n  private _records: Map<any, Record|null>;\n\n  constructor(\n      providers: StaticProvider[], parent: Injector = Injector.NULL, source: string|null = null) {\n    this.parent = parent;\n    this.source = source;\n    const records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    records.set(\n        INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    this.scope = recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  get(token: any, notFoundValue?: any): any;\n  get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n    const records = this._records;\n    let record = records.get(token);\n    if (record === undefined) {\n      // This means we have never seen this record, see if it is tree shakable provider.\n      const injectableDef = getInjectableDef(token);\n      if (injectableDef) {\n        const providedIn = injectableDef && injectableDef.providedIn;\n        if (providedIn === 'any' || providedIn != null && providedIn === this.scope) {\n          records.set(\n              token, record = resolveProvider(\n                         {provide: token, useFactory: injectableDef.factory, deps: EMPTY}));\n        }\n      }\n      if (record === undefined) {\n        // Set record to null to make sure that we don't go through expensive lookup above again.\n        records.set(token, null);\n      }\n    }\n    let lastInjector = setCurrentInjector(this);\n    try {\n      return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);\n    } catch (e) {\n      return catchInjectorError(e, token, 'StaticInjectorError', this.source);\n    } finally {\n      setCurrentInjector(lastInjector);\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const deps = computeDeps(provider);\n  let fn: Function = IDENT;\n  let value: any = EMPTY;\n  let useNew: boolean = false;\n  let provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = (provider as ValueProvider).useValue;\n  } else if ((provider as FactoryProvider).useFactory) {\n    fn = (provider as FactoryProvider).useFactory;\n  } else if ((provider as ExistingProvider).useExisting) {\n    // Just use IDENT\n  } else if ((provider as StaticClassProvider).useClass) {\n    useNew = true;\n    fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider): string|\n    null {\n  let scope: string|null = null;\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (Array.isArray(provider)) {\n      // if we have an array recurse into the array\n      for (let i = 0; i < provider.length; i++) {\n        scope = recursivelyProcessProviders(records, provider[i]) || scope;\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let token = resolveForwardRef(provider.provide);\n      const resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          });\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      if (token === INJECTOR_SCOPE) {\n        scope = resolvedProvider.value;\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n  return scope;\n}\n\nfunction tryResolveToken(\n    token: any, record: Record | undefined | null, records: Map<any, Record|null>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue, flags);\n  } catch (e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n\nfunction resolveToken(\n    token: any, record: Record | undefined | null, records: Map<any, Record|null>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  let value;\n  if (record && !(flags & InjectFlags.SkipSelf)) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let obj = undefined;\n      let useNew = record.useNew;\n      let fn = record.fn;\n      let depRecords = record.deps;\n      let deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let i = 0; i < depRecords.length; i++) {\n          const depRecord: DependencyRecord = depRecords[i];\n          const options = depRecord.options;\n          const childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? Injector.NULL : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n              InjectFlags.Default));\n        }\n      }\n      record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(obj, deps);\n    }\n  } else if (!(flags & InjectFlags.Self)) {\n    value = parent.get(token, notFoundValue, InjectFlags.Default);\n  } else if (!(flags & InjectFlags.Optional)) {\n    value = Injector.NULL.get(token, notFoundValue);\n  } else {\n    value = Injector.NULL.get(token, typeof notFoundValue !== 'undefined' ? notFoundValue : null);\n  }\n  return value;\n}\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (Array.isArray(token)) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if ((provider as ExistingProvider).useExisting) {\n    const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj, 'StaticInjectorError'));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {ERROR_ORIGINAL_ERROR, wrappedError} from '../util/errors';\nimport {stringify} from '../util/stringify';\n\nimport {ReflectiveInjector} from './reflective_injector';\nimport {ReflectiveKey} from './reflective_key';\n\nfunction findFirstClosedCycle(keys: any[]): any[] {\n  const res: any[] = [];\n  for (let i = 0; i < keys.length; ++i) {\n    if (res.indexOf(keys[i]) > -1) {\n      res.push(keys[i]);\n      return res;\n    }\n    res.push(keys[i]);\n  }\n  return res;\n}\n\nfunction constructResolvingPath(keys: any[]): string {\n  if (keys.length > 1) {\n    const reversed = findFirstClosedCycle(keys.slice().reverse());\n    const tokenStrs = reversed.map(k => stringify(k.token));\n    return ' (' + tokenStrs.join(' -> ') + ')';\n  }\n\n  return '';\n}\n\nexport interface InjectionError extends Error {\n  keys: ReflectiveKey[];\n  injectors: ReflectiveInjector[];\n  constructResolvingMessage: (keys: ReflectiveKey[]) => string;\n  addKey(injector: ReflectiveInjector, key: ReflectiveKey): void;\n}\n\nfunction injectionError(\n    injector: ReflectiveInjector, key: ReflectiveKey,\n    constructResolvingMessage: (keys: ReflectiveKey[]) => string,\n    originalError?: Error): InjectionError {\n  const keys = [key];\n  const errMsg = constructResolvingMessage(keys);\n  const error =\n      (originalError ? wrappedError(errMsg, originalError) : Error(errMsg)) as InjectionError;\n  error.addKey = addKey;\n  error.keys = keys;\n  error.injectors = [injector];\n  error.constructResolvingMessage = constructResolvingMessage;\n  (error as any)[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n\nfunction addKey(this: InjectionError, injector: ReflectiveInjector, key: ReflectiveKey): void {\n  this.injectors.push(injector);\n  this.keys.push(key);\n  // Note: This updated message won't be reflected in the `.stack` property\n  this.message = this.constructResolvingMessage(this.keys);\n}\n\n/**\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n * {@link Injector} does not have a {@link Provider} for the given key.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n */\nexport function noProviderError(injector: ReflectiveInjector, key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    const first = stringify(keys[0].token);\n    return `No provider for ${first}!${constructResolvingPath(keys)}`;\n  });\n}\n\n/**\n * Thrown when dependencies form a cycle.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n *\n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n *\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n */\nexport function cyclicDependencyError(\n    injector: ReflectiveInjector, key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;\n  });\n}\n\n/**\n * Thrown when a constructing type returns with an Error.\n *\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n *\n * var injector = Injector.resolveAndCreate([A]);\n\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n */\nexport function instantiationError(\n    injector: ReflectiveInjector, originalException: any, originalStack: any,\n    key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    const first = stringify(keys[0].token);\n    return `${originalException.message}: Error during instantiation of ${first}!${constructResolvingPath(keys)}.`;\n  }, originalException);\n}\n\n/**\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n * creation.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n */\nexport function invalidProviderError(provider: any) {\n  return Error(\n      `Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);\n}\n\n/**\n * Thrown when the class has no annotation information.\n *\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n *\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n *\n * ```typescript\n * class B {}\n *\n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n *\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n *\n */\nexport function noAnnotationError(typeOrFunc: Type<any>| Function, params: any[][]): Error {\n  const signature: string[] = [];\n  for (let i = 0, ii = params.length; i < ii; i++) {\n    const parameter = params[i];\n    if (!parameter || parameter.length == 0) {\n      signature.push('?');\n    } else {\n      signature.push(parameter.map(stringify).join(' '));\n    }\n  }\n  return Error(\n      'Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n      signature.join(', ') + '). ' +\n      'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' +\n      stringify(typeOrFunc) + '\\' is decorated with Injectable.');\n}\n\n/**\n * Thrown when getting an object by index.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {}\n *\n * var injector = Injector.resolveAndCreate([A]);\n *\n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n *\n */\nexport function outOfBoundsError(index: number) {\n  return Error(`Index ${index} is out-of-bounds.`);\n}\n\n// TODO: add a working example after alpha38 is released\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\nexport function mixingMultiProvidersWithRegularProvidersError(\n    provider1: any, provider2: any): Error {\n  return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {stringify} from '../util/stringify';\nimport {resolveForwardRef} from './forward_ref';\n\n\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n *\n * @deprecated No replacement\n * @publicApi\n */\nexport class ReflectiveKey {\n  public readonly displayName: string;\n  /**\n   * Private\n   */\n  constructor(public token: Object, public id: number) {\n    if (!token) {\n      throw new Error('Token must be defined!');\n    }\n    this.displayName = stringify(this.token);\n  }\n\n  /**\n   * Retrieves a `Key` for a token.\n   */\n  static get(token: Object): ReflectiveKey {\n    return _globalKeyRegistry.get(resolveForwardRef(token));\n  }\n\n  /**\n   * @returns the number of keys registered in the system.\n   */\n  static get numberOfKeys(): number { return _globalKeyRegistry.numberOfKeys; }\n}\n\nexport class KeyRegistry {\n  private _allKeys = new Map<Object, ReflectiveKey>();\n\n  get(token: Object): ReflectiveKey {\n    if (token instanceof ReflectiveKey) return token;\n\n    if (this._allKeys.has(token)) {\n      return this._allKeys.get(token) !;\n    }\n\n    const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n    this._allKeys.set(token, newKey);\n    return newKey;\n  }\n\n  get numberOfKeys(): number { return this._allKeys.size; }\n}\n\nconst _globalKeyRegistry = new KeyRegistry();\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n\nexport {PlatformReflectionCapabilities};\nexport {GetterFn, MethodFn, SetterFn};\n\n/**\n * Provides access to reflection data about symbols. Used internally by Angular\n * to power dependency injection and compilation.\n */\nexport class Reflector {\n  constructor(public reflectionCapabilities: PlatformReflectionCapabilities) {}\n\n  updateCapabilities(caps: PlatformReflectionCapabilities) { this.reflectionCapabilities = caps; }\n\n  factory(type: Type<any>): Function { return this.reflectionCapabilities.factory(type); }\n\n  parameters(typeOrFunc: Type<any>): any[][] {\n    return this.reflectionCapabilities.parameters(typeOrFunc);\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    return this.reflectionCapabilities.annotations(typeOrFunc);\n  }\n\n  propMetadata(typeOrFunc: Type<any>): {[key: string]: any[]} {\n    return this.reflectionCapabilities.propMetadata(typeOrFunc);\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);\n  }\n\n  getter(name: string): GetterFn { return this.reflectionCapabilities.getter(name); }\n\n  setter(name: string): SetterFn { return this.reflectionCapabilities.setter(name); }\n\n  method(name: string): MethodFn { return this.reflectionCapabilities.method(name); }\n\n  importUri(type: any): string { return this.reflectionCapabilities.importUri(type); }\n\n  resourceUri(type: any): string { return this.reflectionCapabilities.resourceUri(type); }\n\n  resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);\n  }\n\n  resolveEnum(identifier: any, name: string): any {\n    return this.reflectionCapabilities.resolveEnum(identifier, name);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ReflectionCapabilities} from './reflection_capabilities';\nimport {Reflector} from './reflector';\n\nexport {Reflector} from './reflector';\n\n/**\n * The {@link Reflector} used internally in Angular to access metadata\n * about symbols.\n */\nexport const reflector = new Reflector(new ReflectionCapabilities());\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {reflector} from '../reflection/reflection';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {ClassProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ValueProvider} from './interface/provider';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {invalidProviderError, mixingMultiProvidersWithRegularProvidersError, noAnnotationError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\n\n\ninterface NormalizedProvider extends TypeProvider, ValueProvider, ClassProvider, ExistingProvider,\n    FactoryProvider {}\n\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\nexport class ReflectiveDependency {\n  constructor(\n      public key: ReflectiveKey, public optional: boolean, public visibility: Self|SkipSelf|null) {}\n\n  static fromKey(key: ReflectiveKey): ReflectiveDependency {\n    return new ReflectiveDependency(key, false, null);\n  }\n}\n\nconst _EMPTY_LIST: any[] = [];\n\n/**\n * An internal resolved representation of a `Provider` used by the `Injector`.\n *\n * @usageNotes\n * This is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @publicApi\n */\nexport interface ResolvedReflectiveProvider {\n  /**\n   * A key, usually a `Type<any>`.\n   */\n  key: ReflectiveKey;\n\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  resolvedFactories: ResolvedReflectiveFactory[];\n\n  /**\n   * Indicates if the provider is a multi-provider or a regular provider.\n   */\n  multiProvider: boolean;\n}\n\nexport class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\n  readonly resolvedFactory: ResolvedReflectiveFactory;\n\n  constructor(\n      public key: ReflectiveKey, public resolvedFactories: ResolvedReflectiveFactory[],\n      public multiProvider: boolean) {\n    this.resolvedFactory = this.resolvedFactories[0];\n  }\n}\n\n/**\n * An internal resolved representation of a factory function created by resolving `Provider`.\n * @publicApi\n */\nexport class ResolvedReflectiveFactory {\n  constructor(\n      /**\n       * Factory function which can return an instance of an object represented by a key.\n       */\n      public factory: Function,\n\n      /**\n       * Arguments (dependencies) to the `factory` function.\n       */\n      public dependencies: ReflectiveDependency[]) {}\n}\n\n\n/**\n * Resolve a single provider.\n */\nfunction resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory {\n  let factoryFn: Function;\n  let resolvedDeps: ReflectiveDependency[];\n  if (provider.useClass) {\n    const useClass = resolveForwardRef(provider.useClass);\n    factoryFn = reflector.factory(useClass);\n    resolvedDeps = _dependenciesFor(useClass);\n  } else if (provider.useExisting) {\n    factoryFn = (aliasInstance: any) => aliasInstance;\n    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n  } else if (provider.useFactory) {\n    factoryFn = provider.useFactory;\n    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n  } else {\n    factoryFn = () => provider.useValue;\n    resolvedDeps = _EMPTY_LIST;\n  }\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n\n/**\n * Converts the `Provider` into `ResolvedProvider`.\n *\n * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider\n * syntax.\n */\nfunction resolveReflectiveProvider(provider: NormalizedProvider): ResolvedReflectiveProvider {\n  return new ResolvedReflectiveProvider_(\n      ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)],\n      provider.multi || false);\n}\n\n/**\n * Resolve a list of Providers.\n */\nexport function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[] {\n  const normalized = _normalizeProviders(providers, []);\n  const resolved = normalized.map(resolveReflectiveProvider);\n  const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n  return Array.from(resolvedProviderMap.values());\n}\n\n/**\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\n * multi providers have been merged.\n */\nexport function mergeResolvedReflectiveProviders(\n    providers: ResolvedReflectiveProvider[],\n    normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>):\n    Map<number, ResolvedReflectiveProvider> {\n  for (let i = 0; i < providers.length; i++) {\n    const provider = providers[i];\n    const existing = normalizedProvidersMap.get(provider.key.id);\n    if (existing) {\n      if (provider.multiProvider !== existing.multiProvider) {\n        throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\n      }\n      if (provider.multiProvider) {\n        for (let j = 0; j < provider.resolvedFactories.length; j++) {\n          existing.resolvedFactories.push(provider.resolvedFactories[j]);\n        }\n      } else {\n        normalizedProvidersMap.set(provider.key.id, provider);\n      }\n    } else {\n      let resolvedProvider: ResolvedReflectiveProvider;\n      if (provider.multiProvider) {\n        resolvedProvider = new ResolvedReflectiveProvider_(\n            provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n      } else {\n        resolvedProvider = provider;\n      }\n      normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n    }\n  }\n  return normalizedProvidersMap;\n}\n\nfunction _normalizeProviders(\n    providers: Provider[], res: NormalizedProvider[]): NormalizedProvider[] {\n  providers.forEach(b => {\n    if (b instanceof Type) {\n      res.push({ provide: b, useClass: b } as NormalizedProvider);\n\n    } else if (b && typeof b == 'object' && (b as any).provide !== undefined) {\n      res.push(b as NormalizedProvider);\n\n    } else if (Array.isArray(b)) {\n      _normalizeProviders(b, res);\n\n    } else {\n      throw invalidProviderError(b);\n    }\n  });\n\n  return res;\n}\n\nexport function constructDependencies(\n    typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[] {\n  if (!dependencies) {\n    return _dependenciesFor(typeOrFunc);\n  } else {\n    const params: any[][] = dependencies.map(t => [t]);\n    return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n  }\n}\n\nfunction _dependenciesFor(typeOrFunc: any): ReflectiveDependency[] {\n  const params = reflector.parameters(typeOrFunc);\n\n  if (!params) return [];\n  if (params.some(p => p == null)) {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n  return params.map(p => _extractToken(typeOrFunc, p, params));\n}\n\nfunction _extractToken(\n    typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency {\n  let token: any = null;\n  let optional = false;\n\n  if (!Array.isArray(metadata)) {\n    if (metadata instanceof Inject) {\n      return _createDependency(metadata.token, optional, null);\n    } else {\n      return _createDependency(metadata, optional, null);\n    }\n  }\n\n  let visibility: Self|SkipSelf|null = null;\n\n  for (let i = 0; i < metadata.length; ++i) {\n    const paramMetadata = metadata[i];\n\n    if (paramMetadata instanceof Type) {\n      token = paramMetadata;\n\n    } else if (paramMetadata instanceof Inject) {\n      token = paramMetadata.token;\n\n    } else if (paramMetadata instanceof Optional) {\n      optional = true;\n\n    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n      visibility = paramMetadata;\n    } else if (paramMetadata instanceof InjectionToken) {\n      token = paramMetadata;\n    }\n  }\n\n  token = resolveForwardRef(token);\n\n  if (token != null) {\n    return _createDependency(token, optional, visibility);\n  } else {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n}\n\nfunction _createDependency(\n    token: any, optional: boolean, visibility: Self | SkipSelf | null): ReflectiveDependency {\n  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from './injector';\nimport {THROW_IF_NOT_FOUND} from './injector_compatibility';\nimport {Provider} from './interface/provider';\nimport {Self, SkipSelf} from './metadata';\nimport {cyclicDependencyError, instantiationError, noProviderError, outOfBoundsError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\nimport {ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider, resolveReflectiveProviders} from './reflective_provider';\n\n\n// Threshold for the dynamic version\nconst UNDEFINED = {};\n\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n * @publicApi\n */\nexport abstract class ReflectiveInjector implements Injector {\n  /**\n   * Turns an array of provider definitions into an array of resolved providers.\n   *\n   * A resolution is a process of flattening multiple nested arrays and converting individual\n   * providers into an array of `ResolvedReflectiveProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n   *\n   * expect(providers.length).toEqual(2);\n   *\n   * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n   * expect(providers[0].key.displayName).toBe(\"Car\");\n   * expect(providers[0].dependencies.length).toEqual(1);\n   * expect(providers[0].factory).toBeDefined();\n   *\n   * expect(providers[1].key.displayName).toBe(\"Engine\");\n   * });\n   * ```\n   *\n   */\n  static resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n\n  /**\n   * Resolves an array of providers and creates an injector from those providers.\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n  static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n\n  /**\n   * Creates an injector from previously resolved providers.\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, Engine]);\n   * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n  static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector):\n      ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n\n\n  /**\n   * Parent of this injector.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   */\n  abstract get parent(): Injector|null;\n\n  /**\n   * Resolves an array of providers and creates a child injector from those providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n   * var child = parent.resolveAndCreateChild([ChildProvider]);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\n\n  /**\n   * Creates a child injector from previously resolved providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n   * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n   *\n   * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n   * var child = parent.createChildFromResolved(childProviders);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\n\n  /**\n   * Resolves a provider and instantiates an object in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   *\n   * var car = injector.resolveAndInstantiate(Car);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n   * ```\n   */\n  abstract resolveAndInstantiate(provider: Provider): any;\n\n  /**\n   * Instantiates an object using a resolved provider in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   * var carProvider = ReflectiveInjector.resolve([Car])[0];\n   * var car = injector.instantiateResolved(carProvider);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n   * ```\n   */\n  abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;\n\n  abstract get(token: any, notFoundValue?: any): any;\n}\n\nexport class ReflectiveInjector_ implements ReflectiveInjector {\n  private static INJECTOR_KEY = ReflectiveKey.get(Injector);\n  /** @internal */\n  _constructionCounter: number = 0;\n  /** @internal */\n  public _providers: ResolvedReflectiveProvider[];\n  public readonly parent: Injector|null;\n\n  keyIds: number[];\n  objs: any[];\n  /**\n   * Private\n   */\n  constructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector) {\n    this._providers = _providers;\n    this.parent = _parent || null;\n\n    const len = _providers.length;\n\n    this.keyIds = [];\n    this.objs = [];\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n\n  get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n\n  resolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n\n  createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const inj = new ReflectiveInjector_(providers);\n    (inj as{parent: Injector | null}).parent = this;\n    return inj;\n  }\n\n  resolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n\n  instantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n\n  getProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw outOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n\n  /** @internal */\n  _new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw cyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n\n  private _getMaxNumberOfObjects(): number { return this.objs.length; }\n\n  private _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const res = [];\n      for (let i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n\n  private _instantiate(\n      provider: ResolvedReflectiveProvider,\n      ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const factory = ResolvedReflectiveFactory.factory;\n\n    let deps: any[];\n    try {\n      deps =\n          ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch (e) {\n      if (e.addKey) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let obj: any;\n    try {\n      obj = factory(...deps);\n    } catch (e) {\n      throw instantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n\n  private _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n\n  private _getByKey(key: ReflectiveKey, visibility: Self|SkipSelf|null, notFoundValue: any): any {\n    if (key === ReflectiveInjector_.INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n\n  private _getObjByKeyId(keyId: number): any {\n    for (let i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n\n  /** @internal */\n  _throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw noProviderError(this, key);\n    }\n  }\n\n  /** @internal */\n  _getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n\n  /** @internal */\n  _getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self|SkipSelf|null): any {\n    let inj: Injector|null;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this.parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const inj_ = <ReflectiveInjector_>inj;\n      const obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_.parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n\n  get displayName(): string {\n    const providers =\n        _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n\n  toString(): string { return this.displayName; }\n}\n\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const res: any[] = [];\n  for (let i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * The `di` module provides dependency injection container services.\n */\n\nexport * from './metadata';\nexport {InjectFlags} from './interface/injector';\nexport {ÉµÉµdefineInjectable, defineInjectable, ÉµÉµdefineInjector, InjectableType, InjectorType} from './interface/defs';\nexport {forwardRef, resolveForwardRef, ForwardRefFn} from './forward_ref';\nexport {Injectable, InjectableDecorator, InjectableProvider} from './injectable';\nexport {Injector} from './injector';\nexport {ÉµÉµinject, inject, INJECTOR} from './injector_compatibility';\nexport {ReflectiveInjector} from './reflective_injector';\nexport {ClassProvider, ClassSansProvider, ConstructorProvider, ConstructorSansProvider, ExistingProvider, ExistingSansProvider, FactoryProvider, FactorySansProvider, Provider, StaticClassProvider, StaticClassSansProvider, StaticProvider, TypeProvider, ValueProvider, ValueSansProvider} from './interface/provider';\nexport {ResolvedReflectiveFactory, ResolvedReflectiveProvider} from './reflective_provider';\nexport {ReflectiveKey} from './reflective_key';\nexport {InjectionToken} from './injection_token';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file should not be necessary because node resolution should just default to `./di/index`!\n *\n * However it does not seem to work and it breaks:\n *  - //packages/animations/browser/test:test_web_chromium-local\n *  - //packages/compiler-cli/test:extract_i18n\n *  - //packages/compiler-cli/test:ngc\n *  - //packages/compiler-cli/test:perform_watch\n *  - //packages/compiler-cli/test/diagnostics:check_types\n *  - //packages/compiler-cli/test/transformers:test\n *  - //packages/compiler/test:test\n *  - //tools/public_api_guard:core_api\n *\n * Remove this file once the above is solved or wait until `ngc` is deleted and then it should be\n * safe to delete this file.\n */\n\nexport * from './di/index';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../di/injection_token';\nimport {Type} from '../interface/type';\nimport {makePropDecorator} from '../util/decorators';\n\n/**\n * A DI token that you can use to create a virtual [provider](guide/glossary#provider)\n * that will populate the `entryComponents` field of components and NgModules\n * based on its `useValue` property value.\n * All components that are referenced in the `useValue` value (either directly\n * or in a nested array or map) are added to the `entryComponents` property.\n *\n * @usageNotes\n *\n * The following example shows how the router can populate the `entryComponents`\n * field of an NgModule based on a router configuration that refers\n * to components.\n *\n * ```typescript\n * // helper function inside the router\n * function provideRoutes(routes) {\n *   return [\n *     {provide: ROUTES, useValue: routes},\n *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\n *   ];\n * }\n *\n * // user code\n * let routes = [\n *   {path: '/root', component: RootComp},\n *   {path: '/teams', component: TeamsComp}\n * ];\n *\n * @NgModule({\n *   providers: [provideRoutes(routes)]\n * })\n * class ModuleWithRoutes {}\n * ```\n *\n * @publicApi\n * @deprecated Since 9.0.0. With Ivy, this property is no longer necessary.\n */\nexport const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken<any>('AnalyzeForEntryComponents');\n\n/**\n * Type of the `Attribute` decorator / constructor function.\n *\n * @publicApi\n */\nexport interface AttributeDecorator {\n  /**\n   * Specifies that a constant attribute value should be injected.\n   *\n   * The directive can inject constant string literals of host element attributes.\n   *\n   * @usageNotes\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * A decorator can inject string literal `text` as in the following example.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n   *\n   * @publicApi\n   */\n  (name: string): any;\n  new (name: string): Attribute;\n}\n\n\n/**\n * Type of the Attribute metadata.\n *\n * @publicApi\n */\nexport interface Attribute {\n  /**\n   * The name of the attribute to be injected into the constructor.\n   */\n  attributeName?: string;\n}\n\n/**\n * Type of the Query metadata.\n *\n * @publicApi\n */\nexport interface Query {\n  descendants: boolean;\n  first: boolean;\n  read: any;\n  isViewQuery: boolean;\n  selector: any;\n  static?: boolean;\n}\n\n/**\n * Base class for query metadata.\n *\n * @see `ContentChildren`.\n * @see `ContentChild`.\n * @see `ViewChildren`.\n * @see `ViewChild`.\n *\n * @publicApi\n */\nexport abstract class Query {}\n\n/**\n * Type of the ContentChildren decorator / constructor function.\n *\n * @see `ContentChildren`.\n * @publicApi\n */\nexport interface ContentChildrenDecorator {\n  /**\n   * Parameter decorator that configures a content query.\n   *\n   * Use to get the `QueryList` of elements or directives from the content DOM.\n   * Any time a child element is added, removed, or moved, the query list will be\n   * updated, and the changes observable of the query list will emit a new value.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   *\n   * Does not retrieve elements or directives that are in other components' templates,\n   * since a component's template is always a black box to its ancestors.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - The directive type or the name used for querying.\n   * * **descendants** - True to include all descendants, otherwise include only direct children.\n   * * **read** - True to read a different token from the queried elements.\n   *\n   * @usageNotes\n   *\n   * Here is a simple demonstration of how the `ContentChildren` decorator can be used.\n   *\n   * {@example core/di/ts/contentChildren/content_children_howto.ts region='HowTo'}\n   *\n   * ### Tab-pane example\n   *\n   * Here is a slightly more realistic example that shows how `ContentChildren` decorators\n   * can be used to implement a tab pane component.\n   *\n   * {@example core/di/ts/contentChildren/content_children_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {descendants?: boolean, read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {descendants?: boolean, read?: any}): Query;\n}\n\n/**\n * Type of the ContentChildren metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nexport type ContentChildren = Query;\n\n/**\n * ContentChildren decorator and metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nexport const ContentChildren: ContentChildrenDecorator = makePropDecorator(\n    'ContentChildren',\n    (selector?: any, data: any = {}) =>\n        ({selector, first: false, isViewQuery: false, descendants: false, ...data}),\n    Query);\n\n/**\n * Type of the ContentChild decorator / constructor function.\n *\n * @publicApi\n */\nexport interface ContentChildDecorator {\n  /**\n   * Parameter decorator that configures a content query.\n   *\n   * Use to get the first element or the directive matching the selector from the content DOM.\n   * If the content DOM changes, and a new child matches the selector,\n   * the property will be updated.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   *\n   * Does not retrieve elements or directives that are in other components' templates,\n   * since a component's template is always a black box to its ancestors.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - The directive type or the name used for querying.\n   * * **read** - True to read a different token from the queried element.\n   * * **static** - True to resolve query results before change detection runs,\n   * false to resolve after change detection. Defaults to false.\n   *\n   * @usageNotes\n   *\n   * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {read?: any, static?: boolean}): any;\n  new (selector: Type<any>|Function|string, opts?: {read?: any, static?: boolean}): ContentChild;\n}\n\n/**\n * Type of the ContentChild metadata.\n *\n * @publicApi\n */\nexport type ContentChild = Query;\n\n/**\n * ContentChild decorator and metadata.\n *\n *\n * @Annotation\n *\n * @publicApi\n */\nexport const ContentChild: ContentChildDecorator = makePropDecorator(\n    'ContentChild', (selector?: any, data: any = {}) =>\n                        ({selector, first: true, isViewQuery: false, descendants: true, ...data}),\n    Query);\n\n/**\n * Type of the ViewChildren decorator / constructor function.\n *\n * @see `ViewChildren`.\n *\n * @publicApi\n */\nexport interface ViewChildrenDecorator {\n  /**\n   * Parameter decorator that configures a view query.\n   *\n   * Use to get the `QueryList` of elements or directives from the view DOM.\n   * Any time a child element is added, removed, or moved, the query list will be updated,\n   * and the changes observable of the query list will emit a new value.\n   *\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - The directive type or the name used for querying.\n   * * **read** - True to read a different token from the queried elements.\n   *\n   * @usageNotes\n   *\n   * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}\n   *\n   * ### Another example\n   *\n   * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {read?: any}): ViewChildren;\n}\n\n/**\n * Type of the ViewChildren metadata.\n *\n * @publicApi\n */\nexport type ViewChildren = Query;\n\n/**\n * ViewChildren decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const ViewChildren: ViewChildrenDecorator = makePropDecorator(\n    'ViewChildren', (selector?: any, data: any = {}) =>\n                        ({selector, first: false, isViewQuery: true, descendants: true, ...data}),\n    Query);\n\n/**\n * Type of the ViewChild decorator / constructor function.\n *\n * @see `ViewChild`.\n * @publicApi\n */\nexport interface ViewChildDecorator {\n  /**\n   * @description\n   * Property decorator that configures a view query.\n   * The change detector looks for the first element or the directive matching the selector\n   * in the view DOM. If the view DOM changes, and a new child matches the selector,\n   * the property is updated.\n   *\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - The directive type or the name used for querying.\n   * * **read** - True to read a different token from the queried elements.\n   * * **static** - True to resolve query results before change detection runs,\n   * false to resolve after change detection. Defaults to false.\n   *\n   *\n   * The following selectors are supported.\n   *   * Any class with the `@Component` or `@Directive` decorator\n   *   * A template reference variable as a string (e.g. query `<my-component #cmp></my-component>`\n   * with `@ViewChild('cmp')`)\n   *   * Any provider defined in the child component tree of the current component (e.g.\n   * `@ViewChild(SomeService) someService: SomeService`)\n   *   * Any provider defined through a string token (e.g. `@ViewChild('someToken') someTokenVal:\n   * any`)\n   *   * A `TemplateRef` (e.g. query `<ng-template></ng-template>` with `@ViewChild(TemplateRef)\n   * template;`)\n   *\n   * @usageNotes\n   *\n   * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}\n   *\n   * ### Example 2\n   *\n   * {@example core/di/ts/viewChild/view_child_howto.ts region='HowTo'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {read?: any, static?: boolean}): any;\n  new (selector: Type<any>|Function|string, opts?: {read?: any, static?: boolean}): ViewChild;\n}\n\n/**\n * Type of the ViewChild metadata.\n *\n * @publicApi\n */\nexport type ViewChild = Query;\n\n/**\n * ViewChild decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const ViewChild: ViewChildDecorator = makePropDecorator(\n    'ViewChild', (selector: any, data: any) =>\n                     ({selector, first: true, isViewQuery: true, descendants: true, ...data}),\n    Query);\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {Component} from './directives';\n\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nexport function resolveComponentResources(\n    resourceResolver: (url: string) => (Promise<string|{text(): Promise<string>}>)): Promise<void> {\n  // Store all promises which are fetching the resources.\n  const componentResolved: Promise<void>[] = [];\n\n  // Cache so that we don't fetch the same resource more than once.\n  const urlMap = new Map<string, Promise<string>>();\n  function cachedResourceResolve(url: string): Promise<string> {\n    let promise = urlMap.get(url);\n    if (!promise) {\n      const resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n    return promise;\n  }\n\n  componentResourceResolutionQueue.forEach((component: Component, type: Type<any>) => {\n    const promises: Promise<void>[] = [];\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {\n        component.template = template;\n      }));\n    }\n    const styleUrls = component.styleUrls;\n    const styles = component.styles || (component.styles = []);\n    const styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach((styleUrl, index) => {\n      styles.push('');  // pre-allocate array.\n      promises.push(cachedResourceResolve(styleUrl).then((style) => {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      }));\n    });\n    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(() => undefined);\n}\n\nlet componentResourceResolutionQueue = new Map<Type<any>, Component>();\n\n// Track when existing Éµcmp for a Type is waiting on resources.\nconst componentDefPendingResolution = new Set<Type<any>>();\n\nexport function maybeQueueResolutionOfComponentResources(type: Type<any>, metadata: Component) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\n\nexport function isComponentDefPendingResolution(type: Type<any>): boolean {\n  return componentDefPendingResolution.has(type);\n}\n\nexport function componentNeedsResolution(component: Component): boolean {\n  return !!(\n      (component.templateUrl && !component.hasOwnProperty('template')) ||\n      component.styleUrls && component.styleUrls.length);\n}\nexport function clearResolutionOfComponentResourcesQueue(): Map<Type<any>, Component> {\n  const old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = new Map();\n  return old;\n}\n\nexport function restoreComponentResolutionQueue(queue: Map<Type<any>, Component>): void {\n  componentDefPendingResolution.clear();\n  queue.forEach((_, type) => componentDefPendingResolution.add(type));\n  componentResourceResolutionQueue = queue;\n}\n\nexport function isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\n\nfunction unwrapResponse(response: string | {text(): Promise<string>}): string|Promise<string> {\n  return typeof response == 'string' ? response : response.text();\n}\n\nfunction componentDefResolved(type: Type<any>): void {\n  componentDefPendingResolution.delete(type);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from '../../util/assert';\nimport {ComponentDef, DirectiveDef} from '../interfaces/definition';\nimport {LView, TVIEW, TView} from '../interfaces/view';\nimport {getCurrentDirectiveDef, getLView} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\n/**\n * Allocates the necessary amount of slots for host vars.\n *\n * @param count Amount of vars to be allocated\n *\n * @codeGenApi\n */\nexport function ÉµÉµallocHostVars(count: number): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  if (!tView.firstCreatePass) return;\n  queueHostBindingForCheck(tView, getCurrentDirectiveDef() !, count);\n  prefillHostVars(tView, lView, count);\n}\n\n/**\n * Stores host binding fn and number of host vars so it will be queued for binding refresh during\n * CD.\n */\nfunction queueHostBindingForCheck(\n    tView: TView, def: DirectiveDef<any>| ComponentDef<any>, hostVars: number): void {\n  ngDevMode &&\n      assertEqual(tView.firstCreatePass, true, 'Should only be called in first create pass.');\n  const expando = tView.expandoInstructions !;\n  const length = expando.length;\n  // Check whether a given `hostBindings` function already exists in expandoInstructions,\n  // which can happen in case directive definition was extended from base definition (as a part of\n  // the `InheritDefinitionFeature` logic). If we found the same `hostBindings` function in the\n  // list, we just increase the number of host vars associated with that function, but do not add it\n  // into the list again.\n  if (length >= 2 && expando[length - 2] === def.hostBindings) {\n    expando[length - 1] = (expando[length - 1] as number) + hostVars;\n  } else {\n    expando.push(def.hostBindings !, hostVars);\n  }\n}\n\n/**\n * On the first template pass, we need to reserve space for host binding values\n * after directives are matched (so all directives are saved, then bindings).\n * Because we are updating the blueprint, we only need to do this once.\n */\nfunction prefillHostVars(tView: TView, lView: LView, totalHostVars: number): void {\n  ngDevMode &&\n      assertEqual(tView.firstCreatePass, true, 'Should only be called in first create pass.');\n  for (let i = 0; i < totalHostVars; i++) {\n    lView.push(NO_CHANGE);\n    tView.blueprint.push(NO_CHANGE);\n    tView.data.push(null);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global as _global} from './global';\n\n// When Symbol.iterator doesn't exist, retrieves the key used in es6-shim\ndeclare const Symbol: any;\nlet _symbolIterator: any = null;\nexport function getSymbolIterator(): string|symbol {\n  if (!_symbolIterator) {\n    const Symbol = _global['Symbol'];\n    if (Symbol && Symbol.iterator) {\n      _symbolIterator = Symbol.iterator;\n    } else {\n      // es6-shim specific logic\n      const keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key !== 'entries' && key !== 'size' &&\n            (Map as any).prototype[key] === Map.prototype['entries']) {\n          _symbolIterator = key;\n        }\n      }\n    }\n  }\n  return _symbolIterator;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getSymbolIterator} from './symbol';\n\n\nexport function isListLikeIterable(obj: any): boolean {\n  if (!isJsObject(obj)) return false;\n  return Array.isArray(obj) ||\n      (!(obj instanceof Map) &&      // JS Map are iterables but return entries as [k, v]\n       getSymbolIterator() in obj);  // JS Iterable have a Symbol.iterator prop\n}\n\nexport function areIterablesEqual(\n    a: any, b: any, comparator: (a: any, b: any) => boolean): boolean {\n  const iterator1 = a[getSymbolIterator()]();\n  const iterator2 = b[getSymbolIterator()]();\n\n  while (true) {\n    const item1 = iterator1.next();\n    const item2 = iterator2.next();\n    if (item1.done && item2.done) return true;\n    if (item1.done || item2.done) return false;\n    if (!comparator(item1.value, item2.value)) return false;\n  }\n}\n\nexport function iterateListLike(obj: any, fn: (p: any) => any) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn(obj[i]);\n    }\n  } else {\n    const iterator = obj[getSymbolIterator()]();\n    let item: any;\n    while (!((item = iterator.next()).done)) {\n      fn(item.value);\n    }\n  }\n}\n\nexport function isJsObject(o: any): boolean {\n  return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {areIterablesEqual, isListLikeIterable} from './iterable';\n\n\n// JS has NaN !== NaN\nexport function looseIdentical(a: any, b: any): boolean {\n  return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n}\n\nexport function devModeEqual(a: any, b: any): boolean {\n  const isListLikeIterableA = isListLikeIterable(a);\n  const isListLikeIterableB = isListLikeIterable(b);\n  if (isListLikeIterableA && isListLikeIterableB) {\n    return areIterablesEqual(a, b, devModeEqual);\n  } else {\n    const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n    const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n      return true;\n    } else {\n      return looseIdentical(a, b);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {looseIdentical} from '../util/comparison';\nimport {getSymbolIterator} from '../util/symbol';\n\nexport function devModeEqual(a: any, b: any): boolean {\n  const isListLikeIterableA = isListLikeIterable(a);\n  const isListLikeIterableB = isListLikeIterable(b);\n  if (isListLikeIterableA && isListLikeIterableB) {\n    return areIterablesEqual(a, b, devModeEqual);\n  } else {\n    const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n    const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n      return true;\n    } else {\n      return looseIdentical(a, b);\n    }\n  }\n}\n\n/**\n * Indicates that the result of a {@link Pipe} transformation has changed even though the\n * reference has not changed.\n *\n * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value\n * is stored.\n *\n * Example:\n *\n * ```\n * if (this._latestValue === this._latestReturnedValue) {\n *    return this._latestReturnedValue;\n *  } else {\n *    this._latestReturnedValue = this._latestValue;\n *    return WrappedValue.wrap(this._latestValue); // this will force update\n *  }\n * ```\n *\n * @publicApi\n */\nexport class WrappedValue {\n  /** @deprecated from 5.3, use `unwrap()` instead - will switch to protected */\n  wrapped: any;\n\n  constructor(value: any) { this.wrapped = value; }\n\n  /** Creates a wrapped value. */\n  static wrap(value: any): WrappedValue { return new WrappedValue(value); }\n\n  /**\n   * Returns the underlying value of a wrapped value.\n   * Returns the given `value` when it is not wrapped.\n   **/\n  static unwrap(value: any): any { return WrappedValue.isWrapped(value) ? value.wrapped : value; }\n\n  /** Returns true if `value` is a wrapped value. */\n  static isWrapped(value: any): value is WrappedValue { return value instanceof WrappedValue; }\n}\n\nexport function isListLikeIterable(obj: any): boolean {\n  if (!isJsObject(obj)) return false;\n  return Array.isArray(obj) ||\n      (!(obj instanceof Map) &&      // JS Map are iterables but return entries as [k, v]\n       getSymbolIterator() in obj);  // JS Iterable have a Symbol.iterator prop\n}\n\nexport function areIterablesEqual(\n    a: any, b: any, comparator: (a: any, b: any) => boolean): boolean {\n  const iterator1 = a[getSymbolIterator()]();\n  const iterator2 = b[getSymbolIterator()]();\n\n  while (true) {\n    const item1 = iterator1.next();\n    const item2 = iterator2.next();\n    if (item1.done && item2.done) return true;\n    if (item1.done || item2.done) return false;\n    if (!comparator(item1.value, item2.value)) return false;\n  }\n}\n\nexport function iterateListLike(obj: any, fn: (p: any) => any) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn(obj[i]);\n    }\n  } else {\n    const iterator = obj[getSymbolIterator()]();\n    let item: any;\n    while (!((item = iterator.next()).done)) {\n      fn(item.value);\n    }\n  }\n}\n\nexport function isJsObject(o: any): boolean {\n  return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {devModeEqual} from '../change_detection/change_detection_util';\nimport {assertDataInRange, assertLessThan, assertNotSame} from '../util/assert';\nimport {throwErrorIfNoChangesMode} from './errors';\nimport {LView} from './interfaces/view';\nimport {getCheckNoChangesMode} from './state';\nimport {NO_CHANGE} from './tokens';\n\n\n// TODO(misko): consider inlining\n/** Updates binding and returns the value. */\nexport function updateBinding(lView: LView, bindingIndex: number, value: any): any {\n  return lView[bindingIndex] = value;\n}\n\n\n/** Gets the current binding value. */\nexport function getBinding(lView: LView, bindingIndex: number): any {\n  ngDevMode && assertDataInRange(lView, bindingIndex);\n  ngDevMode &&\n      assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return lView[bindingIndex];\n}\n\n/** Updates binding if changed, then returns whether it was updated. */\nexport function bindingUpdated(lView: LView, bindingIndex: number, value: any): boolean {\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode &&\n      assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);\n  const oldValue = lView[bindingIndex];\n\n  if (Object.is(oldValue, value)) {\n    return false;\n  } else {\n    if (ngDevMode && getCheckNoChangesMode()) {\n      // View engine didn't report undefined values as changed on the first checkNoChanges pass\n      // (before the change detection was run).\n      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;\n      if (!devModeEqual(oldValueToCompare, value)) {\n        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, oldValueToCompare, value);\n      }\n    }\n    lView[bindingIndex] = value;\n    return true;\n  }\n}\n\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport function bindingUpdated2(lView: LView, bindingIndex: number, exp1: any, exp2: any): boolean {\n  const different = bindingUpdated(lView, bindingIndex, exp1);\n  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\n}\n\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated3(\n    lView: LView, bindingIndex: number, exp1: any, exp2: any, exp3: any): boolean {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\n}\n\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated4(\n    lView: LView, bindingIndex: number, exp1: any, exp2: any, exp3: any, exp4: any): boolean {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {bindingUpdated} from '../bindings';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {getLView, getSelectedIndex, nextBindingIndex} from '../state';\n\nimport {TsickleIssue1009, elementAttributeInternal} from './shared';\n\n\n\n/**\n * Updates the value of or removes a bound attribute on an Element.\n *\n * Used in the case of `[attr.title]=\"value\"`\n *\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n * @param namespace Optional namespace to use when setting the attribute.\n *\n * @codeGenApi\n */\nexport function ÉµÉµattribute(\n    name: string, value: any, sanitizer?: SanitizerFn | null,\n    namespace?: string): TsickleIssue1009 {\n  const lView = getLView();\n  if (bindingUpdated(lView, nextBindingIndex(), value)) {\n    elementAttributeInternal(getSelectedIndex(), name, value, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattribute;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertLessThan} from '../../util/assert';\nimport {bindingUpdated, bindingUpdated2, bindingUpdated3, bindingUpdated4} from '../bindings';\nimport {LView} from '../interfaces/view';\nimport {getBindingIndex, incrementBindingIndex, nextBindingIndex, setBindingIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {renderStringify} from '../util/misc_utils';\n\n\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(lView: LView, values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let isBindingUpdated = false;\n  let bindingIndex = getBindingIndex();\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\n  }\n  setBindingIndex(bindingIndex);\n\n  if (!isBindingUpdated) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += renderStringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(lView: LView, prefix: string, v0: any, suffix: string): string|\n    NO_CHANGE {\n  const different = bindingUpdated(lView, nextBindingIndex(), v0);\n  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 2 expressions.\n */\nexport function interpolation2(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated2(lView, bindingIndex, v0, v1);\n  incrementBindingIndex(2);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 3 expressions.\n */\nexport function interpolation3(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\n  incrementBindingIndex(3);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix :\n      NO_CHANGE;\n}\n\n/**\n * Create an interpolation binding with 4 expressions.\n */\nexport function interpolation4(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  incrementBindingIndex(4);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n          renderStringify(v3) + suffix :\n      NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 5 expressions.\n */\nexport function interpolation5(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n  incrementBindingIndex(5);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n          renderStringify(v3) + i3 + renderStringify(v4) + suffix :\n      NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 6 expressions.\n */\nexport function interpolation6(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n  incrementBindingIndex(6);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n          renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 7 expressions.\n */\nexport function interpolation7(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n  incrementBindingIndex(7);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n          renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 +\n          renderStringify(v6) + suffix :\n      NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 8 expressions.\n */\nexport function interpolation8(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n  incrementBindingIndex(8);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n          renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 +\n          renderStringify(v6) + i6 + renderStringify(v7) + suffix :\n      NO_CHANGE;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {getLView, getSelectedIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {TsickleIssue1009, elementAttributeInternal} from './shared';\n\n\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµattributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµattributeInterpolate1(\n    attrName: string, prefix: string, v0: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    elementAttributeInternal(\n        getSelectedIndex(), attrName, interpolatedValue, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattributeInterpolate1;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµattributeInterpolate2(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    elementAttributeInternal(\n        getSelectedIndex(), attrName, interpolatedValue, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattributeInterpolate2;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµattributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµattributeInterpolate3(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    elementAttributeInternal(\n        getSelectedIndex(), attrName, interpolatedValue, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattributeInterpolate3;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµattributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµattributeInterpolate4(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn, namespace?: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    elementAttributeInternal(\n        getSelectedIndex(), attrName, interpolatedValue, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattributeInterpolate4;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµattributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµattributeInterpolate5(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    elementAttributeInternal(\n        getSelectedIndex(), attrName, interpolatedValue, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattributeInterpolate5;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµattributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµattributeInterpolate6(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    elementAttributeInternal(\n        getSelectedIndex(), attrName, interpolatedValue, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattributeInterpolate6;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµattributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµattributeInterpolate7(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): TsickleIssue1009 {\n  const index = getSelectedIndex();\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattributeInterpolate7;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµattributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµattributeInterpolate8(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    elementAttributeInternal(\n        getSelectedIndex(), attrName, interpolatedValue, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattributeInterpolate8;\n}\n\n/**\n * Update an interpolated attribute on an element with 8 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 7.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµattributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The a collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµattributeInterpolateV(\n    attrName: string, values: any[], sanitizer?: SanitizerFn,\n    namespace?: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    elementAttributeInternal(\n        getSelectedIndex(), attrName, interpolated, lView, sanitizer, namespace);\n  }\n  return ÉµÉµattributeInterpolateV;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from '../../util/assert';\nimport {getComponentViewByInstance} from '../context_discovery';\nimport {CONTEXT, RootContext, RootContextFlags} from '../interfaces/view';\nimport {getRootView} from '../util/view_traversal_utils';\nimport {detectChangesInternal, markViewDirty, scheduleTick, tickRootContext} from './shared';\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges<T>(component: T): void {\n  const view = getComponentViewByInstance(component);\n  detectChangesInternal<T>(view, component);\n}\n\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n *\n * @publicApi\n */\nexport function markDirty<T>(component: T) {\n  ngDevMode && assertDefined(component, 'component');\n  const rootView = markViewDirty(getComponentViewByInstance(component)) !;\n\n  ngDevMode && assertDefined(rootView[CONTEXT], 'rootContext should be defined');\n  scheduleTick(rootView[CONTEXT] as RootContext, RootContextFlags.DetectChanges);\n}\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport function tick<T>(component: T): void {\n  const rootView = getRootView(component);\n  const rootContext = rootView[CONTEXT] as RootContext;\n  tickRootContext(rootContext);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertDataInRange, assertEqual} from '../../util/assert';\nimport {assertFirstCreatePass, assertHasParent} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {executeCheckHooks, executeInitAndCheckHooks, incrementInitPhaseFlags, registerPostOrderHooks} from '../hooks';\nimport {ACTIVE_INDEX, CONTAINER_HEADER_OFFSET, LContainer} from '../interfaces/container';\nimport {ComponentTemplate} from '../interfaces/definition';\nimport {LocalRefExtractor, TAttributes, TContainerNode, TNode, TNodeType, TViewNode} from '../interfaces/node';\nimport {isDirectiveHost} from '../interfaces/type_checks';\nimport {FLAGS, HEADER_OFFSET, InitPhaseState, LView, LViewFlags, RENDERER, TVIEW, TView, TViewType, T_HOST} from '../interfaces/view';\nimport {assertNodeType} from '../node_assert';\nimport {appendChild, removeView} from '../node_manipulation';\nimport {getBindingIndex, getCheckNoChangesMode, getIsParent, getLView, getPreviousOrParentTNode, setIsNotParent, setPreviousOrParentTNode} from '../state';\nimport {getConstant, getLContainerActiveIndex, load} from '../util/view_utils';\n\nimport {addToViewTree, createDirectivesInstances, createLContainer, createTNode, createTView, getOrCreateTNode, resolveDirectives, saveResolvedLocalsInData} from './shared';\n\n\n\n/**\n * Creates an LContainer for inline views, e.g.\n *\n * % if (showing) {\n *   <div></div>\n * % }\n *\n * @param index The index of the container in the data array\n *\n * @codeGenApi\n */\nexport function ÉµÉµcontainer(index: number): void {\n  const lView = getLView();\n  const tNode = containerInternal(lView, index, null, null);\n\n  if (lView[TVIEW].firstCreatePass) {\n    tNode.tViews = [];\n  }\n  setIsNotParent();\n}\n\nfunction templateFirstCreatePass(\n    index: number, tView: TView, lView: LView, templateFn: ComponentTemplate<any>| null,\n    decls: number, vars: number, tagName?: string | null, attrsIndex?: number | null,\n    localRefsIndex?: number | null): TContainerNode {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  // TODO(pk): refactor getOrCreateTNode to have the \"create\" only version\n  const tNode = getOrCreateTNode(\n      tView, lView[T_HOST], index, TNodeType.Container, tagName || null,\n      getConstant<TAttributes>(tViewConsts, attrsIndex));\n\n  resolveDirectives(tView, lView, tNode, getConstant<string[]>(tViewConsts, localRefsIndex));\n  registerPostOrderHooks(tView, tNode);\n\n  const embeddedTView = tNode.tViews = createTView(\n      TViewType.Embedded, -1, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry,\n      null, tView.schemas, tViewConsts);\n  const embeddedTViewNode = createTNode(tView, null, TNodeType.View, -1, null, null) as TViewNode;\n  embeddedTViewNode.injectorIndex = tNode.injectorIndex;\n  embeddedTView.node = embeddedTViewNode;\n\n  if (tView.queries !== null) {\n    tView.queries.template(tView, tNode);\n    embeddedTView.queries = tView.queries.embeddedTView(tNode);\n  }\n\n  return tNode;\n}\n\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n *\n * @codeGenApi\n */\nexport function ÉµÉµtemplate(\n    index: number, templateFn: ComponentTemplate<any>| null, decls: number, vars: number,\n    tagName?: string | null, attrsIndex?: number | null, localRefsIndex?: number | null,\n    localRefExtractor?: LocalRefExtractor) {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  const tNode = tView.firstCreatePass ?\n      templateFirstCreatePass(\n          index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) :\n      tView.data[adjustedIndex] as TContainerNode;\n  setPreviousOrParentTNode(tNode, false);\n\n  const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n  appendChild(comment, tNode, lView);\n  attachPatchData(comment, lView);\n\n  addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n  }\n\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode, localRefExtractor);\n  }\n}\n\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n *\n * @codeGenApi\n */\nexport function ÉµÉµcontainerRefreshStart(index: number): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  let previousOrParentTNode = load(tView.data, index) as TNode;\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n  setPreviousOrParentTNode(previousOrParentTNode, true);\n\n  lView[index + HEADER_OFFSET][ACTIVE_INDEX] = 0;\n\n  // We need to execute init hooks here so ngOnInit hooks are called in top level views\n  // before they are called in embedded views (for backwards compatibility).\n  if (!getCheckNoChangesMode()) {\n    const hooksInitPhaseCompleted =\n        (lView[FLAGS] & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n    if (hooksInitPhaseCompleted) {\n      const preOrderCheckHooks = tView.preOrderCheckHooks;\n      if (preOrderCheckHooks !== null) {\n        executeCheckHooks(lView, preOrderCheckHooks, null);\n      }\n    } else {\n      const preOrderHooks = tView.preOrderHooks;\n      if (preOrderHooks !== null) {\n        executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, null);\n      }\n      incrementInitPhaseFlags(lView, InitPhaseState.OnInitHooksToBeRun);\n    }\n  }\n}\n\n/**\n * Marks the end of the LContainer.\n *\n * Marking the end of LContainer is the time when to child views get inserted or removed.\n *\n * @codeGenApi\n */\nexport function ÉµÉµcontainerRefreshEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  if (getIsParent()) {\n    setIsNotParent();\n  } else {\n    ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.View);\n    ngDevMode && assertHasParent(previousOrParentTNode);\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode, false);\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n\n  const lContainer: LContainer = getLView()[previousOrParentTNode.index];\n  const nextIndex = getLContainerActiveIndex(lContainer);\n\n  // remove extra views at the end of the container\n  while (nextIndex < lContainer.length - CONTAINER_HEADER_OFFSET) {\n    removeView(lContainer, nextIndex);\n  }\n}\n\nfunction containerInternal(\n    lView: LView, nodeIndex: number, tagName: string | null,\n    attrs: TAttributes | null): TContainerNode {\n  ngDevMode && assertEqual(\n                   getBindingIndex(), lView[TVIEW].bindingStartIndex,\n                   'container nodes should be created before any bindings');\n\n  const adjustedIndex = nodeIndex + HEADER_OFFSET;\n  ngDevMode && assertDataInRange(lView, nodeIndex + HEADER_OFFSET);\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const comment = lView[adjustedIndex] =\n      lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n  const tNode =\n      getOrCreateTNode(lView[TVIEW], lView[T_HOST], nodeIndex, TNodeType.Container, tagName, attrs);\n  const lContainer = lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode);\n\n  appendChild(comment, tNode, lView);\n  attachPatchData(comment, lView);\n\n  // Containers are added to the current view tree instead of their embedded views\n  // because views can be removed and re-inserted.\n  addToViewTree(lView, lContainer);\n\n  ngDevMode && assertNodeType(getPreviousOrParentTNode(), TNodeType.Container);\n  return tNode;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {HEADER_OFFSET, TVIEW} from '../interfaces/view';\nimport {getContextLView, getLView} from '../state';\nimport {load} from '../util/view_utils';\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(index: number, value: T): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  const adjustedIndex = index + HEADER_OFFSET;\n  if (adjustedIndex >= tView.data.length) {\n    tView.data[adjustedIndex] = null;\n    tView.blueprint[adjustedIndex] = null;\n  }\n  lView[adjustedIndex] = value;\n}\n\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n *\n * @codeGenApi\n */\nexport function ÉµÉµreference<T>(index: number) {\n  const contextLView = getContextLView();\n  return load<T>(contextLView, index);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectFlags, InjectionToken, resolveForwardRef} from '../../di';\nimport {ÉµÉµinject} from '../../di/injector_compatibility';\nimport {Type} from '../../interface/type';\nimport {getOrCreateInjectable, injectAttributeImpl} from '../di';\nimport {TDirectiveHostNode, TNodeType} from '../interfaces/node';\nimport {assertNodeOfPossibleTypes} from '../node_assert';\nimport {getLView, getPreviousOrParentTNode} from '../state';\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * ```ts\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static Éµdir = ÉµÉµdefineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(ÉµÉµdirectiveInject(DirectiveA))\n *   });\n * }\n * ```\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n *\n * @codeGenApi\n */\nexport function ÉµÉµdirectiveInject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function ÉµÉµdirectiveInject<T>(token: Type<T>| InjectionToken<T>, flags: InjectFlags): T;\nexport function ÉµÉµdirectiveInject<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  const lView = getLView();\n  // Fall back to inject() if view hasn't been created. This situation can happen in tests\n  // if inject utilities are used before bootstrapping.\n  if (lView == null) return ÉµÉµinject(token, flags);\n  const tNode = getPreviousOrParentTNode();\n  return getOrCreateInjectable<T>(\n      tNode as TDirectiveHostNode, lView, resolveForwardRef(token), flags);\n}\n\n/**\n * Facade for the attribute injection from DI.\n *\n * @codeGenApi\n */\nexport function ÉµÉµinjectAttribute(attrNameToInject: string): string|null {\n  return injectAttributeImpl(getPreviousOrParentTNode(), attrNameToInject);\n}\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport function ÉµÉµinvalidFactory(): never {\n  const msg =\n      ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';\n  throw new Error(msg);\n}\n","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\nimport {SafeValue} from '../../sanitization/bypass';\nimport {StyleSanitizeFn} from '../../sanitization/style_sanitizer';\nimport {throwErrorIfNoChangesMode} from '../errors';\nimport {setInputsForProperty} from '../instructions/shared';\nimport {AttributeMarker, TAttributes, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {RElement} from '../interfaces/renderer';\nimport {StylingMapArray, StylingMapArrayIndex, TStylingContext} from '../interfaces/styling';\nimport {isDirectiveHost} from '../interfaces/type_checks';\nimport {LView, RENDERER, TVIEW} from '../interfaces/view';\nimport {getActiveDirectiveId, getCheckNoChangesMode, getCurrentStyleSanitizer, getLView, getSelectedIndex, incrementBindingIndex, nextBindingIndex, resetCurrentStyleSanitizer, setCurrentStyleSanitizer, setElementExitFn} from '../state';\nimport {applyStylingMapDirectly, applyStylingValueDirectly, flushStyling, setClass, setStyle, updateClassViaContext, updateStyleViaContext} from '../styling/bindings';\nimport {activateStylingMapFeature} from '../styling/map_based_bindings';\nimport {attachStylingDebugObject} from '../styling/styling_debug';\nimport {NO_CHANGE} from '../tokens';\nimport {renderStringify} from '../util/misc_utils';\nimport {addItemToStylingMap, allocStylingMapArray, allocTStylingContext, allowDirectStyling, concatString, forceClassesAsString, forceStylesAsString, getInitialStylingValue, getStylingMapArray, getValue, hasClassInput, hasStyleInput, hasValueChanged, hasValueChangedUnwrapSafeValue, isHostStylingActive, isStylingContext, isStylingValueDefined, normalizeIntoStylingMap, patchConfig, selectClassBasedInputName, setValue, stylingMapToString} from '../util/styling_utils';\nimport {getNativeByTNode, getTNode} from '../util/view_utils';\n\n\n\n/**\n * --------\n *\n * This file contains the core logic for how styling instructions are processed in Angular.\n *\n * To learn more about the algorithm see `TStylingContext`.\n *\n * --------\n */\n\n/**\n * Sets the current style sanitizer function which will then be used\n * within all follow-up prop and map-based style binding instructions\n * for the given element.\n *\n * Note that once styling has been applied to the element (i.e. once\n * `advance(n)` is executed or the hostBindings/template function exits)\n * then the active `sanitizerFn` will be set to `null`. This means that\n * once styling is applied to another element then a another call to\n * `styleSanitizer` will need to be made.\n *\n * @param sanitizerFn The sanitization function that will be used to\n *       process style prop/value entries.\n *\n * @codeGenApi\n */\nexport function ÉµÉµstyleSanitizer(sanitizer: StyleSanitizeFn | null): void {\n  setCurrentStyleSanitizer(sanitizer);\n}\n\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *        Note that when a suffix is provided then the underlying sanitizer will\n *        be ignored.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\nexport function ÉµÉµstyleProp(\n    prop: string, value: string | number | SafeValue | null, suffix?: string | null): void {\n  stylePropInternal(getSelectedIndex(), prop, value, suffix);\n}\n\n/**\n * Internal function for applying a single style to an element.\n *\n * The reason why this function has been separated from `ÉµÉµstyleProp` is because\n * it is also called from `ÉµÉµstylePropInterpolate`.\n */\nexport function stylePropInternal(\n    elementIndex: number, prop: string, value: string | number | SafeValue | null,\n    suffix?: string | null | undefined): void {\n  // if a value is interpolated then it may render a `NO_CHANGE` value.\n  // in this case we do not need to do anything, but the binding index\n  // still needs to be incremented because all styling binding values\n  // are stored inside of the lView.\n  const bindingIndex = nextBindingIndex();\n  const lView = getLView();\n  const tNode = getTNode(elementIndex, lView);\n  const firstUpdatePass = lView[TVIEW].firstUpdatePass;\n\n  // we check for this in the instruction code so that the context can be notified\n  // about prop or map bindings so that the direct apply check can decide earlier\n  // if it allows for context resolution to be bypassed.\n  if (firstUpdatePass) {\n    patchConfig(tNode, TNodeFlags.hasStylePropBindings);\n    patchHostStylingFlag(tNode, isHostStyling(), false);\n  }\n\n  const updated = stylingProp(\n      tNode, firstUpdatePass, lView, bindingIndex, prop, resolveStylePropValue(value, suffix),\n      false);\n  if (ngDevMode) {\n    ngDevMode.styleProp++;\n    if (updated) {\n      ngDevMode.stylePropCacheMiss++;\n    }\n  }\n}\n\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\nexport function ÉµÉµclassProp(className: string, value: boolean | null): void {\n  // if a value is interpolated then it may render a `NO_CHANGE` value.\n  // in this case we do not need to do anything, but the binding index\n  // still needs to be incremented because all styling binding values\n  // are stored inside of the lView.\n  const bindingIndex = nextBindingIndex();\n  const lView = getLView();\n  const elementIndex = getSelectedIndex();\n  const tNode = getTNode(elementIndex, lView);\n  const firstUpdatePass = lView[TVIEW].firstUpdatePass;\n\n  // we check for this in the instruction code so that the context can be notified\n  // about prop or map bindings so that the direct apply check can decide earlier\n  // if it allows for context resolution to be bypassed.\n  if (firstUpdatePass) {\n    patchConfig(tNode, TNodeFlags.hasClassPropBindings);\n    patchHostStylingFlag(tNode, isHostStyling(), true);\n  }\n\n  const updated = stylingProp(tNode, firstUpdatePass, lView, bindingIndex, className, value, true);\n  if (ngDevMode) {\n    ngDevMode.classProp++;\n    if (updated) {\n      ngDevMode.classPropCacheMiss++;\n    }\n  }\n}\n\n/**\n * Shared function used to update a prop-based styling binding for an element.\n *\n * Depending on the state of the `tNode.styles` styles context, the style/prop\n * value may be applied directly to the element instead of being processed\n * through the context. The reason why this occurs is for performance and fully\n * depends on the state of the context (i.e. whether or not there are duplicate\n * bindings or whether or not there are map-based bindings and property bindings\n * present together).\n */\nfunction stylingProp(\n    tNode: TNode, firstUpdatePass: boolean, lView: LView, bindingIndex: number, prop: string,\n    value: boolean | number | SafeValue | string | null | undefined | NO_CHANGE,\n    isClassBased: boolean): boolean {\n  let updated = false;\n\n  const native = getNativeByTNode(tNode, lView) as RElement;\n  const context = isClassBased ? getClassesContext(tNode) : getStylesContext(tNode);\n  const sanitizer = isClassBased ? null : getCurrentStyleSanitizer();\n\n  // [style.prop] and [class.name] bindings do not use `bind()` and will\n  // therefore manage accessing and updating the new value in the lView directly.\n  // For this reason, the checkNoChanges situation must also be handled here\n  // as well.\n  if (ngDevMode && getCheckNoChangesMode()) {\n    const oldValue = getValue(lView, bindingIndex);\n    if (hasValueChangedUnwrapSafeValue(oldValue, value)) {\n      throwErrorIfNoChangesMode(false, oldValue, value);\n    }\n  }\n\n  // Direct Apply Case: bypass context resolution and apply the\n  // style/class value directly to the element\n  if (allowDirectStyling(tNode, isClassBased, firstUpdatePass)) {\n    const sanitizerToUse = isClassBased ? null : sanitizer;\n    const renderer = getRenderer(tNode, lView);\n    updated = applyStylingValueDirectly(\n        renderer, context, tNode, native, lView, bindingIndex, prop, value, isClassBased,\n        sanitizerToUse);\n\n    if (sanitizerToUse) {\n      // it's important we remove the current style sanitizer once the\n      // element exits, otherwise it will be used by the next styling\n      // instructions for the next element.\n      setElementExitFn(stylingApply);\n    }\n  } else {\n    // Context Resolution (or first update) Case: save the value\n    // and defer to the context to flush and apply the style/class binding\n    // value to the element.\n    const directiveIndex = getActiveDirectiveId();\n    if (isClassBased) {\n      updated = updateClassViaContext(\n          context, tNode, lView, native, directiveIndex, prop, bindingIndex,\n          value as string | boolean | null, false, firstUpdatePass);\n    } else {\n      updated = updateStyleViaContext(\n          context, tNode, lView, native, directiveIndex, prop, bindingIndex,\n          value as string | SafeValue | null, sanitizer, false, firstUpdatePass);\n    }\n\n    setElementExitFn(stylingApply);\n  }\n\n  return updated;\n}\n\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\nexport function ÉµÉµstyleMap(styles: {[styleName: string]: any} | NO_CHANGE | null): void {\n  const index = getSelectedIndex();\n  const lView = getLView();\n  const tNode = getTNode(index, lView);\n  const firstUpdatePass = lView[TVIEW].firstUpdatePass;\n  const context = getStylesContext(tNode);\n  const hasDirectiveInput = hasStyleInput(tNode);\n\n  // if a value is interpolated then it may render a `NO_CHANGE` value.\n  // in this case we do not need to do anything, but the binding index\n  // still needs to be incremented because all styling binding values\n  // are stored inside of the lView.\n  const bindingIndex = incrementBindingIndex(2);\n  const hostBindingsMode = isHostStyling();\n\n  // inputs are only evaluated from a template binding into a directive, therefore,\n  // there should not be a situation where a directive host bindings function\n  // evaluates the inputs (this should only happen in the template function)\n  if (!hostBindingsMode && hasDirectiveInput && styles !== NO_CHANGE) {\n    updateDirectiveInputValue(context, lView, tNode, bindingIndex, styles, false, firstUpdatePass);\n    styles = NO_CHANGE;\n  }\n\n  // we check for this in the instruction code so that the context can be notified\n  // about prop or map bindings so that the direct apply check can decide earlier\n  // if it allows for context resolution to be bypassed.\n  if (firstUpdatePass) {\n    patchConfig(tNode, TNodeFlags.hasStyleMapBindings);\n    patchHostStylingFlag(tNode, isHostStyling(), false);\n  }\n\n  stylingMap(\n      context, tNode, firstUpdatePass, lView, bindingIndex, styles, false, hasDirectiveInput);\n}\n\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\nexport function ÉµÉµclassMap(classes: {[className: string]: any} | NO_CHANGE | string | null): void {\n  classMapInternal(getSelectedIndex(), classes);\n}\n\n/**\n * Internal function for applying a class string or key/value map of classes to an element.\n *\n * The reason why this function has been separated from `ÉµÉµclassMap` is because\n * it is also called from `ÉµÉµclassMapInterpolate`.\n */\nexport function classMapInternal(\n    elementIndex: number, classes: {[className: string]: any} | NO_CHANGE | string | null): void {\n  const lView = getLView();\n  const tNode = getTNode(elementIndex, lView);\n  const firstUpdatePass = lView[TVIEW].firstUpdatePass;\n  const context = getClassesContext(tNode);\n  const hasDirectiveInput = hasClassInput(tNode);\n\n  // if a value is interpolated then it may render a `NO_CHANGE` value.\n  // in this case we do not need to do anything, but the binding index\n  // still needs to be incremented because all styling binding values\n  // are stored inside of the lView.\n  const bindingIndex = incrementBindingIndex(2);\n  const hostBindingsMode = isHostStyling();\n\n  // inputs are only evaluated from a template binding into a directive, therefore,\n  // there should not be a situation where a directive host bindings function\n  // evaluates the inputs (this should only happen in the template function)\n  if (!hostBindingsMode && hasDirectiveInput && classes !== NO_CHANGE) {\n    updateDirectiveInputValue(context, lView, tNode, bindingIndex, classes, true, firstUpdatePass);\n    classes = NO_CHANGE;\n  }\n\n  // we check for this in the instruction code so that the context can be notified\n  // about prop or map bindings so that the direct apply check can decide earlier\n  // if it allows for context resolution to be bypassed.\n  if (firstUpdatePass) {\n    patchConfig(tNode, TNodeFlags.hasClassMapBindings);\n    patchHostStylingFlag(tNode, isHostStyling(), true);\n  }\n\n  stylingMap(\n      context, tNode, firstUpdatePass, lView, bindingIndex, classes, true, hasDirectiveInput);\n}\n\n/**\n * Shared function used to update a map-based styling binding for an element.\n *\n * When this function is called it will activate support for `[style]` and\n * `[class]` bindings in Angular.\n */\nfunction stylingMap(\n    context: TStylingContext, tNode: TNode, firstUpdatePass: boolean, lView: LView,\n    bindingIndex: number, value: {[key: string]: any} | string | null, isClassBased: boolean,\n    hasDirectiveInput: boolean): void {\n  const directiveIndex = getActiveDirectiveId();\n  const native = getNativeByTNode(tNode, lView) as RElement;\n  const oldValue = getValue(lView, bindingIndex);\n  const sanitizer = getCurrentStyleSanitizer();\n  const valueHasChanged = hasValueChanged(oldValue, value);\n\n  // [style] and [class] bindings do not use `bind()` and will therefore\n  // manage accessing and updating the new value in the lView directly.\n  // For this reason, the checkNoChanges situation must also be handled here\n  // as well.\n  if (ngDevMode && valueHasChanged && getCheckNoChangesMode()) {\n    throwErrorIfNoChangesMode(false, oldValue, value);\n  }\n\n  // Direct Apply Case: bypass context resolution and apply the\n  // style/class map values directly to the element\n  if (allowDirectStyling(tNode, isClassBased, firstUpdatePass)) {\n    const sanitizerToUse = isClassBased ? null : sanitizer;\n    const renderer = getRenderer(tNode, lView);\n    applyStylingMapDirectly(\n        renderer, context, tNode, native, lView, bindingIndex, value, isClassBased, sanitizerToUse,\n        valueHasChanged, hasDirectiveInput);\n    if (sanitizerToUse) {\n      // it's important we remove the current style sanitizer once the\n      // element exits, otherwise it will be used by the next styling\n      // instructions for the next element.\n      setElementExitFn(stylingApply);\n    }\n  } else {\n    const stylingMapArr =\n        value === NO_CHANGE ? NO_CHANGE : normalizeIntoStylingMap(oldValue, value, !isClassBased);\n\n    activateStylingMapFeature();\n\n    // Context Resolution (or first update) Case: save the map value\n    // and defer to the context to flush and apply the style/class binding\n    // value to the element.\n    if (isClassBased) {\n      updateClassViaContext(\n          context, tNode, lView, native, directiveIndex, null, bindingIndex, stylingMapArr,\n          valueHasChanged, firstUpdatePass);\n    } else {\n      updateStyleViaContext(\n          context, tNode, lView, native, directiveIndex, null, bindingIndex, stylingMapArr,\n          sanitizer, valueHasChanged, firstUpdatePass);\n    }\n\n    setElementExitFn(stylingApply);\n  }\n\n  if (ngDevMode) {\n    isClassBased ? ngDevMode.classMap : ngDevMode.styleMap++;\n    if (valueHasChanged) {\n      isClassBased ? ngDevMode.classMapCacheMiss : ngDevMode.styleMapCacheMiss++;\n    }\n  }\n}\n\n/**\n * Writes a value to a directive's `style` or `class` input binding (if it has changed).\n *\n * If a directive has a `@Input` binding that is set on `style` or `class` then that value\n * will take priority over the underlying style/class styling bindings. This value will\n * be updated for the binding each time during change detection.\n *\n * When this occurs this function will attempt to write the value to the input binding\n * depending on the following situations:\n *\n * - If `oldValue !== newValue`\n * - If `newValue` is `null` (but this is skipped if it is during the first update pass)\n */\nfunction updateDirectiveInputValue(\n    context: TStylingContext, lView: LView, tNode: TNode, bindingIndex: number, newValue: any,\n    isClassBased: boolean, firstUpdatePass: boolean): void {\n  const oldValue = getValue(lView, bindingIndex);\n  if (hasValueChanged(oldValue, newValue)) {\n    // even if the value has changed we may not want to emit it to the\n    // directive input(s) in the event that it is falsy during the\n    // first update pass.\n    if (isStylingValueDefined(newValue) || !firstUpdatePass) {\n      const inputName: string = isClassBased ? selectClassBasedInputName(tNode.inputs !) : 'style';\n      const inputs = tNode.inputs ![inputName] !;\n      const initialValue = getInitialStylingValue(context);\n      const value = normalizeStylingDirectiveInputValue(initialValue, newValue, isClassBased);\n      setInputsForProperty(lView, inputs, inputName, value);\n      setElementExitFn(stylingApply);\n    }\n    setValue(lView, bindingIndex, newValue);\n  }\n}\n\n/**\n * Returns the appropriate directive input value for `style` or `class`.\n *\n * Earlier versions of Angular expect a binding value to be passed into directive code\n * exactly as it is unless there is a static value present (in which case both values\n * will be stringified and concatenated).\n */\nfunction normalizeStylingDirectiveInputValue(\n    initialValue: string, bindingValue: string | {[key: string]: any} | null,\n    isClassBased: boolean) {\n  let value = bindingValue;\n\n  // we only concat values if there is an initial value, otherwise we return the value as is.\n  // Note that this is to satisfy backwards-compatibility in Angular.\n  if (initialValue.length) {\n    if (isClassBased) {\n      value = concatString(initialValue, forceClassesAsString(bindingValue));\n    } else {\n      value = concatString(initialValue, forceStylesAsString(bindingValue, true), ';');\n    }\n  }\n  return value;\n}\n\n/**\n * Flushes all styling code to the element.\n *\n * This function is designed to be scheduled from any of the four styling instructions\n * in this file. When called it will flush all style and class bindings to the element\n * via the context resolution algorithm.\n */\nfunction stylingApply(): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const elementIndex = getSelectedIndex();\n  const tNode = getTNode(elementIndex, lView);\n  const native = getNativeByTNode(tNode, lView) as RElement;\n  const directiveIndex = getActiveDirectiveId();\n  const renderer = getRenderer(tNode, lView);\n  const sanitizer = getCurrentStyleSanitizer();\n  const classesContext = isStylingContext(tNode.classes) ? tNode.classes as TStylingContext : null;\n  const stylesContext = isStylingContext(tNode.styles) ? tNode.styles as TStylingContext : null;\n  flushStyling(\n      renderer, lView, tNode, classesContext, stylesContext, native, directiveIndex, sanitizer,\n      tView.firstUpdatePass);\n  resetCurrentStyleSanitizer();\n}\n\nfunction getRenderer(tNode: TNode, lView: LView) {\n  return tNode.type === TNodeType.Element ? lView[RENDERER] : null;\n}\n\n/**\n * Searches and assigns provided all static style/class entries (found in the `attrs` value)\n * and registers them in their respective styling contexts.\n */\nexport function registerInitialStylingOnTNode(\n    tNode: TNode, attrs: TAttributes, startIndex: number): boolean {\n  let hasAdditionalInitialStyling = false;\n  let styles = getStylingMapArray(tNode.styles);\n  let classes = getStylingMapArray(tNode.classes);\n  let mode = -1;\n  for (let i = startIndex; i < attrs.length; i++) {\n    const attr = attrs[i] as string;\n    if (typeof attr == 'number') {\n      mode = attr;\n    } else if (mode == AttributeMarker.Classes) {\n      classes = classes || allocStylingMapArray(null);\n      addItemToStylingMap(classes, attr, true);\n      hasAdditionalInitialStyling = true;\n    } else if (mode == AttributeMarker.Styles) {\n      const value = attrs[++i] as string | null;\n      styles = styles || allocStylingMapArray(null);\n      addItemToStylingMap(styles, attr, value);\n      hasAdditionalInitialStyling = true;\n    }\n  }\n\n  if (classes && classes.length > StylingMapArrayIndex.ValuesStartPosition) {\n    if (!tNode.classes) {\n      tNode.classes = classes;\n    }\n    updateRawValueOnContext(tNode.classes, stylingMapToString(classes, true));\n  }\n\n  if (styles && styles.length > StylingMapArrayIndex.ValuesStartPosition) {\n    if (!tNode.styles) {\n      tNode.styles = styles;\n    }\n    updateRawValueOnContext(tNode.styles, stylingMapToString(styles, false));\n  }\n\n  if (hasAdditionalInitialStyling) {\n    tNode.flags |= TNodeFlags.hasInitialStyling;\n  }\n\n  return hasAdditionalInitialStyling;\n}\n\nfunction updateRawValueOnContext(context: TStylingContext | StylingMapArray, value: string) {\n  const stylingMapArr = getStylingMapArray(context) !;\n  stylingMapArr[StylingMapArrayIndex.RawValuePosition] = value;\n}\n\nfunction getStylesContext(tNode: TNode): TStylingContext {\n  return getContext(tNode, false);\n}\n\nfunction getClassesContext(tNode: TNode): TStylingContext {\n  return getContext(tNode, true);\n}\n\n/**\n * Returns/instantiates a styling context from/to a `tNode` instance.\n */\nfunction getContext(tNode: TNode, isClassBased: boolean): TStylingContext {\n  let context = isClassBased ? tNode.classes : tNode.styles;\n  if (!isStylingContext(context)) {\n    const hasDirectives = isDirectiveHost(tNode);\n    context = allocTStylingContext(context as StylingMapArray | null, hasDirectives);\n    if (ngDevMode) {\n      attachStylingDebugObject(context as TStylingContext, tNode, isClassBased);\n    }\n\n    if (isClassBased) {\n      tNode.classes = context;\n    } else {\n      tNode.styles = context;\n    }\n  }\n  return context as TStylingContext;\n}\n\nfunction resolveStylePropValue(\n    value: string | number | SafeValue | null | NO_CHANGE,\n    suffix: string | null | undefined): string|SafeValue|null|undefined|NO_CHANGE {\n  if (value === NO_CHANGE) return value;\n\n  let resolvedValue: string|null = null;\n  if (isStylingValueDefined(value)) {\n    if (suffix) {\n      // when a suffix is applied then it will bypass\n      // sanitization entirely (b/c a new string is created)\n      resolvedValue = renderStringify(value) + suffix;\n    } else {\n      // sanitization happens by dealing with a string value\n      // this means that the string value will be passed through\n      // into the style rendering later (which is where the value\n      // will be sanitized before it is applied)\n      resolvedValue = value as any as string;\n    }\n  }\n  return resolvedValue;\n}\n\n/**\n * Whether or not the style/class binding being applied was executed within a host bindings\n * function.\n */\nfunction isHostStyling(): boolean {\n  return isHostStylingActive(getActiveDirectiveId());\n}\n\nfunction patchHostStylingFlag(tNode: TNode, hostBindingsMode: boolean, isClassBased: boolean) {\n  const flag = hostBindingsMode ?\n      isClassBased ? TNodeFlags.hasHostClassBindings : TNodeFlags.hasHostStyleBindings :\n      isClassBased ? TNodeFlags.hasTemplateClassBindings : TNodeFlags.hasTemplateStyleBindings;\n  patchConfig(tNode, flag);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDataInRange, assertDefined, assertEqual} from '../../util/assert';\nimport {assertHasParent} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {registerPostOrderHooks} from '../hooks';\nimport {TAttributes, TElementNode, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {RElement} from '../interfaces/renderer';\nimport {StylingMapArray, TStylingContext} from '../interfaces/styling';\nimport {isContentQueryHost, isDirectiveHost} from '../interfaces/type_checks';\nimport {HEADER_OFFSET, LView, RENDERER, TVIEW, TView, T_HOST} from '../interfaces/view';\nimport {assertNodeType} from '../node_assert';\nimport {appendChild} from '../node_manipulation';\nimport {decreaseElementDepthCount, getBindingIndex, getElementDepthCount, getIsParent, getLView, getNamespace, getPreviousOrParentTNode, getSelectedIndex, increaseElementDepthCount, setIsNotParent, setPreviousOrParentTNode} from '../state';\nimport {setUpAttributes} from '../util/attrs_utils';\nimport {getInitialStylingValue, hasClassInput, hasStyleInput, selectClassBasedInputName} from '../util/styling_utils';\nimport {getConstant, getNativeByTNode, getTNode} from '../util/view_utils';\n\nimport {createDirectivesInstances, elementCreate, executeContentQueries, getOrCreateTNode, matchingSchemas, renderInitialStyling, resolveDirectives, saveResolvedLocalsInData, setInputsForProperty} from './shared';\nimport {registerInitialStylingOnTNode} from './styling';\n\nfunction elementStartFirstCreatePass(\n    index: number, tView: TView, lView: LView, native: RElement, name: string,\n    attrsIndex?: number | null, localRefsIndex?: number): TElementNode {\n  ngDevMode && ngDevMode.firstCreatePass++;\n\n  const tViewConsts = tView.consts;\n  const attrs = getConstant<TAttributes>(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, lView[T_HOST], index, TNodeType.Element, name, attrs);\n\n  if (attrs !== null) {\n    registerInitialStylingOnTNode(tNode, attrs, 0);\n  }\n\n  const hasDirectives =\n      resolveDirectives(tView, lView, tNode, getConstant<string[]>(tViewConsts, localRefsIndex));\n  ngDevMode && validateElement(lView, native, tNode, hasDirectives);\n\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n\n  return tNode;\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\nexport function ÉµÉµelementStart(\n    index: number, name: string, attrsIndex?: number | null, localRefsIndex?: number): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const adjustedIndex = HEADER_OFFSET + index;\n\n  ngDevMode && assertEqual(\n                   getBindingIndex(), tView.bindingStartIndex,\n                   'elements should be created before any bindings');\n  ngDevMode && ngDevMode.rendererCreateElement++;\n  ngDevMode && assertDataInRange(lView, adjustedIndex);\n\n  const renderer = lView[RENDERER];\n  const native = lView[adjustedIndex] = elementCreate(name, renderer, getNamespace());\n\n  const tNode = tView.firstCreatePass ?\n      elementStartFirstCreatePass(index, tView, lView, native, name, attrsIndex, localRefsIndex) :\n      tView.data[adjustedIndex] as TElementNode;\n  setPreviousOrParentTNode(tNode, true);\n\n  const attrs = tNode.attrs;\n  if (attrs != null) {\n    setUpAttributes(renderer, native, attrs);\n  }\n  if ((tNode.flags & TNodeFlags.hasInitialStyling) === TNodeFlags.hasInitialStyling) {\n    renderInitialStyling(renderer, native, tNode, false);\n  }\n\n  appendChild(native, tNode, lView);\n\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (getElementDepthCount() === 0) {\n    attachPatchData(native, lView);\n  }\n  increaseElementDepthCount();\n\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n}\n\n/**\n * Mark the end of the element.\n *\n * @codeGenApi\n */\nexport function ÉµÉµelementEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  ngDevMode && assertDefined(previousOrParentTNode, 'No parent node to close.');\n  if (getIsParent()) {\n    setIsNotParent();\n  } else {\n    ngDevMode && assertHasParent(getPreviousOrParentTNode());\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode, false);\n  }\n\n  const tNode = previousOrParentTNode;\n  ngDevMode && assertNodeType(tNode, TNodeType.Element);\n\n  const lView = getLView();\n  const tView = lView[TVIEW];\n\n  decreaseElementDepthCount();\n\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, previousOrParentTNode);\n    if (isContentQueryHost(previousOrParentTNode)) {\n      tView.queries !.elementEnd(previousOrParentTNode);\n    }\n  }\n\n  if (hasClassInput(tNode)) {\n    const inputName: string = selectClassBasedInputName(tNode.inputs !);\n    setDirectiveStylingInput(tNode.classes, lView, tNode.inputs ![inputName], inputName);\n  }\n\n  if (hasStyleInput(tNode)) {\n    setDirectiveStylingInput(tNode.styles, lView, tNode.inputs !['style'], 'style');\n  }\n}\n\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n *\n * @codeGenApi\n */\nexport function ÉµÉµelement(\n    index: number, name: string, attrsIndex?: number | null, localRefsIndex?: number): void {\n  ÉµÉµelementStart(index, name, attrsIndex, localRefsIndex);\n  ÉµÉµelementEnd();\n}\n\n/**\n * Assign static attribute values to a host element.\n *\n * This instruction will assign static attribute values as well as class and style\n * values to an element within the host bindings function. Since attribute values\n * can consist of different types of values, the `attrs` array must include the values in\n * the following format:\n *\n * attrs = [\n *   // static attributes (like `title`, `name`, `id`...)\n *   attr1, value1, attr2, value,\n *\n *   // a single namespace value (like `x:id`)\n *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n *\n *   // another single namespace value (like `x:name`)\n *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n *\n *   // a series of CSS classes that will be applied to the element (no spaces)\n *   CLASSES_MARKER, class1, class2, class3,\n *\n *   // a series of CSS styles (property + value) that will be applied to the element\n *   STYLES_MARKER, prop1, value1, prop2, value2\n * ]\n *\n * All non-class and non-style attributes must be defined at the start of the list\n * first before all class and style values are set. When there is a change in value\n * type (like when classes and styles are introduced) a marker must be used to separate\n * the entries. The marker values themselves are set via entries found in the\n * [AttributeMarker] enum.\n *\n * NOTE: This instruction is meant to used from `hostBindings` function only.\n *\n * @param directive A directive instance the styling is associated with.\n * @param attrs An array of static values (attributes, classes and styles) with the correct marker\n * values.\n *\n * @codeGenApi\n */\nexport function ÉµÉµelementHostAttrs(attrs: TAttributes) {\n  const hostElementIndex = getSelectedIndex();\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const tNode = getTNode(hostElementIndex, lView);\n\n  // non-element nodes (e.g. `<ng-container>`) are not rendered as actual\n  // element nodes and adding styles/classes on to them will cause runtime\n  // errors...\n  if (tNode.type === TNodeType.Element) {\n    const native = getNativeByTNode(tNode, lView) as RElement;\n    const lastAttrIndex = setUpAttributes(lView[RENDERER], native, attrs);\n    if (tView.firstCreatePass) {\n      const stylingNeedsToBeRendered = registerInitialStylingOnTNode(tNode, attrs, lastAttrIndex);\n\n      // this is only called during the first template pass in the\n      // event that this current directive assigned initial style/class\n      // host attribute values to the element. Because initial styling\n      // values are applied before directives are first rendered (within\n      // `createElement`) this means that initial styling for any directives\n      // still needs to be applied. Note that this will only happen during\n      // the first template pass and not each time a directive applies its\n      // attribute values to the element.\n      if (stylingNeedsToBeRendered) {\n        const renderer = lView[RENDERER];\n        renderInitialStyling(renderer, native, tNode, true);\n      }\n    }\n  }\n}\n\nfunction setDirectiveStylingInput(\n    context: TStylingContext | StylingMapArray | null, lView: LView,\n    stylingInputs: (string | number)[], propName: string) {\n  // older versions of Angular treat the input as `null` in the\n  // event that the value does not exist at all. For this reason\n  // we can't have a styling value be an empty string.\n  const value = (context && getInitialStylingValue(context)) || null;\n\n  // Ivy does an extra `[class]` write with a falsy value since the value\n  // is applied during creation mode. This is a deviation from VE and should\n  // be (Jira Issue = FW-1467).\n  setInputsForProperty(lView, stylingInputs, propName, value);\n}\n\nfunction validateElement(\n    hostView: LView, element: RElement, tNode: TNode, hasDirectives: boolean): void {\n  const schemas = hostView[TVIEW].schemas;\n\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return;\n\n  const tagName = tNode.tagName;\n\n  // If the element matches any directive, it's considered as valid.\n  if (!hasDirectives && tagName !== null) {\n    // The element is unknown if it's an instance of HTMLUnknownElement or it isn't registered\n    // as a custom element. Note that unknown elements with a dash in their name won't be instances\n    // of HTMLUnknownElement in browsers that support web components.\n    const isUnknown =\n        (typeof HTMLUnknownElement === 'function' && element instanceof HTMLUnknownElement) ||\n        (typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 &&\n         !customElements.get(tagName));\n\n    if (isUnknown && !matchingSchemas(hostView, tagName)) {\n      let errorMessage = `'${tagName}' is not a known element:\\n`;\n      errorMessage +=\n          `1. If '${tagName}' is an Angular component, then verify that it is part of this module.\\n`;\n      if (tagName && tagName.indexOf('-') > -1) {\n        errorMessage +=\n            `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;\n      } else {\n        errorMessage +=\n            `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n      }\n      throw new Error(errorMessage);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertDataInRange, assertEqual} from '../../util/assert';\nimport {assertHasParent} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {registerPostOrderHooks} from '../hooks';\nimport {TAttributes, TElementContainerNode, TNodeType} from '../interfaces/node';\nimport {isContentQueryHost, isDirectiveHost} from '../interfaces/type_checks';\nimport {HEADER_OFFSET, LView, RENDERER, TVIEW, TView, T_HOST} from '../interfaces/view';\nimport {assertNodeType} from '../node_assert';\nimport {appendChild} from '../node_manipulation';\nimport {getBindingIndex, getIsParent, getLView, getPreviousOrParentTNode, setIsNotParent, setPreviousOrParentTNode} from '../state';\nimport {getConstant} from '../util/view_utils';\n\nimport {createDirectivesInstances, executeContentQueries, getOrCreateTNode, resolveDirectives, saveResolvedLocalsInData} from './shared';\nimport {registerInitialStylingOnTNode} from './styling';\n\nfunction elementContainerStartFirstCreatePass(\n    index: number, tView: TView, lView: LView, attrsIndex?: number | null,\n    localRefsIndex?: number): TElementContainerNode {\n  ngDevMode && ngDevMode.firstCreatePass++;\n\n  const tViewConsts = tView.consts;\n  const attrs = getConstant<TAttributes>(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(\n      tView, lView[T_HOST], index, TNodeType.ElementContainer, 'ng-container', attrs);\n\n  // While ng-container doesn't necessarily support styling, we use the style context to identify\n  // and execute directives on the ng-container.\n  if (attrs !== null) {\n    registerInitialStylingOnTNode(tNode, attrs, 0);\n  }\n\n  const localRefs = getConstant<string[]>(tViewConsts, localRefsIndex);\n  resolveDirectives(tView, lView, tNode, localRefs);\n\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n\n  return tNode;\n}\n\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n *\n * @codeGenApi\n */\nexport function ÉµÉµelementContainerStart(\n    index: number, attrsIndex?: number | null, localRefsIndex?: number): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  ngDevMode && assertDataInRange(lView, adjustedIndex);\n  ngDevMode && assertEqual(\n                   getBindingIndex(), tView.bindingStartIndex,\n                   'element containers should be created before any bindings');\n\n  const tNode = tView.firstCreatePass ?\n      elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) :\n      tView.data[adjustedIndex] as TElementContainerNode;\n  setPreviousOrParentTNode(tNode, true);\n\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const native = lView[adjustedIndex] =\n      lView[RENDERER].createComment(ngDevMode ? 'ng-container' : '');\n  appendChild(native, tNode, lView);\n  attachPatchData(native, lView);\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n}\n\n/**\n * Mark the end of the <ng-container>.\n *\n * @codeGenApi\n */\nexport function ÉµÉµelementContainerEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  if (getIsParent()) {\n    setIsNotParent();\n  } else {\n    ngDevMode && assertHasParent(previousOrParentTNode);\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode, false);\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.ElementContainer);\n\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, previousOrParentTNode);\n    if (isContentQueryHost(previousOrParentTNode)) {\n      tView.queries !.elementEnd(previousOrParentTNode);\n    }\n  }\n}\n\n/**\n * Creates an empty logical container using {@link elementContainerStart}\n * and {@link elementContainerEnd}\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n *\n * @codeGenApi\n */\nexport function ÉµÉµelementContainer(\n    index: number, attrsIndex?: number | null, localRefsIndex?: number): void {\n  ÉµÉµelementContainerStart(index, attrsIndex, localRefsIndex);\n  ÉµÉµelementContainerEnd();\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual} from '../../util/assert';\nimport {assertLContainerOrUndefined} from '../assert';\nimport {ACTIVE_INDEX, ActiveIndexFlag, CONTAINER_HEADER_OFFSET, LContainer} from '../interfaces/container';\nimport {RenderFlags} from '../interfaces/definition';\nimport {TContainerNode, TNodeType} from '../interfaces/node';\nimport {CONTEXT, LView, LViewFlags, PARENT, TVIEW, TView, TViewType, T_HOST} from '../interfaces/view';\nimport {assertNodeType} from '../node_assert';\nimport {insertView, removeView} from '../node_manipulation';\nimport {enterView, getIsParent, getLView, getPreviousOrParentTNode, leaveViewProcessExit, setIsParent, setPreviousOrParentTNode} from '../state';\nimport {getLContainerActiveIndex, isCreationMode} from '../util/view_utils';\n\nimport {assignTViewNodeToLView, createLView, createTView, refreshView, renderView} from './shared';\n\n\n\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n *\n * @codeGenApi\n */\nexport function ÉµÉµembeddedViewStart(viewBlockId: number, decls: number, vars: number): RenderFlags {\n  const lView = getLView();\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  // The previous node can be a view node if we are processing an inline for loop\n  const containerTNode = previousOrParentTNode.type === TNodeType.View ?\n      previousOrParentTNode.parent ! :\n      previousOrParentTNode;\n  const lContainer = lView[containerTNode.index] as LContainer;\n\n  ngDevMode && assertNodeType(containerTNode, TNodeType.Container);\n  let viewToRender = scanForView(lContainer, getLContainerActiveIndex(lContainer), viewBlockId);\n\n  if (viewToRender) {\n    setIsParent();\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  } else {\n    // When we create a new LView, we always reset the state of the instructions.\n    viewToRender = createLView(\n        lView, getOrCreateEmbeddedTView(viewBlockId, decls, vars, containerTNode as TContainerNode),\n        null, LViewFlags.CheckAlways, null, null);\n\n    const tParentNode = getIsParent() ? previousOrParentTNode :\n                                        previousOrParentTNode && previousOrParentTNode.parent;\n    assignTViewNodeToLView(viewToRender[TVIEW], tParentNode, viewBlockId, viewToRender);\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  }\n  if (lContainer) {\n    if (isCreationMode(viewToRender)) {\n      // it is a new view, insert it into collection of views for a given container\n      insertView(viewToRender, lContainer, getLContainerActiveIndex(lContainer));\n    }\n    lContainer[ACTIVE_INDEX] += ActiveIndexFlag.INCREMENT;\n  }\n  return isCreationMode(viewToRender) ? RenderFlags.Create | RenderFlags.Update :\n                                        RenderFlags.Update;\n}\n\n/**\n * Initialize the TView (e.g. static data) for the active embedded view.\n *\n * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's\n * static data for a particular node would overwrite the static data for a node in the view above\n * it with the same index (since it's in the same template).\n *\n * @param viewIndex The index of the TView in TNode.tViews\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param vars The number of bindings and pure function bindings in this template\n * @param container The parent container in which to look for the view's static data\n * @returns TView\n */\nfunction getOrCreateEmbeddedTView(\n    viewIndex: number, decls: number, vars: number, parent: TContainerNode): TView {\n  const tView = getLView()[TVIEW];\n  ngDevMode && assertNodeType(parent, TNodeType.Container);\n  const containerTViews = parent.tViews as TView[];\n  ngDevMode && assertDefined(containerTViews, 'TView expected');\n  ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');\n  if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {\n    containerTViews[viewIndex] = createTView(\n        TViewType.Embedded, viewIndex, null, decls, vars, tView.directiveRegistry,\n        tView.pipeRegistry, null, null, tView.consts);\n  }\n  return containerTViews[viewIndex];\n}\n\n\n/**\n * Looks for a view with a given view block id inside a provided LContainer.\n * Removes views that need to be deleted in the process.\n *\n * @param lContainer to search for views\n * @param startIdx starting index in the views array to search from\n * @param viewBlockId exact view block id to look for\n */\nfunction scanForView(lContainer: LContainer, startIdx: number, viewBlockId: number): LView|null {\n  for (let i = startIdx + CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const viewAtPositionId = lContainer[i][TVIEW].id;\n    if (viewAtPositionId === viewBlockId) {\n      return lContainer[i];\n    } else if (viewAtPositionId < viewBlockId) {\n      // found a view that should not be at this position - remove\n      removeView(lContainer, i - CONTAINER_HEADER_OFFSET);\n    } else {\n      // found a view with id greater than the one we are searching for\n      // which means that required view doesn't exist and can't be found at\n      // later positions in the views array - stop the searchdef.cont here\n      break;\n    }\n  }\n  return null;\n}\n\n/**\n * Marks the end of an embedded view.\n *\n * @codeGenApi\n */\nexport function ÉµÉµembeddedViewEnd(): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const viewHost = lView[T_HOST];\n  const context = lView[CONTEXT];\n\n  if (isCreationMode(lView)) {\n    renderView(lView, tView, context);  // creation mode pass\n  }\n  refreshView(lView, tView, tView.template, context);  // update mode pass\n\n  const lContainer = lView[PARENT] as LContainer;\n  ngDevMode && assertLContainerOrUndefined(lContainer);\n  leaveViewProcessExit();\n  setPreviousOrParentTNode(viewHost !, false);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {OpaqueViewState} from '../interfaces/view';\nimport {getLView} from '../state';\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @codeGenApi\n */\nexport function ÉµÉµgetCurrentView(): OpaqueViewState {\n  return getLView() as any as OpaqueViewState;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nexport function isPromise(obj: any): obj is Promise<any> {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n\n/**\n * Determine if the argument is an Observable\n */\nexport function isObservable(obj: any | Observable<any>): obj is Observable<any> {\n  // TODO: use isObservable once we update pass rxjs 6.1\n  // https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md#610-2018-05-03\n  return !!obj && typeof obj.subscribe === 'function';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {assertDataInRange} from '../../util/assert';\nimport {isObservable} from '../../util/lang';\nimport {EMPTY_OBJ} from '../empty';\nimport {PropertyAliasValue, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {GlobalTargetResolver, RElement, Renderer3, isProceduralRenderer} from '../interfaces/renderer';\nimport {isDirectiveHost} from '../interfaces/type_checks';\nimport {CLEANUP, FLAGS, LView, LViewFlags, RENDERER, TVIEW} from '../interfaces/view';\nimport {assertNodeOfPossibleTypes} from '../node_assert';\nimport {getLView, getPreviousOrParentTNode} from '../state';\nimport {getComponentLViewByIndex, getNativeByTNode, unwrapRNode} from '../util/view_utils';\n\nimport {getCleanup, handleError, loadComponentRenderer, markViewDirty} from './shared';\n\n\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nexport function ÉµÉµlistener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false,\n    eventTargetResolver?: GlobalTargetResolver): void {\n  const lView = getLView();\n  const tNode = getPreviousOrParentTNode();\n  listenerInternal(\n      lView, lView[RENDERER], tNode, eventName, listenerFn, useCapture, eventTargetResolver);\n}\n\n/**\n* Registers a synthetic host listener (e.g. `(@foo.start)`) on a component.\n*\n* This instruction is for compatibility purposes and is designed to ensure that a\n* synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\n* in the component's renderer. Normally all host listeners are evaluated with the\n* parent component's renderer, but, in the case of animation @triggers, they need\n* to be evaluated with the sub component's renderer (because that's where the\n* animation triggers are defined).\n*\n* Do not use this instruction as a replacement for `listener`. This instruction\n* only exists to ensure compatibility with the ViewEngine's host binding behavior.\n*\n* @param eventName Name of the event\n* @param listenerFn The function to be called when event emits\n* @param useCapture Whether or not to use capture in event listener\n* @param eventTargetResolver Function that returns global target information in case this listener\n* should be attached to a global object like window, document or body\n *\n * @codeGenApi\n*/\nexport function ÉµÉµcomponentHostSyntheticListener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false,\n    eventTargetResolver?: GlobalTargetResolver): void {\n  const lView = getLView();\n  const tNode = getPreviousOrParentTNode();\n  const renderer = loadComponentRenderer(tNode, lView);\n  listenerInternal(lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver);\n}\n\n/**\n * A utility function that checks if a given element has already an event handler registered for an\n * event with a specified name. The TView.cleanup data structure is used to find out which events\n * are registered for a given element.\n */\nfunction findExistingListener(\n    lView: LView, eventName: string, tNodeIdx: number): ((e?: any) => any)|null {\n  const tView = lView[TVIEW];\n  const tCleanup = tView.cleanup;\n  if (tCleanup != null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      const cleanupEventName = tCleanup[i];\n      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\n        // We have found a matching event name on the same node but it might not have been\n        // registered yet, so we must explicitly verify entries in the LView cleanup data\n        // structures.\n        const lCleanup = lView[CLEANUP] !;\n        const listenerIdxInLCleanup = tCleanup[i + 2];\n        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\n      }\n      // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\n      // 2-element entries (for directive and queries destroy hooks). As such we can encounter\n      // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\n      // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\n      // documentation of TView.cleanup for more details of this data structure layout.\n      if (typeof cleanupEventName === 'string') {\n        i += 2;\n      }\n    }\n  }\n  return null;\n}\n\nfunction listenerInternal(\n    lView: LView, renderer: Renderer3, tNode: TNode, eventName: string,\n    listenerFn: (e?: any) => any, useCapture = false,\n    eventTargetResolver?: GlobalTargetResolver): void {\n  const tView = lView[TVIEW];\n  const isTNodeDirectiveHost = isDirectiveHost(tNode);\n  const firstCreatePass = tView.firstCreatePass;\n  const tCleanup: false|any[] = firstCreatePass && (tView.cleanup || (tView.cleanup = []));\n\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Element, TNodeType.Container, TNodeType.ElementContainer);\n\n  let processOutputs = true;\n\n  // add native event listener - applicable to elements only\n  if (tNode.type === TNodeType.Element) {\n    const native = getNativeByTNode(tNode, lView) as RElement;\n    const resolved = eventTargetResolver ? eventTargetResolver(native) : EMPTY_OBJ as any;\n    const target = resolved.target || native;\n    const lCleanup = getCleanup(lView);\n    const lCleanupIndex = lCleanup.length;\n    const idxOrTargetGetter = eventTargetResolver ?\n        (_lView: LView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])).target :\n        tNode.index;\n\n    // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n    if (isProceduralRenderer(renderer)) {\n      // There might be cases where multiple directives on the same element try to register an event\n      // handler function for the same event. In this situation we want to avoid registration of\n      // several native listeners as each registration would be intercepted by NgZone and\n      // trigger change detection. This would mean that a single user action would result in several\n      // change detections being invoked. To avoid this situation we want to have only one call to\n      // native handler registration (for the same element and same type of event).\n      //\n      // In order to have just one native event handler in presence of multiple handler functions,\n      // we just register a first handler function as a native event listener and then chain\n      // (coalesce) other handler functions on top of the first native handler function.\n      let existingListener = null;\n      // Please note that the coalescing described here doesn't happen for events specifying an\n      // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\n      // view engine.\n      // Also, we don't have to search for existing listeners is there are no directives\n      // matching on a given node as we can't register multiple event handlers for the same event in\n      // a template (this would mean having duplicate attributes).\n      if (!eventTargetResolver && isTNodeDirectiveHost) {\n        existingListener = findExistingListener(lView, eventName, tNode.index);\n      }\n      if (existingListener !== null) {\n        // Attach a new listener to coalesced listeners list, maintaining the order in which\n        // listeners are registered. For performance reasons, we keep a reference to the last\n        // listener in that list (in `__ngLastListenerFn__` field), so we can avoid going through\n        // the entire set each time we need to add a new listener.\n        const lastListenerFn = (<any>existingListener).__ngLastListenerFn__ || existingListener;\n        lastListenerFn.__ngNextListenerFn__ = listenerFn;\n        (<any>existingListener).__ngLastListenerFn__ = listenerFn;\n        processOutputs = false;\n      } else {\n        // The first argument of `listen` function in Procedural Renderer is:\n        // - either a target name (as a string) in case of global target (window, document, body)\n        // - or element reference (in all other cases)\n        listenerFn = wrapListener(tNode, lView, listenerFn, false /** preventDefault */);\n        const cleanupFn = renderer.listen(resolved.name || target, eventName, listenerFn);\n        ngDevMode && ngDevMode.rendererAddEventListener++;\n\n        lCleanup.push(listenerFn, cleanupFn);\n        tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\n      }\n\n    } else {\n      listenerFn = wrapListener(tNode, lView, listenerFn, true /** preventDefault */);\n      target.addEventListener(eventName, listenerFn, useCapture);\n      ngDevMode && ngDevMode.rendererAddEventListener++;\n\n      lCleanup.push(listenerFn);\n      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);\n    }\n  }\n\n  // subscribe to directive outputs\n  const outputs = tNode.outputs;\n  let props: PropertyAliasValue|undefined;\n  if (processOutputs && outputs !== null && (props = outputs[eventName])) {\n    const propsLength = props.length;\n    if (propsLength) {\n      const lCleanup = getCleanup(lView);\n      for (let i = 0; i < propsLength; i += 2) {\n        const index = props[i] as number;\n        ngDevMode && assertDataInRange(lView, index);\n        const minifiedName = props[i + 1];\n        const directiveInstance = lView[index];\n        const output = directiveInstance[minifiedName];\n\n        if (ngDevMode && !isObservable(output)) {\n          throw new Error(\n              `@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);\n        }\n\n        const subscription = output.subscribe(listenerFn);\n        const idx = lCleanup.length;\n        lCleanup.push(listenerFn, subscription);\n        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n      }\n    }\n  }\n}\n\nfunction executeListenerWithErrorHandling(\n    lView: LView, tNode: TNode, listenerFn: (e?: any) => any, e: any): boolean {\n  try {\n    // Only explicitly returning false from a listener should preventDefault\n    return listenerFn(e) !== false;\n  } catch (error) {\n    handleError(lView, error);\n    return false;\n  }\n}\n\n/**\n * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\n * if applicable.\n *\n * @param tNode The TNode associated with this listener\n * @param lView The LView that contains this listener\n * @param listenerFn The listener function to call\n * @param wrapWithPreventDefault Whether or not to prevent default behavior\n * (the procedural renderer does this already, so in those cases, we should skip)\n */\nfunction wrapListener(\n    tNode: TNode, lView: LView, listenerFn: (e?: any) => any,\n    wrapWithPreventDefault: boolean): EventListener {\n  // Note: we are performing most of the work in the listener function itself\n  // to optimize listener registration.\n  return function wrapListenerIn_markDirtyAndPreventDefault(e: any) {\n    // Ivy uses `Function` as a special token that allows us to unwrap the function\n    // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n    if (e === Function) {\n      return listenerFn;\n    }\n\n    // In order to be backwards compatible with View Engine, events on component host nodes\n    // must also mark the component view itself dirty (i.e. the view that it owns).\n    const startView = tNode.flags & TNodeFlags.isComponentHost ?\n        getComponentLViewByIndex(tNode.index, lView) :\n        lView;\n\n    // See interfaces/view.ts for more on LViewFlags.ManualOnPush\n    if ((lView[FLAGS] & LViewFlags.ManualOnPush) === 0) {\n      markViewDirty(startView);\n    }\n\n    let result = executeListenerWithErrorHandling(lView, tNode, listenerFn, e);\n    // A just-invoked listener function might have coalesced listeners so we need to check for\n    // their presence and invoke as needed.\n    let nextListenerFn = (<any>wrapListenerIn_markDirtyAndPreventDefault).__ngNextListenerFn__;\n    while (nextListenerFn) {\n      // We should prevent default if any of the listeners explicitly return false\n      result = executeListenerWithErrorHandling(lView, tNode, nextListenerFn, e) && result;\n      nextListenerFn = (<any>nextListenerFn).__ngNextListenerFn__;\n    }\n\n    if (wrapWithPreventDefault && result === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n\n    return result;\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport {ÉµÉµnamespaceHTML, ÉµÉµnamespaceMathML, ÉµÉµnamespaceSVG} from '../state';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {nextContextImpl} from '../state';\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n *\n * @codeGenApi\n */\nexport function ÉµÉµnextContext<T = any>(level: number = 1): T {\n  return nextContextImpl(level);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {newArray} from '../../util/array_utils';\nimport {TAttributes, TElementNode, TNode, TNodeType} from '../interfaces/node';\nimport {ProjectionSlots} from '../interfaces/projection';\nimport {DECLARATION_COMPONENT_VIEW, TVIEW, T_HOST} from '../interfaces/view';\nimport {applyProjection} from '../node_manipulation';\nimport {getProjectAsAttrValue, isNodeMatchingSelectorList, isSelectorInSelectorList} from '../node_selector_matcher';\nimport {getLView, setIsNotParent} from '../state';\nimport {getOrCreateTNode} from './shared';\n\n\n\n/**\n * Checks a given node against matching projection slots and returns the\n * determined slot index. Returns \"null\" if no slot matched the given node.\n *\n * This function takes into account the parsed ngProjectAs selector from the\n * node's attributes. If present, it will check whether the ngProjectAs selector\n * matches any of the projection slot selectors.\n */\nexport function matchingProjectionSlotIndex(tNode: TNode, projectionSlots: ProjectionSlots): number|\n    null {\n  let wildcardNgContentIndex = null;\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n  for (let i = 0; i < projectionSlots.length; i++) {\n    const slotValue = projectionSlots[i];\n    // The last wildcard projection slot should match all nodes which aren't matching\n    // any selector. This is necessary to be backwards compatible with view engine.\n    if (slotValue === '*') {\n      wildcardNgContentIndex = i;\n      continue;\n    }\n    // If we ran into an `ngProjectAs` attribute, we should match its parsed selector\n    // to the list of selectors, otherwise we fall back to matching against the node.\n    if (ngProjectAsAttrVal === null ?\n            isNodeMatchingSelectorList(tNode, slotValue, /* isProjectionMode */ true) :\n            isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {\n      return i;  // first matching selector \"captures\" a given node\n    }\n  }\n  return wildcardNgContentIndex;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param projectionSlots? A collection of projection slots. A projection slot can be based\n *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\n *        all nodes which do not match any selector. If not specified, a single wildcard\n *        selector projection slot will be defined.\n *\n * @codeGenApi\n */\nexport function ÉµÉµprojectionDef(projectionSlots?: ProjectionSlots): void {\n  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST] as TElementNode;\n\n  if (!componentNode.projection) {\n    // If no explicit projection slots are defined, fall back to a single\n    // projection slot with the wildcard selector.\n    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\n    const projectionHeads: (TNode | null)[] = componentNode.projection =\n        newArray(numProjectionSlots, null !as TNode);\n    const tails: (TNode | null)[] = projectionHeads.slice();\n\n    let componentChild: TNode|null = componentNode.child;\n\n    while (componentChild !== null) {\n      const slotIndex =\n          projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;\n\n      if (slotIndex !== null) {\n        if (tails[slotIndex]) {\n          tails[slotIndex] !.projectionNext = componentChild;\n        } else {\n          projectionHeads[slotIndex] = componentChild;\n        }\n        tails[slotIndex] = componentChild;\n      }\n\n      componentChild = componentChild.next;\n    }\n  }\n}\n\nlet delayProjection = false;\nexport function setDelayProjection(value: boolean) {\n  delayProjection = value;\n}\n\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n *\n * @codeGenApi\n*/\nexport function ÉµÉµprojection(\n    nodeIndex: number, selectorIndex: number = 0, attrs?: TAttributes): void {\n  const lView = getLView();\n  const tProjectionNode = getOrCreateTNode(\n      lView[TVIEW], lView[T_HOST], nodeIndex, TNodeType.Projection, null, attrs || null);\n\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex;\n\n  // `<ng-content>` has no content\n  setIsNotParent();\n\n  // We might need to delay the projection of nodes if they are in the middle of an i18n block\n  if (!delayProjection) {\n    // re-distribution of projectable nodes is stored on a component's view level\n    applyProjection(lView, tProjectionNode);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {bindingUpdated} from '../bindings';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {TVIEW} from '../interfaces/view';\nimport {getLView, getSelectedIndex, nextBindingIndex} from '../state';\n\nimport {TsickleIssue1009, elementPropertyInternal, storePropertyBindingMetadata} from './shared';\n\n\n/**\n * Update a property on a selected element.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nexport function ÉµÉµproperty<T>(\n    propName: string, value: T, sanitizer?: SanitizerFn | null): TsickleIssue1009 {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, value, sanitizer);\n    ngDevMode && storePropertyBindingMetadata(lView[TVIEW].data, nodeIndex, propName, bindingIndex);\n  }\n  return ÉµÉµproperty;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {TVIEW} from '../interfaces/view';\nimport {getBindingIndex, getLView, getSelectedIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {TsickleIssue1009, elementPropertyInternal, storePropertyBindingMetadata} from './shared';\n\n\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolate(\n    propName: string, v0: any, sanitizer?: SanitizerFn): TsickleIssue1009 {\n  ÉµÉµpropertyInterpolate1(propName, '', v0, '', sanitizer);\n  return ÉµÉµpropertyInterpolate;\n}\n\n\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolate1(\n    propName: string, prefix: string, v0: any, suffix: string,\n    sanitizer?: SanitizerFn): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    elementPropertyInternal(lView, getSelectedIndex(), propName, interpolatedValue, sanitizer);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            lView[TVIEW].data, getSelectedIndex(), propName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return ÉµÉµpropertyInterpolate1;\n}\n\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolate2(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, interpolatedValue, sanitizer);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            lView[TVIEW].data, nodeIndex, propName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return ÉµÉµpropertyInterpolate2;\n}\n\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolate3(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, interpolatedValue, sanitizer);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            lView[TVIEW].data, nodeIndex, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return ÉµÉµpropertyInterpolate3;\n}\n\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolate4(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, interpolatedValue, sanitizer);\n    ngDevMode && storePropertyBindingMetadata(\n                     lView[TVIEW].data, nodeIndex, propName, getBindingIndex() - 4, prefix, i0, i1,\n                     i2, suffix);\n  }\n  return ÉµÉµpropertyInterpolate4;\n}\n\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolate5(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string, sanitizer?: SanitizerFn): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, interpolatedValue, sanitizer);\n    ngDevMode && storePropertyBindingMetadata(\n                     lView[TVIEW].data, nodeIndex, propName, getBindingIndex() - 5, prefix, i0, i1,\n                     i2, i3, suffix);\n  }\n  return ÉµÉµpropertyInterpolate5;\n}\n\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolate6(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    sanitizer?: SanitizerFn): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, interpolatedValue, sanitizer);\n    ngDevMode && storePropertyBindingMetadata(\n                     lView[TVIEW].data, nodeIndex, propName, getBindingIndex() - 6, prefix, i0, i1,\n                     i2, i3, i4, suffix);\n  }\n  return ÉµÉµpropertyInterpolate6;\n}\n\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolate7(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, interpolatedValue, sanitizer);\n    ngDevMode && storePropertyBindingMetadata(\n                     lView[TVIEW].data, nodeIndex, propName, getBindingIndex() - 7, prefix, i0, i1,\n                     i2, i3, i4, i5, suffix);\n  }\n  return ÉµÉµpropertyInterpolate7;\n}\n\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolate8(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, interpolatedValue, sanitizer);\n    ngDevMode && storePropertyBindingMetadata(\n                     lView[TVIEW].data, nodeIndex, propName, getBindingIndex() - 8, prefix, i0, i1,\n                     i2, i3, i4, i5, i6, suffix);\n  }\n  return ÉµÉµpropertyInterpolate8;\n}\n\n/**\n * Update an interpolated property on an element with 8 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 7.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ÉµÉµpropertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The a collection of values and the strings inbetween those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµpropertyInterpolateV(\n    propName: string, values: any[], sanitizer?: SanitizerFn): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  if (interpolatedValue !== NO_CHANGE) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, interpolatedValue, sanitizer);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          lView[TVIEW].data, nodeIndex, propName,\n          getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return ÉµÉµpropertyInterpolateV;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertDataInRange, assertEqual} from '../../util/assert';\nimport {TElementNode, TNodeType} from '../interfaces/node';\nimport {HEADER_OFFSET, RENDERER, TVIEW, T_HOST} from '../interfaces/view';\nimport {appendChild, createTextNode} from '../node_manipulation';\nimport {getBindingIndex, getLView, setPreviousOrParentTNode} from '../state';\n\nimport {getOrCreateTNode} from './shared';\n\n\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Static string value to write.\n *\n * @codeGenApi\n */\nexport function ÉµÉµtext(index: number, value: string = ''): void {\n  const lView = getLView();\n  const tView = lView[TVIEW];\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  ngDevMode && assertEqual(\n                   getBindingIndex(), tView.bindingStartIndex,\n                   'text nodes should be created before any bindings');\n  ngDevMode && assertDataInRange(lView, adjustedIndex);\n\n  const tNode = tView.firstCreatePass ?\n      getOrCreateTNode(tView, lView[T_HOST], index, TNodeType.Element, null, null) :\n      tView.data[adjustedIndex] as TElementNode;\n\n  const textNative = lView[adjustedIndex] = createTextNode(value, lView[RENDERER]);\n  appendChild(textNative, tNode, lView);\n\n  // Text nodes are self closing.\n  setPreviousOrParentTNode(tNode, false);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {getLView, getSelectedIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {TsickleIssue1009, textBindingInternal} from './shared';\n\n\n/**\n *\n * Update text content with a lone bound value\n *\n * Used when a text node has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div>{{v0}}</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolate(v0);\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolate(v0: any): TsickleIssue1009 {\n  ÉµÉµtextInterpolate1('', v0, '');\n  return ÉµÉµtextInterpolate;\n}\n\n\n/**\n *\n * Update text content with single bound value surrounded by other text.\n *\n * Used when a text node has 1 interpolated value in it:\n *\n * ```html\n * <div>prefix{{v0}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolate1('prefix', v0, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolate1(prefix: string, v0: any, suffix: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated = interpolation1(lView, prefix, v0, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ÉµÉµtextInterpolate1;\n}\n\n/**\n *\n * Update text content with 2 bound values surrounded by other text.\n *\n * Used when a text node has 2 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ÉµÉµtextInterpolate2;\n}\n\n/**\n *\n * Update text content with 3 bound values surrounded by other text.\n *\n * Used when a text node has 3 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ÉµÉµtextInterpolate3;\n}\n\n/**\n *\n * Update text content with 4 bound values surrounded by other text.\n *\n * Used when a text node has 4 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see ÉµÉµtextInterpolateV\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ÉµÉµtextInterpolate4;\n}\n\n/**\n *\n * Update text content with 5 bound values surrounded by other text.\n *\n * Used when a text node has 5 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ÉµÉµtextInterpolate5;\n}\n\n/**\n *\n * Update text content with 6 bound values surrounded by other text.\n *\n * Used when a text node has 6 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change. @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ÉµÉµtextInterpolate6;\n}\n\n/**\n *\n * Update text content with 7 bound values surrounded by other text.\n *\n * Used when a text node has 7 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any,\n    suffix: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ÉµÉµtextInterpolate7;\n}\n\n/**\n *\n * Update text content with 8 bound values surrounded by other text.\n *\n * Used when a text node has 8 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ÉµÉµtextInterpolate8;\n}\n\n/**\n * Update text content with 9 or more bound values other surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµtextInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The a collection of values and the strings in between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n *\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµtextInterpolateV(values: any[]): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ÉµÉµtextInterpolateV;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView, getSelectedIndex} from '../state';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {classMapInternal} from './styling';\n\n\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ÉµÉµclassMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  classMapInternal(getSelectedIndex(), interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ÉµÉµclassMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  classMapInternal(getSelectedIndex(), interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ÉµÉµclassMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  classMapInternal(getSelectedIndex(), interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ÉµÉµclassMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  classMapInternal(getSelectedIndex(), interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ÉµÉµclassMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  classMapInternal(getSelectedIndex(), interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ÉµÉµclassMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  classMapInternal(getSelectedIndex(), interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ÉµÉµclassMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  classMapInternal(getSelectedIndex(), interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ÉµÉµclassMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  classMapInternal(getSelectedIndex(), interpolatedValue);\n}\n\n/**\n * Update an interpolated class on an element with 8 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 7.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The a collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function ÉµÉµclassMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  classMapInternal(getSelectedIndex(), interpolatedValue);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {getLView, getSelectedIndex} from '../state';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {TsickleIssue1009} from './shared';\nimport {stylePropInternal} from './styling';\n\n\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµstylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµstylePropInterpolate1(\n    prop: string, prefix: string, v0: any, suffix: string,\n    valueSuffix?: string | null): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  stylePropInternal(getSelectedIndex(), prop, interpolatedValue as string, valueSuffix);\n  return ÉµÉµstylePropInterpolate1;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµstylePropInterpolate2(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    valueSuffix?: string | null): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  stylePropInternal(getSelectedIndex(), prop, interpolatedValue as string, valueSuffix);\n  return ÉµÉµstylePropInterpolate2;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµstylePropInterpolate3(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string,\n    valueSuffix?: string | null): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  stylePropInternal(getSelectedIndex(), prop, interpolatedValue as string, valueSuffix);\n  return ÉµÉµstylePropInterpolate3;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµstylePropInterpolate4(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, valueSuffix?: string | null): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  stylePropInternal(getSelectedIndex(), prop, interpolatedValue as string, valueSuffix);\n  return ÉµÉµstylePropInterpolate4;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµstylePropInterpolate5(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string, valueSuffix?: string | null): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  stylePropInternal(getSelectedIndex(), prop, interpolatedValue as string, valueSuffix);\n  return ÉµÉµstylePropInterpolate5;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµstylePropInterpolate6(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    valueSuffix?: string | null): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  stylePropInternal(getSelectedIndex(), prop, interpolatedValue as string, valueSuffix);\n  return ÉµÉµstylePropInterpolate6;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµstylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµstylePropInterpolate7(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    valueSuffix?: string | null): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  stylePropInternal(getSelectedIndex(), prop, interpolatedValue as string, valueSuffix);\n  return ÉµÉµstylePropInterpolate7;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµstylePropInterpolate8(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, valueSuffix?: string | null): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  stylePropInternal(getSelectedIndex(), prop, interpolatedValue as string, valueSuffix);\n  return ÉµÉµstylePropInterpolate8;\n}\n\n/**\n * Update an interpolated style property on an element with 8 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 7.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ÉµÉµstylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The a collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ÉµÉµstylePropInterpolateV(\n    prop: string, values: any[], valueSuffix?: string | null): TsickleIssue1009 {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  stylePropInternal(getSelectedIndex(), prop, interpolatedValue as string, valueSuffix);\n  return ÉµÉµstylePropInterpolateV;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {bindingUpdated} from '../bindings';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {TVIEW} from '../interfaces/view';\nimport {getLView, getSelectedIndex, nextBindingIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {TsickleIssue1009, elementPropertyInternal, loadComponentRenderer, storePropertyBindingMetadata} from './shared';\n\n/**\n * Update a property on a host element. Only applies to native node properties, not inputs.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nexport function ÉµÉµhostProperty<T>(\n    propName: string, value: T, sanitizer?: SanitizerFn | null): TsickleIssue1009 {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(lView, nodeIndex, propName, value, sanitizer, true);\n    ngDevMode && storePropertyBindingMetadata(lView[TVIEW].data, nodeIndex, propName, bindingIndex);\n  }\n  return ÉµÉµhostProperty;\n}\n\n\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub component's renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n *\n * @codeGenApi\n */\nexport function ÉµÉµupdateSyntheticHostBinding<T>(\n    propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn | null): TsickleIssue1009 {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const nodeIndex = getSelectedIndex();\n    elementPropertyInternal(\n        lView, nodeIndex, propName, value, sanitizer, true, loadComponentRenderer);\n    ngDevMode && storePropertyBindingMetadata(lView[TVIEW].data, nodeIndex, propName, bindingIndex);\n  }\n  return ÉµÉµupdateSyntheticHostBinding;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/*\n * This file re-exports all symbols contained in this directory.\n *\n * Why is this file not `index.ts`?\n *\n * There seems to be an inconsistent path resolution of an `index.ts` file\n * when only the parent directory is referenced. This could be due to the\n * node module resolution configuration differing from rollup and/or typescript.\n *\n * With commit\n * https://github.com/angular/angular/commit/d5e3f2c64bd13ce83e7c70788b7fc514ca4a9918\n * the `instructions.ts` file was moved to `instructions/instructions.ts` and an\n * `index.ts` file was used to re-export everything. Having had file names that were\n * importing from `instructions' directly (not the from the sub file or the `index.ts`\n * file) caused strange CI issues. `index.ts` had to be renamed to `all.ts` for this\n * to work.\n *\n * Jira Issue = FW-1184\n */\nexport * from './alloc_host_vars';\nexport * from './attribute';\nexport * from './attribute_interpolation';\nexport * from './change_detection';\nexport * from './container';\nexport * from './storage';\nexport * from './di';\nexport * from './element';\nexport * from './element_container';\nexport * from './embedded_view';\nexport * from './get_current_view';\nexport * from './listener';\nexport * from './namespace';\nexport * from './next_context';\nexport * from './projection';\nexport * from './property';\nexport * from './property_interpolation';\nexport * from './advance';\nexport * from './styling';\nexport * from './text';\nexport * from './text_interpolation';\nexport * from './class_map_interpolation';\nexport * from './style_prop_interpolation';\nexport * from './host_property';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../../di/injector';\nimport {assertLView} from '../assert';\nimport {discoverLocalRefs, getComponentAtNodeIndex, getDirectivesAtNodeIndex, getLContext} from '../context_discovery';\nimport {NodeInjector} from '../di';\nimport {DebugNode, buildDebugNode} from '../instructions/lview_debug';\nimport {LContext} from '../interfaces/context';\nimport {DirectiveDef} from '../interfaces/definition';\nimport {TElementNode, TNode, TNodeProviderIndexes} from '../interfaces/node';\nimport {isLView} from '../interfaces/type_checks';\nimport {CLEANUP, CONTEXT, FLAGS, HEADER_OFFSET, HOST, LView, LViewFlags, TVIEW, T_HOST} from '../interfaces/view';\n\nimport {stringifyForError} from './misc_utils';\nimport {getLViewParent, getRootContext} from './view_traversal_utils';\nimport {getTNode, unwrapRNode} from './view_utils';\n\n\n\n/**\n * Returns the component instance associated with a given DOM host element.\n * Elements which don't represent components return `null`.\n *\n * @param element Host DOM element from which the component should be retrieved.\n *\n * ```\n * <my-app>\n *   #VIEW\n *     <div>\n *       <child-comp></child-comp>\n *     </div>\n * </mp-app>\n *\n * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();\n * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();\n * ```\n *\n * @publicApi\n */\nexport function getComponent<T = {}>(element: Element): T|null {\n  if (!(element instanceof Node)) throw new Error('Expecting instance of DOM Node');\n  const context = loadLContext(element, false);\n  if (context === null) return null;\n\n\n  if (context.component === undefined) {\n    context.component = getComponentAtNodeIndex(context.nodeIndex, context.lView);\n  }\n\n  return context.component as T;\n}\n\n/**\n * Returns the component instance associated with a given DOM host element.\n * Elements which don't represent components return `null`.\n *\n * @param element Host DOM element from which the component should be retrieved.\n *\n * ```\n * <my-app>\n *   #VIEW\n *     <div>\n *       <child-comp></child-comp>\n *     </div>\n * </mp-app>\n *\n * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();\n * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();\n * ```\n *\n * @publicApi\n */\nexport function getContext<T = {}>(element: Element): T|null {\n  if (!(element instanceof Node)) throw new Error('Expecting instance of DOM Node');\n  const context = loadLContext(element, false);\n  if (context === null) return null;\n\n  return context.lView[CONTEXT] as T;\n}\n\n/**\n * Returns the component instance associated with view which owns the DOM element (`null`\n * otherwise).\n *\n * @param element DOM element which is owned by an existing component's view.\n *\n * ```\n * <my-app>\n *   #VIEW\n *     <div>\n *       <child-comp></child-comp>\n *     </div>\n * </mp-app>\n *\n * expect(getViewComponent(<child-comp>) instanceof MyApp).toBeTruthy();\n * expect(getViewComponent(<my-app>)).toEqual(null);\n * ```\n *\n * @publicApi\n */\nexport function getViewComponent<T = {}>(element: Element | {}): T|null {\n  const context = loadLContext(element, false);\n  if (context === null) return null;\n\n  let lView = context.lView;\n  let parent: LView|null;\n  ngDevMode && assertLView(lView);\n  while (lView[HOST] === null && (parent = getLViewParent(lView) !)) {\n    // As long as lView[HOST] is null we know we are part of sub-template such as `*ngIf`\n    lView = parent;\n  }\n  return lView[FLAGS] & LViewFlags.IsRoot ? null : lView[CONTEXT] as T;\n}\n\n/**\n * Retrieve all root components.\n *\n * Root components are those which have been bootstrapped by Angular.\n *\n * @param target A DOM element, component or directive instance.\n *\n * @publicApi\n */\nexport function getRootComponents(target: {}): any[] {\n  return [...getRootContext(target).components];\n}\n\n/**\n * Retrieves an `Injector` associated with the element, component or directive.\n *\n * @param target A DOM element, component or directive instance.\n *\n * @publicApi\n */\nexport function getInjector(target: {}): Injector {\n  const context = loadLContext(target, false);\n  if (context === null) return Injector.NULL;\n\n  const tNode = context.lView[TVIEW].data[context.nodeIndex] as TElementNode;\n  return new NodeInjector(tNode, context.lView);\n}\n\n/**\n * Retrieve a set of injection tokens at a given DOM node.\n *\n * @param element Element for which the injection tokens should be retrieved.\n * @publicApi\n */\nexport function getInjectionTokens(element: Element): any[] {\n  const context = loadLContext(element, false);\n  if (context === null) return [];\n  const lView = context.lView;\n  const tView = lView[TVIEW];\n  const tNode = tView.data[context.nodeIndex] as TNode;\n  const providerTokens: any[] = [];\n  const startIndex = tNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const endIndex = tNode.directiveEnd;\n  for (let i = startIndex; i < endIndex; i++) {\n    let value = tView.data[i];\n    if (isDirectiveDefHack(value)) {\n      // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a\n      // design flaw.  We should always store same type so that we can be monomorphic. The issue\n      // is that for Components/Directives we store the def instead the type. The correct behavior\n      // is that we should always be storing injectable type in this location.\n      value = value.type;\n    }\n    providerTokens.push(value);\n  }\n  return providerTokens;\n}\n\n/**\n * Retrieves directives associated with a given DOM host element.\n *\n * @param target A DOM element, component or directive instance.\n *\n * @publicApi\n */\nexport function getDirectives(target: {}): Array<{}> {\n  const context = loadLContext(target) !;\n\n  if (context.directives === undefined) {\n    context.directives = getDirectivesAtNodeIndex(context.nodeIndex, context.lView, false);\n  }\n\n  return context.directives || [];\n}\n\n/**\n * Returns LContext associated with a target passed as an argument.\n * Throws if a given target doesn't have associated LContext.\n *\n */\nexport function loadLContext(target: {}): LContext;\nexport function loadLContext(target: {}, throwOnNotFound: false): LContext|null;\nexport function loadLContext(target: {}, throwOnNotFound: boolean = true): LContext|null {\n  const context = getLContext(target);\n  if (!context && throwOnNotFound) {\n    throw new Error(\n        ngDevMode ? `Unable to find context associated with ${stringifyForError(target)}` :\n                    'Invalid ng target');\n  }\n  return context;\n}\n\n/**\n * Retrieve map of local references.\n *\n * The references are retrieved as a map of local reference name to element or directive instance.\n *\n * @param target A DOM element, component or directive instance.\n *\n * @publicApi\n */\nexport function getLocalRefs(target: {}): {[key: string]: any} {\n  const context = loadLContext(target, false);\n  if (context === null) return {};\n\n  if (context.localRefs === undefined) {\n    context.localRefs = discoverLocalRefs(context.lView, context.nodeIndex);\n  }\n\n  return context.localRefs || {};\n}\n\n/**\n * Retrieve the host element of the component.\n *\n * Use this function to retrieve the host element of the component. The host\n * element is the element which the component is associated with.\n *\n * @param directive Component or Directive for which the host element should be retrieved.\n *\n * @publicApi\n */\nexport function getHostElement<T>(directive: T): Element {\n  return getLContext(directive) !.native as never as Element;\n}\n\n/**\n * Retrieves the rendered text for a given component.\n *\n * This function retrieves the host element of a component and\n * and then returns the `textContent` for that element. This implies\n * that the text returned will include re-projected content of\n * the component as well.\n *\n * @param component The component to return the content text for.\n */\nexport function getRenderedText(component: any): string {\n  const hostElement = getHostElement(component);\n  return hostElement.textContent || '';\n}\n\nexport function loadLContextFromNode(node: Node): LContext {\n  if (!(node instanceof Node)) throw new Error('Expecting instance of DOM Node');\n  return loadLContext(node) !;\n}\n\nexport interface Listener {\n  name: string;\n  element: Element;\n  callback: (value: any) => any;\n  useCapture: boolean|null;\n}\n\nexport function isBrowserEvents(listener: Listener): boolean {\n  // Browser events are those which don't have `useCapture` as boolean.\n  return typeof listener.useCapture === 'boolean';\n}\n\n\n/**\n * Retrieves a list of DOM listeners.\n *\n * ```\n * <my-app>\n *   #VIEW\n *     <div (click)=\"doSomething()\">\n *     </div>\n * </mp-app>\n *\n * expect(getListeners(<div>)).toEqual({\n *   name: 'click',\n *   element: <div>,\n *   callback: () => doSomething(),\n *   useCapture: false\n * });\n * ```\n *\n * @param element Element for which the DOM listeners should be retrieved.\n * @publicApi\n */\nexport function getListeners(element: Element): Listener[] {\n  if (!(element instanceof Node)) throw new Error('Expecting instance of DOM Node');\n  const lContext = loadLContext(element, false);\n  if (lContext === null) return [];\n\n  const lView = lContext.lView;\n  const tView = lView[TVIEW];\n  const lCleanup = lView[CLEANUP];\n  const tCleanup = tView.cleanup;\n  const listeners: Listener[] = [];\n  if (tCleanup && lCleanup) {\n    for (let i = 0; i < tCleanup.length;) {\n      const firstParam = tCleanup[i++];\n      const secondParam = tCleanup[i++];\n      if (typeof firstParam === 'string') {\n        const name: string = firstParam;\n        const listenerElement = unwrapRNode(lView[secondParam]) as any as Element;\n        const callback: (value: any) => any = lCleanup[tCleanup[i++]];\n        const useCaptureOrIndx = tCleanup[i++];\n        // if useCaptureOrIndx is boolean then report it as is.\n        // if useCaptureOrIndx is positive number then it in unsubscribe method\n        // if useCaptureOrIndx is negative number then it is a Subscription\n        const useCapture = typeof useCaptureOrIndx === 'boolean' ?\n            useCaptureOrIndx :\n            (useCaptureOrIndx >= 0 ? false : null);\n        if (element == listenerElement) {\n          listeners.push({element, name, callback, useCapture});\n        }\n      }\n    }\n  }\n  listeners.sort(sortListeners);\n  return listeners;\n}\n\nfunction sortListeners(a: Listener, b: Listener) {\n  if (a.name == b.name) return 0;\n  return a.name < b.name ? -1 : 1;\n}\n\n/**\n * This function should not exist because it is megamorphic and only mostly correct.\n *\n * See call site for more info.\n */\nfunction isDirectiveDefHack(obj: any): obj is DirectiveDef<any> {\n  return obj.type !== undefined && obj.template !== undefined && obj.declaredInputs !== undefined;\n}\n\n/**\n * Returns the attached `DebugNode` instance for an element in the DOM.\n *\n * @param element DOM element which is owned by an existing component's view.\n *\n * @publicApi\n */\nexport function getDebugNode(element: Node): DebugNode|null {\n  let debugNode: DebugNode|null = null;\n\n  const lContext = loadLContextFromNode(element);\n  const lView = lContext.lView;\n  const nodeIndex = lContext.nodeIndex;\n  if (nodeIndex !== -1) {\n    const valueInLView = lView[nodeIndex];\n    // this means that value in the lView is a component with its own\n    // data. In this situation the TNode is not accessed at the same spot.\n    const tNode = isLView(valueInLView) ? (valueInLView[T_HOST] as TNode) :\n                                          getTNode(nodeIndex - HEADER_OFFSET, lView);\n    debugNode = buildDebugNode(tNode, lView, nodeIndex);\n  }\n\n  return debugNode;\n}\n\n/**\n * Retrieve the component `LView` from component/element.\n *\n * NOTE: `LView` is a private and should not be leaked outside.\n *       Don't export this method to `ng.*` on window.\n *\n * @param target Component or Element instance.\n */\nexport function getComponentLView(target: any): LView {\n  const lContext = loadLContext(target);\n  const nodeIndx = lContext.nodeIndex;\n  const lView = lContext.lView;\n  const componentLView = lView[nodeIndx];\n  ngDevMode && assertLView(componentLView);\n  return componentLView;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * This file is the index file collecting all of the symbols published on the global.ng namespace.\n *\n * The reason why this file/module is separate global_utils.ts file is that we use this file\n * to generate a d.ts file containing all the published symbols that is then compared to the golden\n * file in the public_api_guard test.\n */\n\nexport {markDirty} from './instructions/all';\nexport {getComponent, getContext, getDebugNode, getDirectives, getHostElement, getInjector, getListeners, getRootComponents, getViewComponent} from './util/discovery_utils';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertDefined} from '../../util/assert';\nimport {global} from '../../util/global';\nimport {getComponent, getContext, getDebugNode, getDirectives, getHostElement, getInjector, getListeners, getRootComponents, getViewComponent, markDirty} from '../global_utils_api';\n\n\n\n/**\n * This file introduces series of globally accessible debug tools\n * to allow for the Angular debugging story to function.\n *\n * To see this in action run the following command:\n *\n *   bazel run --config=ivy\n *   //packages/core/test/bundling/todo:devserver\n *\n *  Then load `localhost:5432` and start using the console tools.\n */\n\n/**\n * This value reflects the property on the window where the dev\n * tools are patched (window.ng).\n * */\nexport const GLOBAL_PUBLISH_EXPANDO_KEY = 'ng';\n\nlet _published = false;\n/**\n * Publishes a collection of default debug tools onto`window.ng`.\n *\n * These functions are available globally when Angular is in development\n * mode and are automatically stripped away from prod mode is on.\n */\nexport function publishDefaultGlobalUtils() {\n  if (!_published) {\n    _published = true;\n    publishGlobalUtil('getComponent', getComponent);\n    publishGlobalUtil('getContext', getContext);\n    publishGlobalUtil('getListeners', getListeners);\n    publishGlobalUtil('getViewComponent', getViewComponent);\n    publishGlobalUtil('getHostElement', getHostElement);\n    publishGlobalUtil('getInjector', getInjector);\n    publishGlobalUtil('getRootComponents', getRootComponents);\n    publishGlobalUtil('getDirectives', getDirectives);\n    publishGlobalUtil('getDebugNode', getDebugNode);\n    publishGlobalUtil('markDirty', markDirty);\n  }\n}\n\nexport declare type GlobalDevModeContainer = {\n  [GLOBAL_PUBLISH_EXPANDO_KEY]: {[fnName: string]: Function};\n};\n\n/**\n * Publishes the given function to `window.ng` so that it can be\n * used from the browser console when an application is not in production.\n */\nexport function publishGlobalUtil(name: string, fn: Function): void {\n  if (typeof COMPILED === 'undefined' || !COMPILED) {\n    // Note: we can't export `ng` when using closure enhanced optimization as:\n    // - closure declares globals itself for minified names, which sometimes clobber our `ng` global\n    // - we can't declare a closure extern as the namespace `ng` is already used within Google\n    //   for typings for AngularJS (via `goog.provide('ng....')`).\n    const w = global as any as GlobalDevModeContainer;\n    ngDevMode && assertDefined(fn, 'function not defined');\n    if (w) {\n      let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];\n      if (!container) {\n        container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};\n      }\n      container[name] = fn;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// We are temporarily importing the existing viewEngine from core so we can be sure we are\n// correctly implementing its interfaces for backwards compatibility.\nimport {Type} from '../core';\nimport {Injector} from '../di/injector';\nimport {Sanitizer} from '../sanitization/sanitizer';\nimport {assertDataInRange} from '../util/assert';\n\nimport {assertComponentType} from './assert';\nimport {getComponentDef} from './definition';\nimport {diPublicInInjector, getOrCreateNodeInjectorForNode} from './di';\nimport {registerPostOrderHooks, registerPreOrderHooks} from './hooks';\nimport {CLEAN_PROMISE, addToViewTree, createLView, createTView, getOrCreateTComponentView, getOrCreateTNode, initNodeFlags, instantiateRootComponent, invokeHostBindingsInCreationMode, locateHostElement, markAsComponentHost, refreshView, renderView} from './instructions/shared';\nimport {ComponentDef, ComponentType, RenderFlags} from './interfaces/definition';\nimport {TElementNode, TNode, TNodeType} from './interfaces/node';\nimport {PlayerHandler} from './interfaces/player';\nimport {RElement, Renderer3, RendererFactory3, domRendererFactory3} from './interfaces/renderer';\nimport {CONTEXT, HEADER_OFFSET, LView, LViewFlags, RootContext, RootContextFlags, TVIEW, TViewType} from './interfaces/view';\nimport {enterView, getPreviousOrParentTNode, incrementActiveDirectiveId, leaveView, setActiveHostElement} from './state';\nimport {publishDefaultGlobalUtils} from './util/global_utils';\nimport {defaultScheduler, stringifyForError} from './util/misc_utils';\nimport {getRootContext} from './util/view_traversal_utils';\nimport {readPatchedLView} from './util/view_utils';\n\n\n\n/** Options that control how the component should be bootstrapped. */\nexport interface CreateComponentOptions {\n  /** Which renderer factory to use. */\n  rendererFactory?: RendererFactory3;\n\n  /** A custom sanitizer instance */\n  sanitizer?: Sanitizer;\n\n  /** A custom animation player handler */\n  playerHandler?: PlayerHandler;\n\n  /**\n   * Host element on which the component will be bootstrapped. If not specified,\n   * the component definition's `tag` is used to query the existing DOM for the\n   * element to bootstrap.\n   */\n  host?: RElement|string;\n\n  /** Module injector for the component. If unspecified, the injector will be NULL_INJECTOR. */\n  injector?: Injector;\n\n  /**\n   * List of features to be applied to the created component. Features are simply\n   * functions that decorate a component with a certain behavior.\n   *\n   * Typically, the features in this list are features that cannot be added to the\n   * other features list in the component definition because they rely on other factors.\n   *\n   * Example: `LifecycleHooksFeature` is a function that adds lifecycle hook capabilities\n   * to root components in a tree-shakable way. It cannot be added to the component\n   * features list because there's no way of knowing when the component will be used as\n   * a root component.\n   */\n  hostFeatures?: HostFeature[];\n\n  /**\n   * A function which is used to schedule change detection work in the future.\n   *\n   * When marking components as dirty, it is necessary to schedule the work of\n   * change detection in the future. This is done to coalesce multiple\n   * {@link markDirty} calls into a single changed detection processing.\n   *\n   * The default value of the scheduler is the `requestAnimationFrame` function.\n   *\n   * It is also useful to override this function for testing purposes.\n   */\n  scheduler?: (work: () => void) => void;\n}\n\n/** See CreateComponentOptions.hostFeatures */\ntype HostFeature = (<T>(component: T, componentDef: ComponentDef<T>) => void);\n\n// TODO: A hack to not pull in the NullInjector from @angular/core.\nexport const NULL_INJECTOR: Injector = {\n  get: (token: any, notFoundValue?: any) => {\n    throw new Error('NullInjector: Not found: ' + stringifyForError(token));\n  }\n};\n\n/**\n * Bootstraps a Component into an existing host element and returns an instance\n * of the component.\n *\n * Use this function to bootstrap a component into the DOM tree. Each invocation\n * of this function will create a separate tree of components, injectors and\n * change detection cycles and lifetimes. To dynamically insert a new component\n * into an existing tree such that it shares the same injection, change detection\n * and object lifetime, use {@link ViewContainer#createComponent}.\n *\n * @param componentType Component to bootstrap\n * @param options Optional parameters which control bootstrapping\n */\nexport function renderComponent<T>(\n    componentType: ComponentType<T>|\n        Type<T>/* Type as workaround for: Microsoft/TypeScript/issues/4881 */\n    ,\n    opts: CreateComponentOptions = {}): T {\n  ngDevMode && publishDefaultGlobalUtils();\n  ngDevMode && assertComponentType(componentType);\n\n  const rendererFactory = opts.rendererFactory || domRendererFactory3;\n  const sanitizer = opts.sanitizer || null;\n  const componentDef = getComponentDef<T>(componentType) !;\n  if (componentDef.type != componentType) componentDef.type = componentType;\n\n  // The first index of the first selector is the tag name.\n  const componentTag = componentDef.selectors ![0] ![0] as string;\n  const hostRNode =\n      locateHostElement(rendererFactory, opts.host || componentTag, componentDef.encapsulation);\n  const rootFlags = componentDef.onPush ? LViewFlags.Dirty | LViewFlags.IsRoot :\n                                          LViewFlags.CheckAlways | LViewFlags.IsRoot;\n  const rootContext = createRootContext(opts.scheduler, opts.playerHandler);\n\n  const renderer = rendererFactory.createRenderer(hostRNode, componentDef);\n  const rootTView = createTView(TViewType.Root, -1, null, 1, 0, null, null, null, null, null);\n  const rootView: LView = createLView(\n      null, rootTView, rootContext, rootFlags, null, null, rendererFactory, renderer, undefined,\n      opts.injector || null);\n\n  enterView(rootView, null);\n  let component: T;\n\n  try {\n    if (rendererFactory.begin) rendererFactory.begin();\n    const componentView = createRootComponentView(\n        hostRNode, componentDef, rootView, rendererFactory, renderer, sanitizer);\n    component = createRootComponent(\n        componentView, componentDef, rootView, rootContext, opts.hostFeatures || null);\n\n    // create mode pass\n    renderView(rootView, rootTView, null);\n    // update mode pass\n    refreshView(rootView, rootTView, null, null);\n\n  } finally {\n    leaveView();\n    if (rendererFactory.end) rendererFactory.end();\n  }\n\n  return component;\n}\n\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param renderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nexport function createRootComponentView(\n    rNode: RElement | null, def: ComponentDef<any>, rootView: LView,\n    rendererFactory: RendererFactory3, renderer: Renderer3, sanitizer?: Sanitizer | null): LView {\n  const tView = rootView[TVIEW];\n  ngDevMode && assertDataInRange(rootView, 0 + HEADER_OFFSET);\n  rootView[0 + HEADER_OFFSET] = rNode;\n  const tNode: TElementNode = getOrCreateTNode(tView, null, 0, TNodeType.Element, null, null);\n  const componentView = createLView(\n      rootView, getOrCreateTComponentView(def), null,\n      def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, rootView[HEADER_OFFSET], tNode,\n      rendererFactory, renderer, sanitizer);\n\n  if (tView.firstCreatePass) {\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);\n    markAsComponentHost(tView, tNode);\n    initNodeFlags(tNode, rootView.length, 1);\n  }\n\n  addToViewTree(rootView, componentView);\n\n  // Store component view at node index, with node as the HOST\n  return rootView[HEADER_OFFSET] = componentView;\n}\n\n/**\n * Creates a root component and sets it up with features and host bindings. Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nexport function createRootComponent<T>(\n    componentView: LView, componentDef: ComponentDef<T>, rootView: LView, rootContext: RootContext,\n    hostFeatures: HostFeature[] | null): any {\n  const tView = rootView[TVIEW];\n  // Create directive instance with factory() and store at next index in viewData\n  const component = instantiateRootComponent(tView, rootView, componentDef);\n\n  rootContext.components.push(component);\n  componentView[CONTEXT] = component;\n\n  hostFeatures && hostFeatures.forEach((feature) => feature(component, componentDef));\n\n  // We want to generate an empty QueryList for root content queries for backwards\n  // compatibility with ViewEngine.\n  if (componentDef.contentQueries) {\n    componentDef.contentQueries(RenderFlags.Create, component, rootView.length - 1);\n  }\n\n  const rootTNode = getPreviousOrParentTNode();\n  if (tView.firstCreatePass && componentDef.hostBindings) {\n    const elementIndex = rootTNode.index - HEADER_OFFSET;\n    setActiveHostElement(elementIndex);\n    incrementActiveDirectiveId();\n\n    const expando = tView.expandoInstructions !;\n    invokeHostBindingsInCreationMode(\n        componentDef, expando, component, rootTNode, tView.firstCreatePass);\n\n    setActiveHostElement(null);\n  }\n\n  return component;\n}\n\n\nexport function createRootContext(\n    scheduler?: (workFn: () => void) => void, playerHandler?: PlayerHandler|null): RootContext {\n  return {\n    components: [],\n    scheduler: scheduler || defaultScheduler,\n    clean: CLEAN_PROMISE,\n    playerHandler: playerHandler || null,\n    flags: RootContextFlags.Empty\n  };\n}\n\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});\n * ```\n */\nexport function LifecycleHooksFeature(component: any, def: ComponentDef<any>): void {\n  const rootTView = readPatchedLView(component) ![TVIEW];\n  const dirIndex = rootTView.data.length - 1;\n\n  // TODO(misko): replace `as TNode` with createTNode call. (needs refactoring to lose dep on\n  // LNode).\n  registerPostOrderHooks(\n      rootTView, { directiveStart: dirIndex, directiveEnd: dirIndex + 1 } as TNode);\n}\n\n/**\n * Wait on component until it is rendered.\n *\n * This function returns a `Promise` which is resolved when the component's\n * change detection is executed. This is determined by finding the scheduler\n * associated with the `component`'s render tree and waiting until the scheduler\n * flushes. If nothing is scheduled, the function returns a resolved promise.\n *\n * Example:\n * ```\n * await whenRendered(myComponent);\n * ```\n *\n * @param component Component to wait upon\n * @returns Promise which resolves when the component is rendered.\n */\nexport function whenRendered(component: any): Promise<null> {\n  return getRootContext(component).clean;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../../interface/type';\nimport {fillProperties} from '../../util/property';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from '../empty';\nimport {ComponentDef, ContentQueriesFunction, DirectiveDef, DirectiveDefFeature, HostBindingsFunction, RenderFlags, ViewQueriesFunction} from '../interfaces/definition';\nimport {isComponentDef} from '../interfaces/type_checks';\n\nexport function getSuperType(type: Type<any>): Type<any>&\n    {Éµcmp?: ComponentDef<any>, Éµdir?: DirectiveDef<any>} {\n  return Object.getPrototypeOf(type.prototype).constructor;\n}\n\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n *\n * @codeGenApi\n */\nexport function ÉµÉµInheritDefinitionFeature(definition: DirectiveDef<any>| ComponentDef<any>): void {\n  let superType = getSuperType(definition.type);\n\n  while (superType) {\n    let superDef: DirectiveDef<any>|ComponentDef<any>|undefined = undefined;\n    if (isComponentDef(definition)) {\n      // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n      superDef = superType.Éµcmp || superType.Éµdir;\n    } else {\n      if (superType.Éµcmp) {\n        throw new Error('Directives cannot inherit Components');\n      }\n      // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n      superDef = superType.Éµdir;\n    }\n\n    if (superDef) {\n      // Some fields in the definition may be empty, if there were no values to put in them that\n      // would've justified object creation. Unwrap them if necessary.\n      const writeableDef = definition as any;\n      writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\n      writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\n      writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\n\n      // Merge hostBindings\n      const superHostBindings = superDef.hostBindings;\n      superHostBindings && inheritHostBindings(definition, superHostBindings);\n\n      // Merge queries\n      const superViewQuery = superDef.viewQuery;\n      const superContentQueries = superDef.contentQueries;\n      superViewQuery && inheritViewQuery(definition, superViewQuery);\n      superContentQueries && inheritContentQueries(definition, superContentQueries);\n\n      // Merge inputs and outputs\n      fillProperties(definition.inputs, superDef.inputs);\n      fillProperties(definition.declaredInputs, superDef.declaredInputs);\n      fillProperties(definition.outputs, superDef.outputs);\n\n      // Inherit hooks\n      // Assume super class inheritance feature has already run.\n      definition.afterContentChecked =\n          definition.afterContentChecked || superDef.afterContentChecked;\n      definition.afterContentInit = definition.afterContentInit || superDef.afterContentInit;\n      definition.afterViewChecked = definition.afterViewChecked || superDef.afterViewChecked;\n      definition.afterViewInit = definition.afterViewInit || superDef.afterViewInit;\n      definition.doCheck = definition.doCheck || superDef.doCheck;\n      definition.onDestroy = definition.onDestroy || superDef.onDestroy;\n      definition.onInit = definition.onInit || superDef.onInit;\n\n      // Run parent features\n      const features = superDef.features;\n      if (features) {\n        for (let i = 0; i < features.length; i++) {\n          const feature = features[i];\n          if (feature && feature.ngInherit) {\n            (feature as DirectiveDefFeature)(definition);\n          }\n        }\n      }\n    }\n\n    superType = Object.getPrototypeOf(superType);\n  }\n}\n\nfunction maybeUnwrapEmpty<T>(value: T[]): T[];\nfunction maybeUnwrapEmpty<T>(value: T): T;\nfunction maybeUnwrapEmpty(value: any): any {\n  if (value === EMPTY_OBJ) {\n    return {};\n  } else if (value === EMPTY_ARRAY) {\n    return [];\n  } else {\n    return value;\n  }\n}\n\nfunction inheritViewQuery(\n    definition: DirectiveDef<any>| ComponentDef<any>, superViewQuery: ViewQueriesFunction<any>) {\n  const prevViewQuery = definition.viewQuery;\n\n  if (prevViewQuery) {\n    definition.viewQuery = (rf, ctx) => {\n      superViewQuery(rf, ctx);\n      prevViewQuery(rf, ctx);\n    };\n  } else {\n    definition.viewQuery = superViewQuery;\n  }\n}\n\nfunction inheritContentQueries(\n    definition: DirectiveDef<any>| ComponentDef<any>,\n    superContentQueries: ContentQueriesFunction<any>) {\n  const prevContentQueries = definition.contentQueries;\n\n  if (prevContentQueries) {\n    definition.contentQueries = (rf, ctx, directiveIndex) => {\n      superContentQueries(rf, ctx, directiveIndex);\n      prevContentQueries(rf, ctx, directiveIndex);\n    };\n  } else {\n    definition.contentQueries = superContentQueries;\n  }\n}\n\nfunction inheritHostBindings(\n    definition: DirectiveDef<any>| ComponentDef<any>,\n    superHostBindings: HostBindingsFunction<any>) {\n  const prevHostBindings = definition.hostBindings;\n  // If the subclass does not have a host bindings function, we set the subclass host binding\n  // function to be the superclass's (in this feature). We should check if they're the same here\n  // to ensure we don't inherit it twice.\n  if (superHostBindings !== prevHostBindings) {\n    if (prevHostBindings) {\n      definition.hostBindings = (rf: RenderFlags, ctx: any, elementIndex: number) => {\n        superHostBindings(rf, ctx, elementIndex);\n        prevHostBindings(rf, ctx, elementIndex);\n      };\n    } else {\n      definition.hostBindings = superHostBindings;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentDef, DirectiveDef} from '../interfaces/definition';\nimport {isComponentDef} from '../interfaces/type_checks';\n\nimport {getSuperType} from './inherit_definition_feature';\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `ÉµÉµCopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS: (keyof DirectiveDef<unknown>)[] = [\n  // The child class should use the providers of its parent.\n  'providersResolver',\n\n  // Not listed here are any fields which are handled by the `ÉµÉµInheritDefinitionFeature`, such\n  // as inputs, outputs, and host binding functions.\n];\n\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `ÉµÉµCopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS: Exclude<keyof ComponentDef<unknown>, keyof DirectiveDef<unknown>>[] = [\n  // The child class should use the template function of its parent, including all template\n  // semantics.\n  'template',\n  'decls',\n  'consts',\n  'vars',\n  'onPush',\n  'ngContentSelectors',\n\n  // The child class should use the CSS styles of its parent, including all styling semantics.\n  'styles',\n  'encapsulation',\n\n  // The child class should be checked by the runtime in the same way as its parent.\n  'schemas',\n];\n\n/**\n * Copies the fields not handled by the `ÉµÉµInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ÉµÉµCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nexport function ÉµÉµCopyDefinitionFeature(definition: DirectiveDef<any>| ComponentDef<any>): void {\n  let superType = getSuperType(definition.type) !;\n\n  let superDef: DirectiveDef<any>|ComponentDef<any>|undefined = undefined;\n  if (isComponentDef(definition)) {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.Éµcmp !;\n  } else {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.Éµdir !;\n  }\n\n  // Needed because `definition` fields are readonly.\n  const defAny = (definition as any);\n\n  // Copy over any fields that apply to either directives or components.\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n\n  if (isComponentDef(superDef)) {\n    // Copy over any component-specific fields.\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nexport class SimpleChange {\n  constructor(public previousValue: any, public currentValue: any, public firstChange: boolean) {}\n  /**\n   * Check whether the new value is the first value assigned.\n   */\n  isFirstChange(): boolean { return this.firstChange; }\n}\n\n/**\n * A hashtable of changes represented by {@link SimpleChange} objects stored\n * at the declared property name they belong to on a Directive or Component. This is\n * the type passed to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nexport interface SimpleChanges { [propName: string]: SimpleChange; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OnChanges} from '../../interface/lifecycle_hooks';\nimport {SimpleChange, SimpleChanges} from '../../interface/simple_change';\nimport {EMPTY_OBJ} from '../empty';\nimport {DirectiveDef, DirectiveDefFeature} from '../interfaces/definition';\n\nconst PRIVATE_PREFIX = '__ngOnChanges_';\n\ntype OnChangesExpando = OnChanges & {\n  __ngOnChanges_: SimpleChanges|null|undefined;\n  // tslint:disable-next-line:no-any Can hold any value\n  [key: string]: any;\n};\n\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static Éµcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature()]\n * });\n * ```\n *\n * @codeGenApi\n */\nexport function ÉµÉµNgOnChangesFeature<T>(): DirectiveDefFeature {\n  // This option ensures that the ngOnChanges lifecycle hook will be inherited\n  // from superclasses (in InheritDefinitionFeature).\n  (NgOnChangesFeatureImpl as DirectiveDefFeature).ngInherit = true;\n  return NgOnChangesFeatureImpl;\n}\n\nfunction NgOnChangesFeatureImpl<T>(definition: DirectiveDef<T>): void {\n  if (definition.type.prototype.ngOnChanges) {\n    definition.setInput = ngOnChangesSetInput;\n    definition.onChanges = wrapOnChanges();\n  }\n}\n\nfunction wrapOnChanges() {\n  return function wrapOnChangesHook_inPreviousChangesStorage(this: OnChanges) {\n    const simpleChangesStore = getSimpleChangesStore(this);\n    const current = simpleChangesStore && simpleChangesStore.current;\n\n    if (current) {\n      const previous = simpleChangesStore !.previous;\n      if (previous === EMPTY_OBJ) {\n        simpleChangesStore !.previous = current;\n      } else {\n        // New changes are copied to the previous store, so that we don't lose history for inputs\n        // which were not changed this time\n        for (let key in current) {\n          previous[key] = current[key];\n        }\n      }\n      simpleChangesStore !.current = null;\n      this.ngOnChanges(current);\n    }\n  };\n}\n\nfunction ngOnChangesSetInput<T>(\n    this: DirectiveDef<T>, instance: T, value: any, publicName: string, privateName: string): void {\n  const simpleChangesStore = getSimpleChangesStore(instance) ||\n      setSimpleChangesStore(instance, {previous: EMPTY_OBJ, current: null});\n  const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n  const previous = simpleChangesStore.previous;\n\n  const declaredName = (this.declaredInputs as{[key: string]: string})[publicName];\n  const previousChange = previous[declaredName];\n  current[declaredName] = new SimpleChange(\n      previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n\n  (instance as any)[privateName] = value;\n}\n\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\n\nfunction getSimpleChangesStore(instance: any): null|NgSimpleChangesStore {\n  return instance[SIMPLE_CHANGES_STORE] || null;\n}\n\nfunction setSimpleChangesStore(instance: any, store: NgSimpleChangesStore): NgSimpleChangesStore {\n  return instance[SIMPLE_CHANGES_STORE] = store;\n}\n\ninterface NgSimpleChangesStore {\n  previous: SimpleChanges;\n  current: SimpleChanges|null;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {resolveForwardRef} from '../di/forward_ref';\nimport {ClassProvider, Provider} from '../di/interface/provider';\nimport {isClassProvider, isTypeProvider, providerToFactory} from '../di/r3_injector';\n\nimport {diPublicInInjector, getNodeInjectable, getOrCreateNodeInjectorForNode} from './di';\nimport {ÉµÉµdirectiveInject} from './instructions/all';\nimport {DirectiveDef} from './interfaces/definition';\nimport {NodeInjectorFactory} from './interfaces/injector';\nimport {TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TNodeProviderIndexes} from './interfaces/node';\nimport {isComponentDef} from './interfaces/type_checks';\nimport {LView, TData, TVIEW, TView} from './interfaces/view';\nimport {getLView, getPreviousOrParentTNode} from './state';\n\n\n\n/**\n * Resolves the providers which are defined in the DirectiveDef.\n *\n * When inserting the tokens and the factories in their respective arrays, we can assume that\n * this method is called first for the component (if any), and then for other directives on the same\n * node.\n * As a consequence,the providers are always processed in that order:\n * 1) The view providers of the component\n * 2) The providers of the component\n * 3) The providers of the other directives\n * This matches the structure of the injectables arrays of a view (for each node).\n * So the tokens and the factories can be pushed at the end of the arrays, except\n * in one case for multi providers.\n *\n * @param def the directive definition\n * @param providers: Array of `providers`.\n * @param viewProviders: Array of `viewProviders`.\n */\nexport function providersResolver<T>(\n    def: DirectiveDef<T>, providers: Provider[], viewProviders: Provider[]): void {\n  const lView = getLView();\n  const tView: TView = lView[TVIEW];\n  if (tView.firstCreatePass) {\n    const isComponent = isComponentDef(def);\n\n    // The list of view providers is processed first, and the flags are updated\n    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);\n\n    // Then, the list of providers is processed, and the flags are updated\n    resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);\n  }\n}\n\n/**\n * Resolves a provider and publishes it to the DI system.\n */\nfunction resolveProvider(\n    provider: Provider, tInjectables: TData, lInjectablesBlueprint: NodeInjectorFactory[],\n    isComponent: boolean, isViewProvider: boolean): void {\n  provider = resolveForwardRef(provider);\n  if (Array.isArray(provider)) {\n    // Recursively call `resolveProvider`\n    // Recursion is OK in this case because this code will not be in hot-path once we implement\n    // cloning of the initial state.\n    for (let i = 0; i < provider.length; i++) {\n      resolveProvider(\n          provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);\n    }\n  } else {\n    const lView = getLView();\n    const tView = lView[TVIEW];\n    let token: any = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n    let providerFactory: () => any = providerToFactory(provider);\n\n    const tNode = getPreviousOrParentTNode();\n    const beginIndex = tNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n    const endIndex = tNode.directiveStart;\n    const cptViewProvidersCount =\n        tNode.providerIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n\n    if (isClassProvider(provider) || isTypeProvider(provider)) {\n      const prototype = ((provider as ClassProvider).useClass || provider).prototype;\n      const ngOnDestroy = prototype.ngOnDestroy;\n\n      if (ngOnDestroy) {\n        (tView.destroyHooks || (tView.destroyHooks = [])).push(tInjectables.length, ngOnDestroy);\n      }\n    }\n\n    if (isTypeProvider(provider) || !provider.multi) {\n      // Single provider case: the factory is created and pushed immediately\n      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ÉµÉµdirectiveInject);\n      const existingFactoryIndex = indexOf(\n          token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount,\n          endIndex);\n      if (existingFactoryIndex == -1) {\n        diPublicInInjector(\n            getOrCreateNodeInjectorForNode(\n                tNode as TElementNode | TContainerNode | TElementContainerNode, lView),\n            tView, token);\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n        if (isViewProvider) {\n          tNode.providerIndexes += TNodeProviderIndexes.CptViewProvidersCountShifter;\n        }\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        lInjectablesBlueprint[existingFactoryIndex] = factory;\n        lView[existingFactoryIndex] = factory;\n      }\n    } else {\n      // Multi provider case:\n      // We create a multi factory which is going to aggregate all the values.\n      // Since the output of such a factory depends on content or view injection,\n      // we create two of them, which are linked together.\n      //\n      // The first one (for view providers) is always in the first block of the injectables array,\n      // and the second one (for providers) is always in the second block.\n      // This is important because view providers have higher priority. When a multi token\n      // is being looked up, the view providers should be found first.\n      // Note that it is not possible to have a multi factory in the third block (directive block).\n      //\n      // The algorithm to process multi providers is as follows:\n      // 1) If the multi provider comes from the `viewProviders` of the component:\n      //   a) If the special view providers factory doesn't exist, it is created and pushed.\n      //   b) Else, the multi provider is added to the existing multi factory.\n      // 2) If the multi provider comes from the `providers` of the component or of another\n      // directive:\n      //   a) If the multi factory doesn't exist, it is created and provider pushed into it.\n      //      It is also linked to the multi factory for view providers, if it exists.\n      //   b) Else, the multi provider is added to the existing multi factory.\n\n      const existingProvidersFactoryIndex =\n          indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\n      const existingViewProvidersFactoryIndex =\n          indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\n      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 &&\n          lInjectablesBlueprint[existingProvidersFactoryIndex];\n      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 &&\n          lInjectablesBlueprint[existingViewProvidersFactoryIndex];\n\n      if (isViewProvider && !doesViewProvidersFactoryExist ||\n          !isViewProvider && !doesProvidersFactoryExist) {\n        // Cases 1.a and 2.a\n        diPublicInInjector(\n            getOrCreateNodeInjectorForNode(\n                tNode as TElementNode | TContainerNode | TElementContainerNode, lView),\n            tView, token);\n        const factory = multiFactory(\n            isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver,\n            lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);\n        if (!isViewProvider && doesViewProvidersFactoryExist) {\n          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\n        }\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n        if (isViewProvider) {\n          tNode.providerIndexes += TNodeProviderIndexes.CptViewProvidersCountShifter;\n        }\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        // Cases 1.b and 2.b\n        multiFactoryAdd(\n            lInjectablesBlueprint ![isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex],\n            providerFactory, !isViewProvider && isComponent);\n      }\n      if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {\n        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders !++;\n      }\n    }\n  }\n}\n\n/**\n * Add a factory in a multi factory.\n */\nfunction multiFactoryAdd(\n    multiFactory: NodeInjectorFactory, factory: () => any, isComponentProvider: boolean): void {\n  multiFactory.multi !.push(factory);\n  if (isComponentProvider) {\n    multiFactory.componentProviders !++;\n  }\n}\n\n/**\n * Returns the index of item in the array, but only in the begin to end range.\n */\nfunction indexOf(item: any, arr: any[], begin: number, end: number) {\n  for (let i = begin; i < end; i++) {\n    if (arr[i] === item) return i;\n  }\n  return -1;\n}\n\n/**\n * Use this with `multi` `providers`.\n */\nfunction multiProvidersFactoryResolver(\n    this: NodeInjectorFactory, _: undefined, tData: TData, lData: LView,\n    tNode: TDirectiveHostNode): any[] {\n  return multiResolve(this.multi !, []);\n}\n\n/**\n * Use this with `multi` `viewProviders`.\n *\n * This factory knows how to concatenate itself with the existing `multi` `providers`.\n */\nfunction multiViewProvidersFactoryResolver(\n    this: NodeInjectorFactory, _: undefined, tData: TData, lView: LView,\n    tNode: TDirectiveHostNode): any[] {\n  const factories = this.multi !;\n  let result: any[];\n  if (this.providerFactory) {\n    const componentCount = this.providerFactory.componentProviders !;\n    const multiProviders =\n        getNodeInjectable(lView, lView[TVIEW], this.providerFactory !.index !, tNode);\n    // Copy the section of the array which contains `multi` `providers` from the component\n    result = multiProviders.slice(0, componentCount);\n    // Insert the `viewProvider` instances.\n    multiResolve(factories, result);\n    // Copy the section of the array which contains `multi` `providers` from other directives\n    for (let i = componentCount; i < multiProviders.length; i++) {\n      result.push(multiProviders[i]);\n    }\n  } e